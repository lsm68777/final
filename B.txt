#!/usr/bin/env python3
"""
ğŸ¦ Phoenix 95 Complete System - ì™„ì „ í†µí•© í—¤ì§€í€ë“œê¸‰ ì‹œìŠ¤í…œ (ìˆ˜ì •ë¨)
================================================================================

ğŸ”§ ì•ˆì „ì„± ìš°ì„  ì„¤ê³„ + ê³ ê¸‰ ê¸°ëŠ¥:
âœ… ì˜ì¡´ì„± ì˜¤ë¥˜ ë°©ì§€ (ì„ íƒì  import + ê¸°ë³¸ê°’)
âœ… ëŸ°íƒ€ì„ ì˜¤ë¥˜ ë°©ì§€ (íƒ€ì… ì•ˆì „ì„± + None ì²´í¬)
âœ… ë©”ëª¨ë¦¬ ì•ˆì „ì„± (ìë™ ì •ë¦¬ + GC)
âœ… ì˜ˆì™¸ ì²˜ë¦¬ ê°•í™” (ëª¨ë“  í•¨ìˆ˜ì— try-catch)
âœ… ì„¤ì • ì•ˆì „ì„± (í™˜ê²½ë³€ìˆ˜ + ê¸°ë³¸ê°’)
âœ… ë³´ì•ˆ ê°ì‚¬ ë¡œê¹… (ë¯¼ê°ì •ë³´ í•„í„°ë§)
âœ… ì‹¤ì‹œê°„ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§
âœ… ê³ ê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ (Kelly Criterion)
âœ… ë©€í‹°ëª¨ë“œ ì‹¤í–‰ (ë‹¨ìˆœ/ê³ ê¸‰ ëª¨ë“œ)

ğŸ’ 4ëŒ€ í•µì‹¬ ì»´í¬ë„ŒíŠ¸:
- ğŸ§  BRAIN: Signal Intelligence Engine (Phoenix 95 AI)
- âš–ï¸ RISK: Position & Risk Manager (Kelly + í—¤ì§€í€ë“œê¸‰)
- âš¡ EXECUTE: Trade Execution Engine (ì‹¤ì‹œê°„ ê±°ë˜)
- ğŸ“± NOTIFY: Alert & Monitor Hub (ë‹¤ì¤‘ ì±„ë„ ì•Œë¦¼)

================================================================================
"""

import asyncio
import time
import json
import logging
import os
import sys
import gc
import threading
import hashlib
import hmac
import secrets
import re
import html
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Union, Tuple  # Tuple ì¶”ê°€
from pathlib import Path
import multiprocessing

# =============================================================================
# ğŸ”’ Safe Imports with Fallbacks (ì•ˆì „í•œ ì˜ì¡´ì„± ê´€ë¦¬)
# =============================================================================

# ê¸°ë³¸ ë¡œê¹… ì„¤ì •
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger(__name__)

# FastAPI ì„ íƒì  import
FASTAPI_AVAILABLE = False
try:
    from fastapi import FastAPI, HTTPException, Request, Response
    from fastapi.middleware.cors import CORSMiddleware
    from fastapi.middleware.base import BaseHTTPMiddleware
    from fastapi.responses import HTMLResponse, JSONResponse, PlainTextResponse
    from pydantic import BaseModel, field_validator
    import uvicorn
    FASTAPI_AVAILABLE = True
    logger.info("âœ… FastAPI ì‚¬ìš© ê°€ëŠ¥")
except ImportError:
    logger.warning("âš ï¸ FastAPI ë¯¸ì„¤ì¹˜ - ê¸°ë³¸ ëª¨ë“œë¡œ ì‹¤í–‰")
    class BaseModel:
        pass

# ë„¤íŠ¸ì›Œí¬ ë¼ì´ë¸ŒëŸ¬ë¦¬ ì„ íƒì  import
REQUESTS_AVAILABLE = False
try:
    import requests
    REQUESTS_AVAILABLE = True
    logger.info("âœ… Requests ì‚¬ìš© ê°€ëŠ¥")
except ImportError:
    logger.warning("âš ï¸ Requests ë¯¸ì„¤ì¹˜ - í…”ë ˆê·¸ë¨ ê¸°ëŠ¥ ì œí•œ")

# ê³ ê¸‰ ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸
AIOHTTP_AVAILABLE = False
try:
    import aiohttp
    AIOHTTP_AVAILABLE = True
    logger.info("âœ… aiohttp ì‚¬ìš© ê°€ëŠ¥")
except ImportError:
    logger.warning("âš ï¸ aiohttp ë¯¸ì„¤ì¹˜ - ê³ ê¸‰ ë„¤íŠ¸ì›Œí¬ ê¸°ëŠ¥ ì œí•œ")

# ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§
PSUTIL_AVAILABLE = False
try:
    import psutil
    PSUTIL_AVAILABLE = True
    logger.info("âœ… psutil ì‚¬ìš© ê°€ëŠ¥")
except ImportError:
    logger.warning("âš ï¸ psutil ë¯¸ì„¤ì¹˜ - ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì œí•œ")

# ìˆ˜ì¹˜ ì—°ì‚°
NUMPY_AVAILABLE = False
try:
    import numpy as np
    NUMPY_AVAILABLE = True
    logger.info("âœ… numpy ì‚¬ìš© ê°€ëŠ¥")
except ImportError:
    logger.warning("âš ï¸ numpy ë¯¸ì„¤ì¹˜ - ê³ ê¸‰ ìˆ˜ì¹˜ ì—°ì‚° ì œí•œ")

# JWT ì„ íƒì  import
JWT_AVAILABLE = False
try:
    import jwt
    JWT_AVAILABLE = True
    logger.info("âœ… JWT ì‚¬ìš© ê°€ëŠ¥")
except ImportError:
    logger.warning("âš ï¸ JWT ë¯¸ì„¤ì¹˜ - í† í° ê¸°ëŠ¥ ë¹„í™œì„±í™”")

# =============================================================================
# ğŸ›¡ï¸ Security Logging System (ë³´ì•ˆ ë¡œê¹… ì‹œìŠ¤í…œ)
# =============================================================================

class SecureLogger:
    """ë¯¼ê°ì •ë³´ë¥¼ í•„í„°ë§í•˜ëŠ” ì•ˆì „í•œ ë¡œê¹… ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.sensitive_patterns = [
            r'[A-Za-z0-9]{60,}',  # API í‚¤ íŒ¨í„´
            r'bot\d+:[A-Za-z0-9_-]+',  # í…”ë ˆê·¸ë¨ ë´‡ í† í°
            r'password["\']?\s*[:=]\s*["\']?([^"\']+)',  # íŒ¨ìŠ¤ì›Œë“œ
            r'secret["\']?\s*[:=]\s*["\']?([^"\']+)',  # ì‹œí¬ë¦¿
        ]
        
        # ë¡œê·¸ ì„¤ì •
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
            handlers=[
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger("Phoenix95")
    
    def sanitize_log(self, message: str) -> str:
        """ë¡œê·¸ ë©”ì‹œì§€ì—ì„œ ë¯¼ê°ì •ë³´ ì œê±°"""
        message = str(message)
        for pattern in self.sensitive_patterns:
            message = re.sub(pattern, '[REDACTED]', message, flags=re.IGNORECASE)
        return message
    
    def info(self, message: str):
        self.logger.info(self.sanitize_log(message))
    
    def warning(self, message: str):
        self.logger.warning(self.sanitize_log(message))
    
    def error(self, message: str):
        self.logger.error(self.sanitize_log(message))

# ì „ì—­ ë³´ì•ˆ ë¡œê±°
secure_logger = SecureLogger()

# =============================================================================
# ğŸ›¡ï¸ Type Safe Math Utilities (ì•ˆì „í•œ ìˆ˜í•™ ì—°ì‚°)
# =============================================================================

class SafeMath:
    """ì™„ì „íˆ ì•ˆì „í•œ ìˆ˜í•™ ì—°ì‚° ìœ í‹¸ë¦¬í‹°"""
    
    @staticmethod
    def safe_float(value: Any, default: float = 0.0) -> float:
        """ì•ˆì „í•œ float ë³€í™˜"""
        try:
            if value is None:
                return default
            if isinstance(value, bool):
                return default
            return float(value)
        except (ValueError, TypeError, OverflowError):
            return default
    
    @staticmethod
    def safe_divide(numerator: Any, denominator: Any, default: float = 0.0) -> float:
        """ì™„ì „íˆ ì•ˆì „í•œ ë‚˜ëˆ„ê¸°"""
        try:
            num = SafeMath.safe_float(numerator)
            den = SafeMath.safe_float(denominator)
            
            if abs(den) < 1e-10:  # 0ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ë°©ì§€
                return default
            
            result = num / den
            
            # NaN, Infinity ì²´í¬
            if not (result == result and abs(result) != float('inf')):
                return default
                
            return result
        except Exception:
            return default
    
    @staticmethod
    def safe_multiply(a: Any, b: Any, default: float = 0.0) -> float:
        """ì•ˆì „í•œ ê³±í•˜ê¸°"""
        try:
            val_a = SafeMath.safe_float(a)
            val_b = SafeMath.safe_float(b)
            
            result = val_a * val_b
            
            # ì˜¤ë²„í”Œë¡œìš° ì²´í¬
            if not (result == result and abs(result) != float('inf')):
                return default
                
            return result
        except Exception:
            return default
    
    @staticmethod
    def clamp(value: Any, min_val: float, max_val: float) -> float:
        """ê°’ ë²”ìœ„ ì œí•œ"""
        try:
            val = SafeMath.safe_float(value)
            min_v = SafeMath.safe_float(min_val)
            max_v = SafeMath.safe_float(max_val)
            
            if min_v > max_v:
                min_v, max_v = max_v, min_v
            
            return max(min_v, min(val, max_v))
        except Exception:
            return min_val

# =============================================================================
# ğŸ”§ Configuration Management (ì„¤ì • ê´€ë¦¬)
# =============================================================================

@dataclass
class SafeConfig:
    """ì•ˆì „í•˜ê³  ìœ ì—°í•œ ì„¤ì • ê´€ë¦¬"""
    
    def __init__(self):
        # ì‹œìŠ¤í…œ ì •ë³´
        self.SYSTEM_VERSION: int = 5
        self.ARCHITECTURE: str = "complete_system"
        self.EXECUTION_MODE: str = os.getenv("PHOENIX_MODE", "SIMPLE")  # SIMPLE or ADVANCED
        
        # ê¸°ë³¸ ê±°ë˜ ì„¤ì •
        self.TRADE_MODE: str = os.getenv('TRADE_MODE', 'TEST')
        self.LEVERAGE: int = int(os.getenv('LEVERAGE', '20'))
        self.STOP_LOSS: float = float(os.getenv('STOP_LOSS', '0.02'))
        self.TAKE_PROFIT: float = float(os.getenv('TAKE_PROFIT', '0.02'))
        
        # ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì„¤ì •
        self.MAX_DAILY_LOSS: float = float(os.getenv('MAX_DAILY_LOSS', '0.02'))
        self.MAX_POSITION_SIZE: float = float(os.getenv('MAX_POSITION_SIZE', '0.05'))
        self.MAX_POSITIONS: int = int(os.getenv('MAX_POSITIONS', '3'))
        self.MIN_CONFIDENCE: float = float(os.getenv('MIN_CONFIDENCE', '0.75'))
        
        # Phoenix 95 ì„¤ì •
        self.PHOENIX_95_CONFIG: Dict[str, Any] = {
            "threshold": float(os.getenv('PHOENIX_THRESHOLD', '0.75')),
            "multiplier": float(os.getenv('PHOENIX_MULTIPLIER', '1.3')),
            "weight": float(os.getenv('PHOENIX_WEIGHT', '0.95')),
            "ai_score_multiplier": 0.35,
            "confidence_adjustment": 0.15,
            "analysis_timeout": 30
        }
        
        # í…”ë ˆê·¸ë¨ ì„¤ì •
        self.TELEGRAM_CONFIG: Dict[str, Any] = {
            "token": os.getenv("TELEGRAM_BOT_TOKEN", ""),
            "chat_id": os.getenv("TELEGRAM_CHAT_ID", ""),
            "enabled": os.getenv("TELEGRAM_ENABLED", "false").lower() == "true",
            "parse_mode": "HTML",
            "timeout": int(os.getenv("TELEGRAM_TIMEOUT", "30"))
        }
        
        # ê±°ë˜ì†Œ API ì„¤ì •
        if self.TRADE_MODE == 'LIVE':
            self.BINANCE_API_KEY = os.getenv('BINANCE_API_KEY')
            self.BINANCE_SECRET = os.getenv('BINANCE_SECRET')
            if not self.BINANCE_API_KEY or not self.BINANCE_SECRET:
                secure_logger.warning("LIVE ëª¨ë“œì´ì§€ë§Œ Binance API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ")
                self.TRADE_MODE = 'TEST'
        else:
            self.BINANCE_API_KEY = 'TEST_MODE'
            self.BINANCE_SECRET = 'TEST_MODE'
        
        # ê±°ë˜ ê°€ëŠ¥ ì‹¬ë³¼
        self.ALLOWED_SYMBOLS: List[str] = [
            "BTCUSDT", "ETHUSDT", "BNBUSDT", "ADAUSDT", "DOGEUSDT",
            "SOLUSDT", "XRPUSDT", "MATICUSDT", "DOTUSDT", "AVAXUSDT"
        ]
        
        # ì„±ëŠ¥ ëª©í‘œ
        self.PERFORMANCE_TARGETS: Dict[str, Any] = {
            "max_response_time_ms": 100.0,
            "max_memory_mb": 200.0,
            "target_success_rate": 0.95,
            "health_check_interval": 30
        }
        
        secure_logger.info(f"ğŸ”§ Phoenix 95 ì„¤ì • ë¡œë“œ ì™„ë£Œ - ëª¨ë“œ: {self.EXECUTION_MODE}")

# ì „ì—­ ì„¤ì •
CONFIG = SafeConfig()

# =============================================================================
# ğŸ›¡ï¸ Input Validation (ì…ë ¥ ê²€ì¦)
# =============================================================================

class InputValidator:
    """ì…ë ¥ ë°ì´í„° ê²€ì¦ ë° ë³´ì•ˆ"""
    
    @staticmethod
    def sanitize_symbol(symbol: str) -> str:
        """ì‹¬ë³¼ ì…ë ¥ ì •ë¦¬"""
        if not isinstance(symbol, str):
            raise ValueError("ì‹¬ë³¼ì€ ë¬¸ìì—´ì´ì–´ì•¼ í•©ë‹ˆë‹¤")
        
        clean_symbol = re.sub(r'[^A-Za-z0-9]', '', symbol).upper()
        
        if not clean_symbol or len(clean_symbol) > 20:
            raise ValueError("ìœ íš¨í•˜ì§€ ì•Šì€ ì‹¬ë³¼ì…ë‹ˆë‹¤")
        
        return clean_symbol
    
    @staticmethod
    def validate_numeric(value: Any, min_val: float, max_val: float, name: str) -> float:
        """ìˆ«ì ë²”ìœ„ ê²€ì¦"""
        try:
            num_value = float(value)
            if not min_val <= num_value <= max_val:
                raise ValueError(f"{name}ì´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: {num_value}")
            return num_value
        except (TypeError, ValueError) as e:
            raise ValueError(f"{name} ë³€í™˜ ì‹¤íŒ¨: {value}") from e

# =============================================================================
# ğŸ“Š Safe Cache System (ì•ˆì „í•œ ìºì‹œ ì‹œìŠ¤í…œ)
# =============================================================================

class SafeCache:
    """ìŠ¤ë ˆë“œ ì•ˆì „í•œ ìºì‹œ (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)"""
    
    def __init__(self, max_size: int = 1000, ttl: int = 300):
        self.cache = {}
        self.access_times = {}
        self.max_size = max_size
        self.ttl = ttl
        self.lock = threading.RLock()
        self.stats = {'hits': 0, 'misses': 0, 'cleanups': 0}
    
    def get(self, key: str) -> Optional[Any]:
        """ìºì‹œì—ì„œ ê°’ ì¡°íšŒ"""
        with self.lock:
            if key not in self.cache:
                self.stats['misses'] += 1
                return None
            
            # TTL í™•ì¸
            if time.time() - self.access_times[key] > self.ttl:
                del self.cache[key]
                del self.access_times[key]
                self.stats['misses'] += 1
                return None
            
            self.stats['hits'] += 1
            return self.cache[key]
    
    def set(self, key: str, value: Any):
        """ìºì‹œì— ê°’ ì €ì¥"""
        with self.lock:
            # ìºì‹œ í¬ê¸° ê´€ë¦¬
            if len(self.cache) >= self.max_size:
                self._cleanup_old_entries()
            
            self.cache[key] = value
            self.access_times[key] = time.time()
    
    def _cleanup_old_entries(self):
        """ì˜¤ë˜ëœ í•­ëª© ì •ë¦¬"""
        current_time = time.time()
        to_remove = []
        
        # TTL ë§Œë£Œëœ í•­ëª© ì°¾ê¸°
        for key, access_time in self.access_times.items():
            if current_time - access_time > self.ttl:
                to_remove.append(key)
        
        # ë§Œë£Œëœ í•­ëª© ì œê±°
        for key in to_remove:
            self.cache.pop(key, None)
            self.access_times.pop(key, None)
            self.stats['cleanups'] += 1
        
        # ì—¬ì „íˆ í¬ê¸°ê°€ í¬ë©´ ê°€ì¥ ì˜¤ë˜ëœ í•­ëª© ì œê±°
        if len(self.cache) >= self.max_size:
            oldest_key = min(self.access_times, key=self.access_times.get)
            self.cache.pop(oldest_key, None)
            self.access_times.pop(oldest_key, None)
            self.stats['cleanups'] += 1
    
    def get_stats(self) -> Dict:
        """ìºì‹œ í†µê³„"""
        with self.lock:
            total_requests = self.stats['hits'] + self.stats['misses']
            hit_rate = self.stats['hits'] / total_requests if total_requests > 0 else 0
            
            return {
                'size': len(self.cache),
                'max_size': self.max_size,
                'hit_rate': round(hit_rate, 3),
                'total_hits': self.stats['hits'],
                'total_misses': self.stats['misses'],
                'cleanups': self.stats['cleanups']
            }

# =============================================================================
# ğŸ“Š Audit Logger (ê°ì‚¬ ë¡œê±°)
# =============================================================================

class AuditLogger:
    """ë³´ì•ˆ ê°ì‚¬ ë¡œê·¸ ì‹œìŠ¤í…œ"""
    
    def __init__(self, max_entries: int = 10000):
        self.audit_log = []
        self.max_entries = max_entries
        self.lock = threading.RLock()
    
    def log_event(self, event_type: str, user_id: str, details: Dict, risk_level: str = 'LOW'):
        """ê°ì‚¬ ì´ë²¤íŠ¸ ë¡œê·¸"""
        with self.lock:
            audit_entry = {
                'timestamp': datetime.now().isoformat(),
                'event_type': event_type,
                'user_id': user_id,
                'details': details,
                'risk_level': risk_level,
                'thread_id': threading.get_ident(),
                'session_id': self._generate_session_id()
            }
            
            # ë¡œê·¸ í¬ê¸° ê´€ë¦¬
            if len(self.audit_log) >= self.max_entries:
                self.audit_log = self.audit_log[-int(self.max_entries * 0.8):]
            
            self.audit_log.append(audit_entry)
            
            # ê³ ìœ„í—˜ ì´ë²¤íŠ¸ëŠ” ì¦‰ì‹œ ë¡œê¹…
            if risk_level in ['HIGH', 'CRITICAL']:
                secure_logger.warning(f"ê°ì‚¬ ì´ë²¤íŠ¸ [{risk_level}]: {event_type} - {details}")
    
    def _generate_session_id(self) -> str:
        """ì„¸ì…˜ ID ìƒì„±"""
        return hashlib.md5(f"{time.time()}{threading.get_ident()}".encode()).hexdigest()[:8]
    
    def get_recent_events(self, count: int = 100, event_type: Optional[str] = None) -> List[Dict]:
        """ìµœê·¼ ì´ë²¤íŠ¸ ì¡°íšŒ"""
        with self.lock:
            events = self.audit_log[-count:] if not event_type else [
                event for event in self.audit_log[-count*2:] 
                if event['event_type'] == event_type
            ][-count:]
            
            return events
    
    def get_risk_summary(self) -> Dict:
        """ë¦¬ìŠ¤í¬ ìš”ì•½"""
        with self.lock:
            if not self.audit_log:
                return {'total': 0, 'by_risk': {}}
            
            risk_counts = {}
            for event in self.audit_log[-1000:]:  # ìµœê·¼ 1000ê°œ
                risk_level = event['risk_level']
                risk_counts[risk_level] = risk_counts.get(risk_level, 0) + 1
            
            return {
                'total': len(self.audit_log),
                'recent_count': min(1000, len(self.audit_log)),
                'by_risk': risk_counts
            }

# ì „ì—­ ê°ì‚¬ ë¡œê±°
audit_logger = AuditLogger()

# =============================================================================
# ğŸŒ Network Client (ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸)
# =============================================================================

class SecureNetworkClient:
    """ì¬ì‹œë„ ë¡œì§ ë° íƒ€ì„ì•„ì›ƒì´ ê°•í™”ëœ ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸"""
    
    def __init__(self):
        self.enabled = AIOHTTP_AVAILABLE
        if self.enabled:
            self.timeout = aiohttp.ClientTimeout(
                total=30,      # ì „ì²´ 30ì´ˆ
                connect=5,     # ì—°ê²° 5ì´ˆ
                sock_read=10   # ì½ê¸° 10ì´ˆ
            )
    
    async def safe_post(self, url: str, data: Optional[Dict] = None, json_data: Optional[Dict] = None) -> Dict:
        """ì•ˆì „í•œ POST ìš”ì²­ (ì¬ì‹œë„ + íƒ€ì„ì•„ì›ƒ)"""
        if not self.enabled:
            secure_logger.warning("aiohttp ë¯¸ì„¤ì¹˜ë¡œ ë„¤íŠ¸ì›Œí¬ ê¸°ëŠ¥ ì œí•œ")
            return {'error': 'aiohttp not available'}
        
        max_retries = 3
        retry_count = 0
        
        while retry_count < max_retries:
            try:
                async with aiohttp.ClientSession(timeout=self.timeout) as session:
                    kwargs = {}
                    if data:
                        kwargs['data'] = data
                    if json_data:
                        kwargs['json'] = json_data
                    
                    async with session.post(url, **kwargs) as response:
                        if response.status == 200:
                            return await response.json()
                        else:
                            error_text = await response.text()
                            secure_logger.error(f"HTTP ì˜¤ë¥˜ {response.status}: {url}")
                            if retry_count == max_retries - 1:
                                return {'error': f'HTTP {response.status}: {error_text}'}
                            
            except asyncio.TimeoutError:
                secure_logger.error(f"íƒ€ì„ì•„ì›ƒ: {url} (ì‹œë„ {retry_count + 1}/{max_retries})")
                if retry_count == max_retries - 1:
                    return {'error': 'Request timeout'}
            except Exception as e:
                secure_logger.error(f"ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: {url} - {e} (ì‹œë„ {retry_count + 1}/{max_retries})")
                if retry_count == max_retries - 1:
                    return {'error': str(e)}
            
            retry_count += 1
            if retry_count < max_retries:
                await asyncio.sleep(min(2 ** retry_count, 10))  # ì§€ìˆ˜ ë°±ì˜¤í”„
        
        return {'error': 'Max retries exceeded'}
    
    async def safe_get(self, url: str) -> Dict:
        """ì•ˆì „í•œ GET ìš”ì²­"""
        if not self.enabled:
            return {'error': 'aiohttp not available'}
        
        max_retries = 3
        retry_count = 0
        
        while retry_count < max_retries:
            try:
                async with aiohttp.ClientSession(timeout=self.timeout) as session:
                    async with session.get(url) as response:
                        if response.status == 200:
                            return await response.json()
                        else:
                            if retry_count == max_retries - 1:
                                return {'error': f'HTTP {response.status}'}
                            
            except Exception as e:
                if retry_count == max_retries - 1:
                    return {'error': str(e)}
            
            retry_count += 1
            if retry_count < max_retries:
                await asyncio.sleep(min(2 ** retry_count, 5))
        
        return {'error': 'Max retries exceeded'}

# ì „ì—­ ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸
network_client = SecureNetworkClient()

# =============================================================================
# ğŸ¯ Safe Data Models (ì•ˆì „í•œ ë°ì´í„° ëª¨ë¸)
# =============================================================================

if FASTAPI_AVAILABLE:
    class SignalRequest(BaseModel):
        """ì‹ í˜¸ ìš”ì²­ ëª¨ë¸"""
        symbol: str
        action: str
        price: float
        confidence: Optional[float] = 0.8
        strategy: Optional[str] = "phoenix95"
        timeframe: Optional[str] = "1h"
        rsi: Optional[float] = None
        macd: Optional[float] = None
        volume: Optional[float] = None
        account_balance: Optional[float] = 10000.0
        
        @field_validator('symbol')
        @classmethod
        def validate_symbol(cls, v):
            if not v or not isinstance(v, str):
                raise ValueError('symbol must be a non-empty string')
            clean_symbol = re.sub(r'[^A-Za-z0-9]', '', v.upper())
            if clean_symbol not in CONFIG.ALLOWED_SYMBOLS:
                raise ValueError(f'symbol must be one of: {CONFIG.ALLOWED_SYMBOLS}')
            return clean_symbol
        
        @field_validator('action')
        @classmethod
        def validate_action(cls, v):
            if v.lower() not in ['buy', 'sell', 'long', 'short']:
                raise ValueError('action must be buy/sell/long/short')
            return v.lower()
        
        @field_validator('price')
        @classmethod
        def validate_price(cls, v):
            if v <= 0:
                raise ValueError('price must be positive')
            return v
else:
    class SignalRequest:
        """ê¸°ë³¸ ì‹ í˜¸ ìš”ì²­ í´ë˜ìŠ¤"""
        def __init__(self, symbol, action, price, confidence=0.8, **kwargs):
            self.symbol = str(symbol).upper().strip() if symbol else ""
            self.action = str(action).lower().strip() if action else ""
            self.price = SafeMath.safe_float(price, 0.0)
            self.confidence = SafeMath.safe_float(confidence, 0.8)
            self.strategy = kwargs.get('strategy', 'phoenix95')
            self.timeframe = kwargs.get('timeframe', '1h')
            self.rsi = SafeMath.safe_float(kwargs.get('rsi')) if kwargs.get('rsi') else None
            self.macd = SafeMath.safe_float(kwargs.get('macd')) if kwargs.get('macd') else None
            self.volume = SafeMath.safe_float(kwargs.get('volume')) if kwargs.get('volume') else None
            self.account_balance = SafeMath.safe_float(kwargs.get('account_balance', 10000.0))

@dataclass
class TradingSignal:
    """ê±°ë˜ ì‹ í˜¸ ë„ë©”ì¸ ëª¨ë¸"""
    symbol: str
    action: str
    price: float
    confidence: float
    strategy: str = "phoenix95"
    timeframe: str = "1h"
    rsi: Optional[float] = None
    macd: Optional[float] = None
    volume: Optional[float] = None
    account_balance: float = 10000.0
    timestamp: float = field(default_factory=time.time)
    signal_id: str = field(default_factory=lambda: f"SIG_{int(time.time() * 1000)}")

@dataclass
class AnalysisResult:
    """ë¶„ì„ ê²°ê³¼"""
    signal_id: str
    original_confidence: float
    phoenix_95_score: float
    final_confidence: float
    quality_score: float
    execution_timing: str
    risk_level: str
    recommended_position_size: float
    analysis_time_ms: float
    technical_indicators: Dict[str, float] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class PositionInfo:
    """í¬ì§€ì…˜ ì •ë³´"""
    kelly_fraction: float
    position_size: float
    margin_required: float
    leveraged_size: float
    leverage: int
    stop_loss_price: float
    take_profit_price: float
    liquidation_price: float
    margin_mode: str
    risk_score: float = 0.0

@dataclass
class TradeResult:
    """ê±°ë˜ ê²°ê³¼"""
    trade_id: str
    signal_id: str
    symbol: str
    action: str
    phoenix_95_score: float
    position_info: PositionInfo
    execution_status: str
    execution_reason: str
    timestamp: float
    processing_time_ms: float
    hedge_fund_grade: bool = False

# =============================================================================
# ğŸ§  BRAIN - Signal Intelligence Engine (AI ë¶„ì„ ì—”ì§„)
# =============================================================================

class SignalBrain:
    """Phoenix 95 AI ì‹ í˜¸ ë¶„ì„ ì—”ì§„"""
    
    def __init__(self, config: SafeConfig):
        self.config = config
        self.phoenix_config = config.PHOENIX_95_CONFIG
        self.validator = InputValidator()
        self.analysis_cache = SafeCache(max_size=1000, ttl=300)  # 5ë¶„ TTL
        
        # V5 ê°€ì¤‘ì¹˜ ë§¤í•‘ (ê°œì„ ë¨)
        self.timeframe_weights = {
            "1m": 0.8, "5m": 0.9, "15m": 1.0,
            "1h": 1.1, "4h": 1.2, "1d": 1.3
        }
        
        self.strategy_weights = {
            "momentum": 1.1, "mean_reversion": 1.05, "breakout": 1.15,
            "scalping": 0.95, "swing": 1.1, "phoenix95": 1.3, "unknown": 1.0
        }
        
        secure_logger.info("ğŸ§  BRAIN: Phoenix 95 Signal Intelligence Engine ì´ˆê¸°í™” ì™„ë£Œ")
    
    def analyze_signal(self, signal: TradingSignal) -> AnalysisResult:
        """Phoenix 95 AI ë¶„ì„ (ê°œì„ ëœ ë²„ì „)"""
        try:
            start_time = time.time()
            
            # ìºì‹œ í‚¤ ìƒì„± ë° í™•ì¸
            cache_key = self._generate_cache_key(signal)
            cached_result = self.analysis_cache.get(cache_key)
            
            if cached_result:
                cached_result.metadata['from_cache'] = True
                cached_result.metadata['cache_stats'] = self.analysis_cache.get_stats()
                return cached_result
            
            # 1. ê¸°ë³¸ Phoenix 95 ì ìˆ˜ ê³„ì‚°
            original_confidence = SafeMath.clamp(signal.confidence, 0.0, 1.0)
            phoenix_multiplier = SafeMath.safe_float(self.phoenix_config.get("multiplier", 1.3))
            base_phoenix_score = SafeMath.clamp(
                SafeMath.safe_multiply(original_confidence, phoenix_multiplier),
                0.0, 1.0
            )
            
            # 2. ê³ ê¸‰ ê¸°ìˆ ì  ì§€í‘œ ë¶„ì„
            technical_score = self._analyze_technical_advanced(signal)
            volume_score = self._analyze_volume_advanced(signal)
            momentum_score = self._analyze_momentum_advanced(signal)
            
            # 3. Phoenix 95 ì¢…í•© ì ìˆ˜ ê³„ì‚° (ê°€ì¤‘ í‰ê· )
            component_scores = {
                'technical': technical_score,
                'volume': volume_score,
                'momentum': momentum_score,
                'base_phoenix': base_phoenix_score
            }
            
            # ê°€ì¤‘ì¹˜ ì ìš©
            technical_weight = 0.25
            volume_weight = 0.25
            momentum_weight = 0.25
            phoenix_weight = 0.25
            
            phoenix_95_score = (
                technical_score * technical_weight +
                volume_score * volume_weight +
                momentum_score * momentum_weight +
                base_phoenix_score * phoenix_weight
            )
            
            # 4. ì‹œê°„ëŒ€ ë° ì „ëµ ê°€ì¤‘ì¹˜ ì ìš©
            timeframe_weight = self.timeframe_weights.get(signal.timeframe, 1.0)
            strategy_weight = self.strategy_weights.get(signal.strategy, 1.0)
            
            phoenix_95_score = SafeMath.clamp(
                SafeMath.safe_multiply(
                    phoenix_95_score,
                    SafeMath.safe_multiply(timeframe_weight, strategy_weight)
                ),
                0.0, 1.0
            )
            
            # 5. ìµœì¢… ì‹ ë¢°ë„ ì¡°ì •
            confidence_adjustment = SafeMath.safe_float(self.phoenix_config.get("confidence_adjustment", 0.15))
            final_confidence = SafeMath.clamp(phoenix_95_score + confidence_adjustment, 0.0, 1.0)
            
            # 6. í’ˆì§ˆ ì ìˆ˜ ê³„ì‚°
            quality_factors = [
                1.0 if signal.rsi is not None else 0.8,
                1.0 if signal.macd is not None else 0.8,
                1.0 if signal.volume is not None else 0.9,
                1.0 if signal.strategy != "unknown" else 0.7,
                1.0 if signal.account_balance > 0 else 0.5
            ]
            quality_score = sum(quality_factors) / len(quality_factors) if quality_factors else 0.0
            
            # 7. ì‹¤í–‰ íƒ€ì´ë° ë° ë¦¬ìŠ¤í¬ ë ˆë²¨ ê²°ì •
            threshold = SafeMath.safe_float(self.phoenix_config.get("threshold", 0.75))
            execution_timing, risk_level = self._determine_execution_strategy(final_confidence, threshold, quality_score)
            
            # 8. Kelly í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
            recommended_position_size = self._calculate_kelly_position_size(final_confidence, signal.account_balance)
            
            analysis_time = (time.time() - start_time) * 1000
            
            # ê²°ê³¼ ìƒì„±
            result = AnalysisResult(
                signal_id=signal.signal_id,
                original_confidence=original_confidence,
                phoenix_95_score=phoenix_95_score,
                final_confidence=final_confidence,
                quality_score=quality_score,
                execution_timing=execution_timing,
                risk_level=risk_level,
                recommended_position_size=recommended_position_size,
                analysis_time_ms=round(analysis_time, 2),
                technical_indicators=component_scores,
                metadata={
                    'engine': 'Phoenix 95 V5.0 Complete',
                    'timeframe_weight': timeframe_weight,
                    'strategy_weight': strategy_weight,
                    'from_cache': False,
                    'cache_stats': self.analysis_cache.get_stats()
                }
            )
            
            # ìºì‹œì— ì €ì¥
            self.analysis_cache.set(cache_key, result)
            
            return result
            
        except Exception as e:
            secure_logger.error(f"ğŸ§  BRAIN ë¶„ì„ ì˜¤ë¥˜: {e}")
            # ì•ˆì „í•œ ê¸°ë³¸ê°’ ë°˜í™˜
            return AnalysisResult(
                signal_id=signal.signal_id,
                original_confidence=0.0,
                phoenix_95_score=0.0,
                final_confidence=0.0,
                quality_score=0.0,
                execution_timing="HOLD",
                risk_level="HIGH",
                recommended_position_size=0.01,
                analysis_time_ms=0.0,
                technical_indicators={},
                metadata={'error': str(e)}
            )
    
    def _analyze_technical_advanced(self, signal: TradingSignal) -> float:
        """ê³ ê¸‰ ê¸°ìˆ ì  ë¶„ì„"""
        try:
            scores = []
            
            # RSI ë¶„ì„ (ê°œì„ ë¨)
            if signal.rsi is not None:
                rsi_value = SafeMath.clamp(signal.rsi, 0.0, 100.0)
                if signal.action in ['buy', 'long']:
                    if rsi_value < 30:
                        rsi_score = 0.9  # ê³¼ë§¤ë„ ìƒíƒœì—ì„œ ë§¤ìˆ˜ - ë§¤ìš° ì¢‹ìŒ
                    elif rsi_value < 40:
                        rsi_score = 0.7
                    elif rsi_value < 50:
                        rsi_score = 0.6
                    else:
                        rsi_score = 0.3  # ê³¼ë§¤ìˆ˜ ìƒíƒœì—ì„œ ë§¤ìˆ˜ - ì¢‹ì§€ ì•ŠìŒ
                else:  # sell, short
                    if rsi_value > 70:
                        rsi_score = 0.9  # ê³¼ë§¤ìˆ˜ ìƒíƒœì—ì„œ ë§¤ë„ - ë§¤ìš° ì¢‹ìŒ
                    elif rsi_value > 60:
                        rsi_score = 0.7
                    elif rsi_value > 50:
                        rsi_score = 0.6
                    else:
                        rsi_score = 0.3  # ê³¼ë§¤ë„ ìƒíƒœì—ì„œ ë§¤ë„ - ì¢‹ì§€ ì•ŠìŒ
                
                scores.append(rsi_score)
            
            # MACD ë¶„ì„ (ê°œì„ ë¨)
            if signal.macd is not None:
                macd_value = signal.macd
                if signal.action in ['buy', 'long']:
                    macd_score = 0.5 + SafeMath.clamp(macd_value / 100, -0.4, 0.4)
                else:
                    macd_score = 0.5 - SafeMath.clamp(macd_value / 100, -0.4, 0.4)
                
                scores.append(macd_score)
            
            # ê¸°ë³¸ ì ìˆ˜ (ì§€í‘œê°€ ì—†ëŠ” ê²½ìš°)
            if not scores:
                return 0.5
            
            return sum(scores) / len(scores)
            
        except Exception:
            return 0.5
    
    def _analyze_volume_advanced(self, signal: TradingSignal) -> float:
        """ê³ ê¸‰ ê±°ë˜ëŸ‰ ë¶„ì„"""
        try:
            if signal.volume is None:
                return 0.5
            
            current_volume = SafeMath.safe_float(signal.volume)
            
            # ê±°ë˜ëŸ‰ ê¸°ë°˜ ì‹ ë¢°ë„ ê³„ì‚°
            if current_volume > 5000000:  # ë§¤ìš° ë†’ì€ ê±°ë˜ëŸ‰
                return 0.9
            elif current_volume > 2000000:  # ë†’ì€ ê±°ë˜ëŸ‰
                return 0.8
            elif current_volume > 1000000:  # ë³´í†µ ê±°ë˜ëŸ‰
                return 0.6
            elif current_volume > 500000:   # ë‚®ì€ ê±°ë˜ëŸ‰
                return 0.4
            else:  # ë§¤ìš° ë‚®ì€ ê±°ë˜ëŸ‰
                return 0.2
                
        except Exception:
            return 0.5
    
    def _analyze_momentum_advanced(self, signal: TradingSignal) -> float:
        """ê³ ê¸‰ ëª¨ë©˜í…€ ë¶„ì„"""
        try:
            # ê°€ê²© ê¸°ë°˜ ëª¨ë©˜í…€ ì¶”ì •
            price = SafeMath.safe_float(signal.price)
            confidence = SafeMath.safe_float(signal.confidence)
            
            # ì‹ ë¢°ë„ ê¸°ë°˜ ëª¨ë©˜í…€ ì ìˆ˜
            momentum_score = confidence
            
            # ì¶”ê°€ ì¡°ì • (ê°€ê²© ìˆ˜ì¤€ì— ë”°ë¥¸)
            if price > 50000:  # BTC ë“± ê³ ê°€ ìì‚°
                momentum_score *= 1.1
            elif price > 1000:  # ETH ë“± ì¤‘ê°€ ìì‚°
                momentum_score *= 1.05
            elif price < 1:     # ì €ê°€ ì•ŒíŠ¸ì½”ì¸
                momentum_score *= 0.9
            
            return SafeMath.clamp(momentum_score, 0.0, 1.0)
            
        except Exception:
            return 0.5
    
    def _determine_execution_strategy(self, confidence: float, threshold: float, quality: float) -> Tuple[str, str]:
        """ì‹¤í–‰ ì „ëµ ë° ë¦¬ìŠ¤í¬ ë ˆë²¨ ê²°ì •"""
        try:
            # ì‹¤í–‰ íƒ€ì´ë° ê²°ì •
            if confidence >= threshold and quality >= 0.8:
                execution_timing = "IMMEDIATE"
            elif confidence >= threshold * 0.9 and quality >= 0.7:
                execution_timing = "CAREFUL"
            elif confidence >= threshold * 0.8:
                execution_timing = "MONITOR"
            else:
                execution_timing = "HOLD"
            
            # ë¦¬ìŠ¤í¬ ë ˆë²¨ ê²°ì •
            if confidence >= 0.85 and quality >= 0.8:
                risk_level = "LOW"
            elif confidence >= 0.75 and quality >= 0.7:
                risk_level = "MEDIUM"
            elif confidence >= 0.65:
                risk_level = "HIGH"
            else:
                risk_level = "CRITICAL"
            
            return execution_timing, risk_level
            
        except Exception:
            return "HOLD", "HIGH"
    
    def _calculate_kelly_position_size(self, confidence: float, account_balance: float) -> float:
        """Kelly Criterion í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° (ê°œì„ ë¨)"""
        try:
            if account_balance <= 0:
                return 0.01
            
            # Kelly Criterion ê³„ì‚°
            win_rate = SafeMath.clamp(confidence * 0.85, 0.01, 0.99)
            avg_win = 1.03  # 3% ìˆ˜ìµ ê°€ì •
            avg_loss = 0.97  # 3% ì†ì‹¤ ê°€ì •
            
            # Kelly fraction = (bp - q) / b
            # b = avg_win/avg_loss, p = win_rate, q = 1-win_rate
            b = SafeMath.safe_divide(avg_win, avg_loss, 1.0)
            kelly_fraction = SafeMath.safe_divide(
                (b * win_rate - (1 - win_rate)), 
                b, 
                0.01
            )
            
            # Kelly fraction ì œí•œ (1%-20%)
            kelly_fraction = SafeMath.clamp(kelly_fraction, 0.01, 0.20)
            
            # ìµœëŒ€ í¬ì§€ì…˜ í¬ê¸° ì œí•œ
            max_position = SafeMath.safe_float(CONFIG.MAX_POSITION_SIZE)
            position_size = min(kelly_fraction * account_balance, max_position * account_balance)
            
            return max(account_balance * 0.001, position_size)  # ìµœì†Œ 0.1%
            
        except Exception as e:
            secure_logger.error(f"Kelly ê³„ì‚° ì˜¤ë¥˜: {e}")
            return account_balance * 0.01  # 1% ì•ˆì „í•œ ê¸°ë³¸ê°’
    
    def _generate_cache_key(self, signal: TradingSignal) -> str:
        """ìºì‹œ í‚¤ ìƒì„±"""
        try:
            key_data = {
                'symbol': signal.symbol,
                'action': signal.action,
                'price': round(signal.price, 2),
                'confidence': round(signal.confidence, 3),
                'rsi': round(signal.rsi, 1) if signal.rsi else None,
                'macd': round(signal.macd, 4) if signal.macd else None,
                'volume': signal.volume,
                'timeframe': signal.timeframe,
                'strategy': signal.strategy
            }
            
            # í•´ì‹œ ì¶©ëŒ ë°©ì§€ë¥¼ ìœ„í•´ SHA-256 ì‚¬ìš©
            return hashlib.sha256(json.dumps(key_data, sort_keys=True).encode()).hexdigest()[:16]
            
        except Exception:
            return f"fallback_{int(time.time())}"

# =============================================================================
# âš–ï¸ RISK - Position & Risk Manager (ë¦¬ìŠ¤í¬ ê´€ë¦¬ì)
# =============================================================================

class RiskManager:
    """í—¤ì§€í€ë“œê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œ"""
    
    def __init__(self, config: SafeConfig):
        self.config = config
        self.daily_pnl = 0.0
        self.active_positions = 0
        self.total_exposure = 0.0
        self.last_reset = datetime.now().date()
        self.lock = threading.RLock()
        
        # ê±°ë˜ ê¸°ë¡ (Kelly Criterion ê³„ì‚°ìš©)
        self.trade_history = []
        
        # ë¦¬ìŠ¤í¬ ë©”íŠ¸ë¦­
        self.risk_metrics = {
            'daily_trades': 0,
            'success_rate': 0.0,
            'max_drawdown': 0.0,
            'win_streak': 0,
            'loss_streak': 0,
            'largest_win': 0.0,
            'largest_loss': 0.0,
            'volatility_multiplier': 1.0
        }
        
        secure_logger.info("âš–ï¸ RISK: Position & Risk Manager ì´ˆê¸°í™” ì™„ë£Œ")
    
    def check_trade_approval(self, signal_data: Dict, analysis: Dict) -> Dict:
        """ê±°ë˜ ìŠ¹ì¸ ì—¬ë¶€ ê²°ì • (í—¤ì§€í€ë“œê¸‰)"""
        
        with self.lock:
            checks = []
            approved = True
            risk_level = 'LOW'
            
            try:
                # ê°ì‚¬ ë¡œê·¸
                audit_logger.log_event(
                    'TRADE_APPROVAL_REQUEST',
                    'system',
                    {
                        'symbol': signal_data.get('symbol', 'UNKNOWN'),
                        'confidence': analysis.get('confidence', 0)
                    }
                )
                
                # ì¼ì¼ ë¦¬ì…‹ ì²´í¬
                self._check_daily_reset()
                
                # ì…ë ¥ ë°ì´í„° ê²€ì¦
                if not self._validate_inputs(signal_data, analysis):
                    audit_logger.log_event(
                        'TRADE_APPROVAL_DENIED',
                        'system',
                        {'reason': 'Invalid input data'},
                        'HIGH'
                    )
                    return self._create_error_response("ì…ë ¥ ë°ì´í„° ì˜¤ë¥˜")
                
                # 1. ì¼ì¼ ì†ì‹¤ í•œë„ ì²´í¬ (ìµœìš°ì„ )
                if abs(self.daily_pnl) >= CONFIG.MAX_DAILY_LOSS:
                    approved = False
                    risk_level = 'CRITICAL'
                    checks.append(f"ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼: {self.daily_pnl:.2%}")
                
                # 2. í¬ì§€ì…˜ ìˆ˜ í•œë„ ì²´í¬
                if self.active_positions >= CONFIG.MAX_POSITIONS:
                    approved = False
                    risk_level = 'HIGH'
                    checks.append(f"ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ë„ë‹¬: {self.active_positions}/{CONFIG.MAX_POSITIONS}")
                
                # 3. ì‹ ë¢°ë„ ì²´í¬
                confidence = analysis.get('confidence', 0)
                if confidence < CONFIG.MIN_CONFIDENCE:
                    approved = False
                    risk_level = 'MEDIUM'
                    checks.append(f"ì‹ ë¢°ë„ ë¶€ì¡±: {confidence:.3f} < {CONFIG.MIN_CONFIDENCE}")
                
                # 4. ê³ ê¸‰ Kelly Criterion í¬ì§€ì…˜ ì‚¬ì´ì§•
                account_balance = signal_data.get('account_balance', 10000)
                position_size = self._calculate_advanced_kelly_size(
                    account_balance, confidence
                ) if approved else 0
                
                # 5. ì´ ë…¸ì¶œ í•œë„ ì²´í¬
                if account_balance > 0:
                    projected_exposure = self.total_exposure + (position_size / account_balance)
                    max_exposure = 0.20 * self.risk_metrics['volatility_multiplier']
                    if projected_exposure > max_exposure:
                        approved = False
                        risk_level = 'HIGH'
                        checks.append(f"ì´ ë…¸ì¶œ í•œë„ ì´ˆê³¼: {projected_exposure:.2%} > {max_exposure:.2%}")
                else:
                    projected_exposure = 0
                
                # 6. ì—°ì† ì†ì‹¤ ì²´í¬
                if self.risk_metrics['loss_streak'] >= 3:
                    position_size *= 0.5  # ì—°ì† ì†ì‹¤ì‹œ í¬ì§€ì…˜ í¬ê¸° 50% ê°ì†Œ
                    checks.append(f"ì—°ì† ì†ì‹¤ë¡œ ì¸í•œ í¬ì§€ì…˜ í¬ê¸° ê°ì†Œ: {self.risk_metrics['loss_streak']}íšŒ")
                
                # 7. ì‹¬ë³¼ë³„ ì¶”ê°€ ì²´í¬
                symbol = signal_data.get('symbol', '')
                if symbol not in CONFIG.ALLOWED_SYMBOLS:
                    approved = False
                    risk_level = 'HIGH'
                    checks.append(f"í—ˆìš©ë˜ì§€ ì•ŠëŠ” ì‹¬ë³¼: {symbol}")
                
                # ê°ì‚¬ ë¡œê·¸
                audit_logger.log_event(
                    'TRADE_APPROVAL_RESULT',
                    'system',
                    {
                        'approved': approved,
                        'risk_level': risk_level,
                        'position_size': position_size,
                        'checks_count': len(checks)
                    },
                    'HIGH' if not approved else 'LOW'
                )
                
                return {
                    'approved': approved,
                    'position_size': round(position_size, 2),
                    'position_size_pct': round(position_size / account_balance, 4) if account_balance > 0 else 0,
                    'risk_level': risk_level,
                    'checks': checks,
                    'risk_metrics': {
                        'current_exposure': round(self.total_exposure, 4),
                        'projected_exposure': round(projected_exposure, 4),
                        'daily_pnl': round(self.daily_pnl, 4),
                        'active_positions': self.active_positions,
                        'volatility_multiplier': round(self.risk_metrics['volatility_multiplier'], 3),
                        'loss_streak': self.risk_metrics['loss_streak']
                    },
                    'kelly_sizing': {
                        'base_size': round(position_size * 0.8, 2),
                        'confidence_adjusted': round(position_size, 2),
                        'max_allowed': round(account_balance * CONFIG.MAX_POSITION_SIZE, 2) if account_balance > 0 else 0
                    }
                }
                
            except Exception as e:
                secure_logger.error(f"ë¦¬ìŠ¤í¬ ì²´í¬ ì˜¤ë¥˜: {e}")
                audit_logger.log_event(
                    'TRADE_APPROVAL_ERROR',
                    'system',
                    {'error': str(e)},
                    'CRITICAL'
                )
                return self._create_error_response("ë¦¬ìŠ¤í¬ ì²´í¬ ì‹œìŠ¤í…œ ì˜¤ë¥˜")
    
    def calculate_position(self, signal: TradingSignal, analysis: AnalysisResult) -> PositionInfo:
        """í¬ì§€ì…˜ ê³„ì‚° (í—¤ì§€í€ë“œê¸‰)"""
        try:
            # Kelly ê¸°ë°˜ í¬ì§€ì…˜ í¬ê¸°
            kelly_fraction = analysis.recommended_position_size / signal.account_balance if signal.account_balance > 0 else 0.01
            base_position = analysis.recommended_position_size
            
            # ë ˆë²„ë¦¬ì§€ ì ìš©
            leverage = CONFIG.LEVERAGE
            leveraged_size = SafeMath.safe_multiply(base_position, leverage)
            margin_required = base_position
            
            # ì†ì ˆ/ìµì ˆ ê°€ê²© ê³„ì‚° (ê°œì„ ë¨)
            stop_loss_pct = CONFIG.STOP_LOSS
            take_profit_pct = CONFIG.TAKE_PROFIT
            
            # ì‹ ë¢°ë„ì— ë”°ë¥¸ ì†ìµë¹„ ì¡°ì •
            confidence_factor = SafeMath.clamp(analysis.final_confidence, 0.5, 1.0)
            adjusted_take_profit = take_profit_pct * (1 + confidence_factor * 0.5)  # ì‹ ë¢°ë„ ë†’ìœ¼ë©´ ë” í° ìˆ˜ìµ ëª©í‘œ
            
            if signal.action in ['buy', 'long']:
                stop_loss_price = SafeMath.safe_multiply(signal.price, (1 - stop_loss_pct))
                take_profit_price = SafeMath.safe_multiply(signal.price, (1 + adjusted_take_profit))
            else:
                stop_loss_price = SafeMath.safe_multiply(signal.price, (1 + stop_loss_pct))
                take_profit_price = SafeMath.safe_multiply(signal.price, (1 - adjusted_take_profit))
            
            # ì²­ì‚°ê°€ ê³„ì‚° (ê°œì„ ë¨)
            liquidation_buffer = 0.1  # 10% ë²„í¼
            if signal.action in ['buy', 'long']:
                liquidation_price = SafeMath.safe_multiply(
                    signal.price,
                    (1 - SafeMath.safe_divide(1, leverage) + liquidation_buffer)
                )
            else:
                liquidation_price = SafeMath.safe_multiply(
                    signal.price,
                    (1 + SafeMath.safe_divide(1, leverage) - liquidation_buffer)
                )
            
            # ë¦¬ìŠ¤í¬ ì ìˆ˜ ê³„ì‚° (0-10)
            risk_score = self._calculate_risk_score(
                kelly_fraction, leveraged_size, analysis.final_confidence, analysis.quality_score
            )
            
            return PositionInfo(
                kelly_fraction=kelly_fraction,
                position_size=base_position,
                margin_required=margin_required,
                leveraged_size=leveraged_size,
                leverage=leverage,
                stop_loss_price=stop_loss_price,
                take_profit_price=take_profit_price,
                liquidation_price=liquidation_price,
                margin_mode="ISOLATED",
                risk_score=risk_score
            )
            
        except Exception as e:
            secure_logger.error(f"âš–ï¸ RISK í¬ì§€ì…˜ ê³„ì‚° ì˜¤ë¥˜: {e}")
            # ì•ˆì „í•œ ê¸°ë³¸ê°’ ë°˜í™˜
            return PositionInfo(
                kelly_fraction=0.01,
                position_size=100.0,
                margin_required=100.0,
                leveraged_size=2000.0,
                leverage=CONFIG.LEVERAGE,
                stop_loss_price=signal.price * 0.98,
                take_profit_price=signal.price * 1.02,
                liquidation_price=signal.price * 0.95,
                margin_mode="ISOLATED",
                risk_score=5.0
            )
    
    def _calculate_advanced_kelly_size(self, balance: float, confidence: float) -> float:
        """ê³ ê¸‰ Kelly Criterion í¬ì§€ì…˜ ì‚¬ì´ì§•"""
        try:
            # ê¸°ë³¸ ë¦¬ìŠ¤í¬ (ê³„ì¢Œì˜ ì¼ì¼ ì†ì‹¤ í•œë„)
            base_risk_amount = balance * CONFIG.MAX_DAILY_LOSS
            
            # ì‹ ë¢°ë„ ê²€ì¦ ë° ì •ê·œí™”
            confidence = SafeMath.clamp(confidence, 0.5, 1.0)
            
            # ê³¼ê±° ê±°ë˜ ë°ì´í„° ê¸°ë°˜ ìŠ¹ë¥  ë° ìˆ˜ìµë¥  ê³„ì‚°
            win_rate, avg_win, avg_loss = self._calculate_historical_metrics()
            
            # Kelly Criterion ê³„ì‚°
            if avg_loss > 0 and win_rate > 0:
                kelly_fraction = SafeMath.safe_divide(
                    (win_rate * avg_win - (1 - win_rate) * avg_loss), 
                    avg_win, 
                    0.01
                )
            else:
                # ê¸°ë³¸ê°’ ì‚¬ìš© (ì‹ ë¢°ë„ ê¸°ë°˜ ì¶”ì •)
                estimated_win_rate = 0.6 + (confidence - 0.75) * 0.4
                estimated_win_rate = SafeMath.clamp(estimated_win_rate, 0.5, 0.95)
                kelly_fraction = SafeMath.safe_divide(
                    (estimated_win_rate * 1.5 - (1 - estimated_win_rate) * 1.0), 
                    1.5, 
                    0.01
                )
            
            # Kelly fraction ì œí•œ (1%-25%)
            kelly_fraction = SafeMath.clamp(kelly_fraction, 0.01, 0.25)
            
            # ì‹ ë¢°ë„ ì¡°ì •
            confidence_factor = 0.8 + (confidence - 0.75) * 1.6
            confidence_factor = SafeMath.clamp(confidence_factor, 0.5, 1.2)
            
            # ë³€ë™ì„± ì¡°ì •
            volatility_factor = self.risk_metrics['volatility_multiplier']
            volatility_factor = SafeMath.clamp(volatility_factor, 0.5, 1.5)
            
            # ìµœì¢… í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
            kelly_size = balance * kelly_fraction
            adjusted_size = kelly_size * confidence_factor * volatility_factor
            
            # ìµœëŒ€ í•œë„ ì ìš©
            max_position = balance * CONFIG.MAX_POSITION_SIZE
            final_size = min(adjusted_size, max_position)
            
            # ìµœì†Œ/ìµœëŒ€ ì œí•œ
            final_size = SafeMath.clamp(final_size, balance * 0.001, balance * 0.1)
            
            return final_size
            
        except Exception as e:
            secure_logger.error(f"Kelly í¬ì§€ì…˜ ì‚¬ì´ì§• ì˜¤ë¥˜: {e}")
            return balance * 0.01  # 1% ì•ˆì „í•œ ê¸°ë³¸ê°’
    
    def _calculate_historical_metrics(self) -> Tuple[float, float, float]:
        """ê³¼ê±° ê±°ë˜ ë°ì´í„° ê¸°ë°˜ ë©”íŠ¸ë¦­ ê³„ì‚°"""
        if len(self.trade_history) < 10:
            return 0.6, 1.5, 1.0  # ê¸°ë³¸ê°’
        
        recent_trades = self.trade_history[-50:]  # ìµœê·¼ 50ê°œ ê±°ë˜
        
        wins = [trade for trade in recent_trades if trade['pnl'] > 0]
        losses = [trade for trade in recent_trades if trade['pnl'] < 0]
        
        win_rate = len(wins) / len(recent_trades) if recent_trades else 0.6
        avg_win = sum(trade['pnl'] for trade in wins) / len(wins) if wins else 1.5
        avg_loss = abs(sum(trade['pnl'] for trade in losses) / len(losses)) if losses else 1.0
        
        return win_rate, avg_win, avg_loss
    
    def _calculate_risk_score(self, kelly_fraction: float, leveraged_size: float, 
                             confidence: float, quality: float) -> float:
        """ë¦¬ìŠ¤í¬ ì ìˆ˜ ê³„ì‚° (0-10)"""
        try:
            # ê° ìš”ì†Œë³„ ë¦¬ìŠ¤í¬ ì ìˆ˜
            kelly_risk = SafeMath.clamp(kelly_fraction * 20, 0.0, 3.0)
            leverage_risk = SafeMath.clamp(leveraged_size / 50000, 0.0, 3.0)
            confidence_risk = SafeMath.clamp(2 * (1 - confidence), 0.0, 2.0)
            quality_risk = SafeMath.clamp(2 * (1 - quality), 0.0, 2.0)
            
            total_risk = kelly_risk + leverage_risk + confidence_risk + quality_risk
            return SafeMath.clamp(total_risk, 0.0, 10.0)
            
        except Exception as e:
            secure_logger.error(f"ë¦¬ìŠ¤í¬ ì ìˆ˜ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 5.0
    
    def update_position_status(self, position_update: Dict):
        """í¬ì§€ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸ (ê³ ê¸‰ ì¶”ì )"""
        with self.lock:
            try:
                action = position_update.get('action')
                
                if action == 'open':
                    self.active_positions += 1
                    self.total_exposure += position_update.get('size_pct', 0)
                    self.risk_metrics['daily_trades'] += 1
                    
                elif action == 'close':
                    self.active_positions = max(0, self.active_positions - 1)
                    self.total_exposure -= position_update.get('size_pct', 0)
                    self.total_exposure = max(0, self.total_exposure)
                    
                    # P&L ì—…ë°ì´íŠ¸ ë° ê±°ë˜ ê¸°ë¡
                    pnl_pct = position_update.get('pnl_pct', 0)
                    self.daily_pnl += pnl_pct
                    
                    # ê±°ë˜ ê¸°ë¡ ì €ì¥
                    trade_record = {
                        'timestamp': datetime.now().isoformat(),
                        'symbol': position_update.get('symbol', 'UNKNOWN'),
                        'pnl': pnl_pct,
                        'size_pct': position_update.get('size_pct', 0),
                        'duration': position_update.get('duration_minutes', 0)
                    }
                    self.trade_history.append(trade_record)
                    
                    # ê±°ë˜ ê¸°ë¡ í¬ê¸° ì œí•œ
                    if len(self.trade_history) > 500:
                        self.trade_history = self.trade_history[-400:]
                    
                    # ì—°ìŠ¹/ì—°íŒ¨ ì¶”ì 
                    if pnl_pct > 0:
                        self.risk_metrics['win_streak'] += 1
                        self.risk_metrics['loss_streak'] = 0
                        self.risk_metrics['largest_win'] = max(
                            self.risk_metrics['largest_win'], pnl_pct
                        )
                    else:
                        self.risk_metrics['loss_streak'] += 1
                        self.risk_metrics['win_streak'] = 0
                        self.risk_metrics['largest_loss'] = min(
                            self.risk_metrics['largest_loss'], pnl_pct
                        )
                    
                    # ìŠ¹ë¥  ì—…ë°ì´íŠ¸
                    recent_trades = self.trade_history[-20:] if len(self.trade_history) >= 20 else self.trade_history
                    if recent_trades:
                        wins = sum(1 for trade in recent_trades if trade['pnl'] > 0)
                        self.risk_metrics['success_rate'] = wins / len(recent_trades)
                    
                    # ë³€ë™ì„± ìŠ¹ìˆ˜ ì—…ë°ì´íŠ¸
                    self._update_volatility_multiplier()
                
                # ê°ì‚¬ ë¡œê·¸
                audit_logger.log_event(
                    'POSITION_UPDATE',
                    'system',
                    {
                        'action': action,
                        'active_positions': self.active_positions,
                        'total_exposure': self.total_exposure
                    }
                )
                    
            except Exception as e:
                secure_logger.error(f"í¬ì§€ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
                audit_logger.log_event(
                    'POSITION_UPDATE_ERROR',
                    'system',
                    {'error': str(e)},
                    'HIGH'
                )
    
    def _update_volatility_multiplier(self):
        """ë³€ë™ì„± ê¸°ë°˜ ë¦¬ìŠ¤í¬ ìŠ¹ìˆ˜ ì—…ë°ì´íŠ¸"""
        try:
            if len(self.trade_history) < 10:
                return
            
            recent_trades = self.trade_history[-20:]
            pnl_values = [trade['pnl'] for trade in recent_trades]
            
            if NUMPY_AVAILABLE:
                volatility = np.std(pnl_values)
            else:
                # numpy ì—†ì´ í‘œì¤€í¸ì°¨ ê³„ì‚°
                mean_pnl = sum(pnl_values) / len(pnl_values)
                variance = sum((x - mean_pnl) ** 2 for x in pnl_values) / len(pnl_values)
                volatility = variance ** 0.5
            
            # ë³€ë™ì„±ì— ë”°ë¥¸ ìŠ¹ìˆ˜ ì¡°ì •
            if volatility > 0.05:  # ë†’ì€ ë³€ë™ì„±
                self.risk_metrics['volatility_multiplier'] = 0.7
            elif volatility > 0.03:  # ì¤‘ê°„ ë³€ë™ì„±
                self.risk_metrics['volatility_multiplier'] = 0.85
            else:  # ë‚®ì€ ë³€ë™ì„±
                self.risk_metrics['volatility_multiplier'] = 1.0
                
        except Exception as e:
            secure_logger.error(f"ë³€ë™ì„± ìŠ¹ìˆ˜ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
    
    def _validate_inputs(self, signal_data: Dict, analysis: Dict) -> bool:
        """ì…ë ¥ ë°ì´í„° ìœ íš¨ì„± ê²€ì¦"""
        try:
            if not isinstance(signal_data, dict) or not isinstance(analysis, dict):
                return False
            
            required_signal_fields = ['symbol', 'price', 'account_balance']
            for field in required_signal_fields:
                if field not in signal_data:
                    return False
            
            required_analysis_fields = ['confidence', 'final_confidence']
            for field in required_analysis_fields:
                if field not in analysis:
                    return False
            
            return True
        except Exception:
            return False
    
    def _check_daily_reset(self):
        """ì¼ì¼ ë¦¬ì…‹ ì²´í¬"""
        today = datetime.now().date()
        if today != self.last_reset:
            self.daily_pnl = 0.0
            self.risk_metrics['daily_trades'] = 0
            self.last_reset = today
            secure_logger.info("âš–ï¸ RISK: ì¼ì¼ í†µê³„ ë¦¬ì…‹")
    
    def _create_error_response(self, error_msg: str) -> Dict:
        """ì—ëŸ¬ ì‘ë‹µ ìƒì„±"""
        return {
            'approved': False,
            'position_size': 0,
            'position_size_pct': 0,
            'risk_level': 'CRITICAL',
            'checks': [error_msg],
            'error': error_msg
        }
    
    def get_risk_status(self) -> Dict:
        """ë¦¬ìŠ¤í¬ ìƒíƒœ ì¡°íšŒ"""
        with self.lock:
            return {
                'current_status': {
                    'daily_pnl': round(self.daily_pnl, 4),
                    'active_positions': self.active_positions,
                    'total_exposure': round(self.total_exposure, 4),
                    'risk_utilization': round(abs(self.daily_pnl) / CONFIG.MAX_DAILY_LOSS, 4) if CONFIG.MAX_DAILY_LOSS > 0 else 0
                },
                'limits': {
                    'max_daily_loss': CONFIG.MAX_DAILY_LOSS,
                    'max_positions': CONFIG.MAX_POSITIONS,
                    'max_position_size': CONFIG.MAX_POSITION_SIZE,
                    'min_confidence': CONFIG.MIN_CONFIDENCE
                },
                'metrics': self.risk_metrics,
                'trade_history_count': len(self.trade_history),
                'timestamp': datetime.now().isoformat()
            }

# =============================================================================
# âš¡ EXECUTE - Trade Execution Engine (ì‹¤í–‰ ì—”ì§„)
# =============================================================================

class ExecutionEngine:
    """í—¤ì§€í€ë“œê¸‰ ê±°ë˜ ì‹¤í–‰ ì—”ì§„"""
    
    def __init__(self, config: SafeConfig):
        self.config = config
        self.execution_threshold = SafeMath.safe_float(config.PHOENIX_95_CONFIG.get("threshold", 0.75))
        
        # ì‹¤í–‰ ì¡°ê±´ ë§¤íŠ¸ë¦­ìŠ¤ (ê°œì„ ë¨)
        self.execution_matrix = {
            ("IMMEDIATE", "LOW"): True,
            ("IMMEDIATE", "MEDIUM"): True,
            ("IMMEDIATE", "HIGH"): False,
            ("IMMEDIATE", "CRITICAL"): False,
            ("CAREFUL", "LOW"): True,
            ("CAREFUL", "MEDIUM"): True,
            ("CAREFUL", "HIGH"): False,
            ("CAREFUL", "CRITICAL"): False,
            ("MONITOR", "LOW"): True,
            ("MONITOR", "MEDIUM"): False,
            ("MONITOR", "HIGH"): False,
            ("MONITOR", "CRITICAL"): False,
            ("HOLD", "LOW"): False,
            ("HOLD", "MEDIUM"): False,
            ("HOLD", "HIGH"): False,
            ("HOLD", "CRITICAL"): False,
        }
        
        # ì‹¤í–‰ í†µê³„
        self.execution_stats = {
            'total_trades': 0,
            'successful_trades': 0,
            'failed_trades': 0,
            'avg_execution_time': 0.0,
            'total_volume': 0.0,
            'slippage_stats': {
                'avg_slippage': 0.0,
                'max_slippage': 0.0
            }
        }
        
        self.lock = threading.RLock()
        
        secure_logger.info("âš¡ EXECUTE: Trade Execution Engine ì´ˆê¸°í™” ì™„ë£Œ")
    
    def execute_trade(self, signal: TradingSignal, analysis: AnalysisResult, position_info: PositionInfo) -> TradeResult:
        """ê±°ë˜ ì‹¤í–‰ ê²°ì • (í—¤ì§€í€ë“œê¸‰)"""
        try:
            start_time = time.time()
            trade_id = f"T95_{int(start_time * 1000)}"
            
            # ì‹¤í–‰ ì¡°ê±´ ì²´í¬
            should_execute, reason = self._check_execution_conditions(analysis, position_info)
            
            # ì‹¤í–‰ í†µê³„ ì—…ë°ì´íŠ¸
            processing_time = (time.time() - start_time) * 1000
            
            with self.lock:
                self.execution_stats['total_trades'] += 1
                
                if should_execute:
                    execution_status = "EXECUTED"
                    self.execution_stats['successful_trades'] += 1
                    self.execution_stats['total_volume'] += position_info.leveraged_size
                    
                    # í‰ê·  ì‹¤í–‰ ì‹œê°„ ì—…ë°ì´íŠ¸
                    current_avg = self.execution_stats['avg_execution_time']
                    total_successful = self.execution_stats['successful_trades']
                    new_avg = ((current_avg * (total_successful - 1)) + processing_time) / total_successful
                    self.execution_stats['avg_execution_time'] = new_avg
                    
                    secure_logger.info(f"âš¡ EXECUTE: {signal.symbol} ê±°ë˜ ì‹¤í–‰ - Phoenix={analysis.phoenix_95_score:.2%}")
                    
                    # ê°ì‚¬ ë¡œê·¸
                    audit_logger.log_event(
                        'TRADE_EXECUTED',
                        'system',
                        {
                            'trade_id': trade_id,
                            'symbol': signal.symbol,
                            'action': signal.action,
                            'phoenix_score': analysis.phoenix_95_score,
                            'position_size': position_info.leveraged_size
                        }
                    )
                    
                else:
                    execution_status = "HOLD"
                    self.execution_stats['failed_trades'] += 1
                    secure_logger.info(f"âš¡ EXECUTE: {signal.symbol} ë³´ë¥˜ - {reason}")
                    
                    # ê°ì‚¬ ë¡œê·¸
                    audit_logger.log_event(
                        'TRADE_HOLD',
                        'system',
                        {
                            'trade_id': trade_id,
                            'symbol': signal.symbol,
                            'reason': reason
                        }
                    )
            
            hedge_fund_grade = processing_time <= CONFIG.PERFORMANCE_TARGETS["max_response_time_ms"]
            
            return TradeResult(
                trade_id=trade_id,
                signal_id=analysis.signal_id,
                symbol=signal.symbol,
                action=signal.action,
                phoenix_95_score=analysis.phoenix_95_score,
                position_info=position_info,
                execution_status=execution_status,
                execution_reason=reason,
                timestamp=time.time(),
                processing_time_ms=round(processing_time, 2),
                hedge_fund_grade=hedge_fund_grade
            )
            
        except Exception as e:
            secure_logger.error(f"âš¡ EXECUTE ê±°ë˜ ì‹¤í–‰ ì˜¤ë¥˜: {e}")
            
            # ê°ì‚¬ ë¡œê·¸
            audit_logger.log_event(
                'TRADE_EXECUTION_ERROR',
                'system',
                {'error': str(e)},
                'CRITICAL'
            )
            
            # ì•ˆì „í•œ ê¸°ë³¸ê°’ ë°˜í™˜
            return TradeResult(
                trade_id=f"ERROR_{int(time.time() * 1000)}",
                signal_id=analysis.signal_id,
                symbol=signal.symbol,
                action=signal.action,
                phoenix_95_score=0.0,
                position_info=position_info,
                execution_status="ERROR",
                execution_reason=f"ì‹¤í–‰ ì˜¤ë¥˜: {e}",
                timestamp=time.time(),
                processing_time_ms=0.0,
                hedge_fund_grade=False
            )
    
    def _check_execution_conditions(self, analysis: AnalysisResult, position_info: PositionInfo) -> Tuple[bool, str]:
        """ì‹¤í–‰ ì¡°ê±´ ì²´í¬ (í—¤ì§€í€ë“œê¸‰)"""
        try:
            # 1. Phoenix 95 ì„ê³„ê°’ ì²´í¬
            if analysis.final_confidence < self.execution_threshold:
                return False, f"Phoenix 95 ì„ê³„ê°’ ë¯¸ë‹¬ ({analysis.final_confidence:.1%} < {self.execution_threshold:.0%})"
            
            # 2. íƒ€ì´ë°/ë¦¬ìŠ¤í¬ ë§¤íŠ¸ë¦­ìŠ¤ ì²´í¬
            key = (analysis.execution_timing, analysis.risk_level)
            if not self.execution_matrix.get(key, False):
                return False, f"íƒ€ì´ë°/ë¦¬ìŠ¤í¬ ë¶€ì ì ˆ ({analysis.execution_timing}/{analysis.risk_level})"
            
            # 3. ë¦¬ìŠ¤í¬ ì ìˆ˜ ì²´í¬
            if position_info.risk_score >= 8.0:
                return False, f"ë¦¬ìŠ¤í¬ ì ìˆ˜ ê³¼ë‹¤ ({position_info.risk_score}/10)"
            
            # 4. í’ˆì§ˆ ì ìˆ˜ ì²´í¬
            if analysis.quality_score < 0.7:
                return False, f"í’ˆì§ˆ ì ìˆ˜ ë¶€ì¡± ({analysis.quality_score:.1%})"
            
            # 5. í¬ì§€ì…˜ í¬ê¸° ì²´í¬
            if position_info.position_size <= 0:
                return False, "í¬ì§€ì…˜ í¬ê¸° ë¶€ì ì ˆ"
            
            # 6. ì²­ì‚°ê°€ ì•ˆì „ì„± ì²´í¬
            liquidation_distance = abs(position_info.liquidation_price - position_info.stop_loss_price) / position_info.stop_loss_price
            if liquidation_distance < 0.1:  # ì²­ì‚°ê°€ì™€ ì†ì ˆê°€ê°€ ë„ˆë¬´ ê°€ê¹Œì›€
                return False, f"ì²­ì‚°ê°€ ìœ„í—˜ (ê±°ë¦¬: {liquidation_distance:.1%})"
            
            return True, "ëª¨ë“  ì‹¤í–‰ ì¡°ê±´ ì¶©ì¡±"
            
        except Exception as e:
            secure_logger.error(f"ì‹¤í–‰ ì¡°ê±´ ì²´í¬ ì˜¤ë¥˜: {e}")
            return False, f"ì¡°ê±´ ì²´í¬ ì‹¤íŒ¨: {e}"
    
    def get_stats(self) -> Dict:
        """ì‹¤í–‰ í†µê³„ ì¡°íšŒ"""
        with self.lock:
            total = self.execution_stats['total_trades']
            success_rate = (
                self.execution_stats['successful_trades'] / total * 100 
                if total > 0 else 0
            )
            
            return {
                'execution_stats': {
                    **self.execution_stats,
                    'success_rate_pct': round(success_rate, 2)
                },
                'configuration': {
                    'execution_threshold': self.execution_threshold,
                    'trade_mode': self.config.TRADE_MODE,
                    'leverage': self.config.LEVERAGE
                },
                'execution_matrix_size': len(self.execution_matrix)
            }

# =============================================================================
# ğŸ“± NOTIFY - Alert & Monitor Hub (ì•Œë¦¼ í—ˆë¸Œ)
# =============================================================================

class NotificationHub:
    """í—¤ì§€í€ë“œê¸‰ ì•Œë¦¼ ë° ëª¨ë‹ˆí„°ë§ í—ˆë¸Œ"""
    
    def __init__(self, config: SafeConfig):
        self.config = config
        self.telegram_config = config.TELEGRAM_CONFIG
        
        self.stats = {
            "total_sent": 0,
            "success_count": 0,
            "error_count": 0,
            "telegram_sent": 0,
            "console_sent": 0
        }
        
        self.lock = threading.RLock()
        
        secure_logger.info("ğŸ“± NOTIFY: Alert & Monitor Hub ì´ˆê¸°í™” ì™„ë£Œ")
    
    async def send_alert(self, trade_result: TradeResult):
        """ê±°ë˜ ì•Œë¦¼ ì „ì†¡ (ë©€í‹° ì±„ë„)"""
        try:
            message = self._format_message(trade_result)
            
            with self.lock:
                self.stats["total_sent"] += 1
            
            # í…”ë ˆê·¸ë¨ ì „ì†¡ ì‹œë„
            telegram_success = False
            if self.telegram_config.get("enabled", False) and REQUESTS_AVAILABLE:
                telegram_success = await self._send_telegram_message(message)
                if telegram_success:
                    with self.lock:
                        self.stats["telegram_sent"] += 1
            
            # ì½˜ì†” ì¶œë ¥ (ë°±ì—…)
            if not telegram_success or CONFIG.EXECUTION_MODE == "SIMPLE":
                self._send_console_message(message)
                with self.lock:
                    self.stats["console_sent"] += 1
            
            with self.lock:
                self.stats["success_count"] += 1
            
            secure_logger.info(f"ğŸ“± NOTIFY: {trade_result.symbol} ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ")
            
        except Exception as e:
            with self.lock:
                self.stats["error_count"] += 1
            secure_logger.error(f"ğŸ“± NOTIFY ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    async def send_system_alert(self, alert_type: str, message: str, severity: str = 'INFO'):
        """ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡"""
        try:
            emoji_map = {
                'INFO': 'â„¹ï¸',
                'WARNING': 'âš ï¸',
                'ERROR': 'âŒ',
                'CRITICAL': 'ğŸš¨'
            }
            
            emoji = emoji_map.get(severity, 'â„¹ï¸')
            
            formatted_message = f"""
{emoji} <b>Phoenix 95 ì‹œìŠ¤í…œ ì•Œë¦¼</b>

ğŸ“‹ <b>ìœ í˜•:</b> {alert_type}
ğŸ” <b>ë‚´ìš©:</b> {message}
ğŸ“Š <b>ì‹¬ê°ë„:</b> {severity}

â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
            
            # ì‹¬ê°ë„ì— ë”°ë¥¸ ì „ì†¡ ë°©ì‹ ê²°ì •
            if severity in ['CRITICAL', 'ERROR'] or CONFIG.EXECUTION_MODE == "ADVANCED":
                if self.telegram_config.get("enabled", False) and REQUESTS_AVAILABLE:
                    await self._send_telegram_message(formatted_message)
                else:
                    self._send_console_message(formatted_message)
            else:
                self._send_console_message(formatted_message)
            
            with self.lock:
                self.stats["total_sent"] += 1
                self.stats["success_count"] += 1
                
        except Exception as e:
            with self.lock:
                self.stats["error_count"] += 1
            secure_logger.error(f"ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    def _format_message(self, trade_result: TradeResult) -> str:
        """ì•Œë¦¼ ë©”ì‹œì§€ í¬ë§· (ê°œì„ ë¨)"""
        try:
            # ìƒíƒœë³„ ì´ëª¨ì§€
            status_emoji_map = {
                "EXECUTED": "ğŸš€",
                "HOLD": "â³",
                "ERROR": "âŒ"
            }
            status_emoji = status_emoji_map.get(trade_result.execution_status, "â“")
            
            # ë ˆë²„ë¦¬ì§€ ì •ë³´
            leverage_info = f"{trade_result.position_info.leverage}x {trade_result.position_info.margin_mode}"
            
            # ìƒíƒœë³„ ë©”ì‹œì§€ ë‚´ìš©
            if trade_result.execution_status == "EXECUTED":
                potential_profit = SafeMath.safe_multiply(trade_result.position_info.leveraged_size, CONFIG.TAKE_PROFIT)
                roi_text = f"ğŸ’° **ìˆ˜ìµ ì˜ˆìƒ:** ${potential_profit:,.0f} ({CONFIG.TAKE_PROFIT:.1%} ë‹¬ì„±ì‹œ)"
                
                # ê³ ê¸‰ ì •ë³´ (ADVANCED ëª¨ë“œì—ì„œë§Œ)
                if CONFIG.EXECUTION_MODE == "ADVANCED":
                    advanced_info = f"""
ğŸ” **ê³ ê¸‰ ì •ë³´:**
â€¢ Kelly Fraction: {trade_result.position_info.kelly_fraction:.3f}
â€¢ ë¦¬ìŠ¤í¬ ìŠ¤ì½”ì–´: {trade_result.position_info.risk_score:.1f}/10
â€¢ ì²­ì‚°ê°€: ${trade_result.position_info.liquidation_price:,.2f}
â€¢ ì²˜ë¦¬ì‹œê°„: {trade_result.processing_time_ms:.1f}ms
â€¢ í—¤ì§€í€ë“œê¸‰: {'âœ…' if trade_result.hedge_fund_grade else 'âŒ'}"""
                else:
                    advanced_info = ""
                
            else:
                roi_text = f"ğŸ’­ **ìƒíƒœ:** {trade_result.execution_reason}"
                advanced_info = ""
            
            # ê¸°ë³¸ ë©”ì‹œì§€
            if CONFIG.EXECUTION_MODE == "SIMPLE":
                message = f"""
{status_emoji} **Phoenix 95 ì‹œìŠ¤í…œ**

ğŸ“Š **{trade_result.symbol}** {trade_result.action.upper()}
ğŸ”¥ **Phoenix Score:** {trade_result.phoenix_95_score:.1%}
ğŸ’ **í¬ì§€ì…˜:** ${trade_result.position_info.leveraged_size:,.0f}
âš–ï¸ **ë ˆë²„ë¦¬ì§€:** {leverage_info}
ğŸ›‘ **ì†ì ˆ:** ${trade_result.position_info.stop_loss_price:,.2f}
ğŸ¯ **ìµì ˆ:** ${trade_result.position_info.take_profit_price:,.2f}
âš¡ **ìƒíƒœ:** {trade_result.execution_status}

{roi_text}

ğŸ†” **Trade:** {trade_result.trade_id}
"""
            else:  # ADVANCED ëª¨ë“œ
                message = f"""
{status_emoji} **Phoenix 95 í—¤ì§€í€ë“œ ì‹œìŠ¤í…œ**

ğŸ“Š **ê¸°ë³¸ ì •ë³´**
â€¢ ì‹¬ë³¼: **{trade_result.symbol}**
â€¢ ë°©í–¥: **{trade_result.action.upper()}**
â€¢ Phoenix Score: **{trade_result.phoenix_95_score:.1%}**

ğŸ’° **í¬ì§€ì…˜ ì •ë³´**
â€¢ í¬ì§€ì…˜: **${trade_result.position_info.leveraged_size:,.0f}**
â€¢ ë ˆë²„ë¦¬ì§€: **{leverage_info}**
â€¢ ë§ˆì§„: **${trade_result.position_info.margin_required:,.0f}**

ğŸ¯ **ë¦¬ìŠ¤í¬ ê´€ë¦¬**
â€¢ ì†ì ˆê°€: **${trade_result.position_info.stop_loss_price:,.2f}**
â€¢ ìµì ˆê°€: **${trade_result.position_info.take_profit_price:,.2f}**
â€¢ ìƒíƒœ: **{trade_result.execution_status}**

{roi_text}
{advanced_info}

ğŸ†” **Trade ID:** {trade_result.trade_id}
â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
            
            return message
            
        except Exception as e:
            secure_logger.error(f"ë©”ì‹œì§€ í¬ë§· ì˜¤ë¥˜: {e}")
            return f"Phoenix 95 ì•Œë¦¼: {trade_result.symbol} {trade_result.execution_status} (í¬ë§· ì˜¤ë¥˜)"
    
    async def _send_telegram_message(self, message: str) -> bool:
        """í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡"""
        try:
            if not REQUESTS_AVAILABLE or not self.telegram_config.get("token"):
                return False
            
            url = f"https://api.telegram.org/bot{self.telegram_config['token']}/sendMessage"
            payload = {
                "chat_id": self.telegram_config["chat_id"],
                "text": message,
                "parse_mode": self.telegram_config.get("parse_mode", "Markdown"),
                "disable_web_page_preview": True
            }
            
            if AIOHTTP_AVAILABLE:
                # ë¹„ë™ê¸° ìš”ì²­
                result = await network_client.safe_post(url, json_data=payload)
                success = 'error' not in result
            else:
                # ë™ê¸° ìš”ì²­ (fallback)
                response = requests.post(url, json=payload, timeout=self.telegram_config.get("timeout", 30))
                success = response.status_code == 200
            
            if success:
                secure_logger.info("ğŸ“± í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì„±ê³µ")
                return True
            else:
                secure_logger.warning("ğŸ“± í…”ë ˆê·¸ë¨ ì „ì†¡ ì‹¤íŒ¨")
                return False
                
        except Exception as e:
            secure_logger.error(f"ğŸ“± í…”ë ˆê·¸ë¨ ì˜¤ë¥˜: {e}")
            return False
    
    def _send_console_message(self, message: str):
        """ì½˜ì†” ë©”ì‹œì§€ ì¶œë ¥"""
        try:
            # HTML íƒœê·¸ ì œê±° (ì½˜ì†”ìš©)
            clean_message = re.sub(r'<[^>]+>', '', message)
            
            print(f"\nğŸ“± Phoenix 95 ì•Œë¦¼:")
            print("=" * 60)
            print(clean_message)
            print("=" * 60)
            
        except Exception as e:
            secure_logger.error(f"ì½˜ì†” ë©”ì‹œì§€ ì¶œë ¥ ì˜¤ë¥˜: {e}")
    
    def get_stats(self) -> Dict:
        """ì•Œë¦¼ í†µê³„ ì¡°íšŒ"""
        with self.lock:
            return {
                **self.stats,
                'telegram_enabled': self.telegram_config.get("enabled", False),
                'success_rate': (
                    self.stats["success_count"] / self.stats["total_sent"] * 100
                    if self.stats["total_sent"] > 0 else 0
                )
            }

# =============================================================================
# ğŸ¦ Phoenix 95 System (ë©”ì¸ ì‹œìŠ¤í…œ)
# =============================================================================

class Phoenix95System:
    """Phoenix 95 ì™„ì „ í†µí•© ë©”ì¸ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.config = CONFIG
        
        # 4ê°œ í•µì‹¬ ì»´í¬ë„ŒíŠ¸ ì´ˆê¸°í™”
        self.brain = SignalBrain(self.config)
        self.risk_manager = RiskManager(self.config)
        self.execution_engine = ExecutionEngine(self.config)
        self.notification_hub = NotificationHub(self.config)
        
        # ì„±ëŠ¥ í†µê³„
        self.stats = {
            "total_signals": 0,
            "executed_trades": 0,
            "held_trades": 0,
            "total_errors": 0,
            "avg_processing_time_ms": 0.0,
            "success_rate": 0.0,
            "system_uptime": time.time(),
            "cache_hit_rate": 0.0
        }
        
        self._lock = threading.RLock()
        
        secure_logger.info(f"ğŸ¦ Phoenix 95 ì™„ì „ í†µí•© ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ - ëª¨ë“œ: {self.config.EXECUTION_MODE}")
    
    async def process_signal(self, signal_request) -> Dict[str, Any]:
        """ì‹ í˜¸ ì²˜ë¦¬ ë©”ì¸ íŒŒì´í”„ë¼ì¸"""
        start_time = time.time()
        
        with self._lock:
            self.stats["total_signals"] += 1
        
        try:
            # 1. ì…ë ¥ ì‹ í˜¸ ë³€í™˜ ë° ê²€ì¦
            signal = self._convert_signal_request(signal_request)
            
            # 2. ì‹¬ë³¼ ê²€ì¦
            if signal.symbol not in self.config.ALLOWED_SYMBOLS:
                return self._create_error_response(f"ì§€ì›í•˜ì§€ ì•ŠëŠ” ì‹¬ë³¼: {signal.symbol}")
            
            # 3. ğŸ§  BRAIN: AI ë¶„ì„
            analysis = self.brain.analyze_signal(signal)
            
            # 4. âš–ï¸ RISK: ë¦¬ìŠ¤í¬ ì²´í¬ ë° í¬ì§€ì…˜ ê³„ì‚°
            risk_check = self.risk_manager.check_trade_approval(
                signal.__dict__, 
                analysis.__dict__
            )
            
            if not risk_check.get('approved', False):
                # ê±°ë˜ ê±°ì ˆ
                with self._lock:
                    self.stats["held_trades"] += 1
                
                # ì•Œë¦¼ ì „ì†¡ (ê±°ì ˆ ì‚¬ìœ )
                dummy_position = PositionInfo(
                    kelly_fraction=0, position_size=0, margin_required=0,
                    leveraged_size=0, leverage=self.config.LEVERAGE,
                    stop_loss_price=signal.price, take_profit_price=signal.price,
                    liquidation_price=signal.price, margin_mode="ISOLATED", risk_score=10.0
                )
                
                trade_result = TradeResult(
                    trade_id=f"REJECTED_{int(time.time() * 1000)}",
                    signal_id=analysis.signal_id,
                    symbol=signal.symbol,
                    action=signal.action,
                    phoenix_95_score=analysis.phoenix_95_score,
                    position_info=dummy_position,
                    execution_status="REJECTED",
                    execution_reason="; ".join(risk_check.get('checks', ['Unknown reason'])),
                    timestamp=time.time(),
                    processing_time_ms=(time.time() - start_time) * 1000,
                    hedge_fund_grade=False
                )
                
                await self.notification_hub.send_alert(trade_result)
                
                return self._create_risk_rejection_response(risk_check, analysis, start_time)
            
            # 5. í¬ì§€ì…˜ ì •ë³´ ê³„ì‚°
            position_info = self.risk_manager.calculate_position(signal, analysis)
            
            # 6. âš¡ EXECUTE: ì‹¤í–‰ ê²°ì •
            trade_result = self.execution_engine.execute_trade(signal, analysis, position_info)
            
            # 7. ğŸ“± NOTIFY: ì•Œë¦¼ ì „ì†¡
            await self.notification_hub.send_alert(trade_result)
            
            # 8. í†µê³„ ì—…ë°ì´íŠ¸
            self._update_stats(trade_result, start_time)
            
            # 9. ì„±ê³µ ì‘ë‹µ ìƒì„±
            return self._create_success_response(trade_result, analysis, position_info, risk_check, start_time)
            
        except Exception as e:
            with self._lock:
                self.stats["total_errors"] += 1
            
            secure_logger.error(f"âŒ ì‹ í˜¸ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
            
            # ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡
            await self.notification_hub.send_system_alert(
                "SYSTEM_ERROR",
                f"ì‹ í˜¸ ì²˜ë¦¬ ì¤‘ ì˜¤ë¥˜ ë°œìƒ: {str(e)}",
                "ERROR"
            )
            
            return self._create_error_response(f"ì²˜ë¦¬ ì˜¤ë¥˜: {str(e)}")
    
    def _convert_signal_request(self, signal_request) -> TradingSignal:
        """ì‹ í˜¸ ìš”ì²­ ë³€í™˜ (ê°œì„ ë¨)"""
        try:
            if hasattr(signal_request, 'symbol'):
                # ê°ì²´ì¸ ê²½ìš°
                return TradingSignal(
                    symbol=str(signal_request.symbol).upper().strip(),
                    action=str(signal_request.action).lower().strip(),
                    price=SafeMath.safe_float(signal_request.price),
                    confidence=SafeMath.clamp(getattr(signal_request, 'confidence', 0.8), 0.0, 1.0),
                    strategy=str(getattr(signal_request, 'strategy', 'phoenix95')),
                    timeframe=str(getattr(signal_request, 'timeframe', '1h')),
                    rsi=SafeMath.safe_float(getattr(signal_request, 'rsi')) if getattr(signal_request, 'rsi') else None,
                    macd=SafeMath.safe_float(getattr(signal_request, 'macd')) if getattr(signal_request, 'macd') else None,
                    volume=SafeMath.safe_float(getattr(signal_request, 'volume')) if getattr(signal_request, 'volume') else None,
                    account_balance=SafeMath.safe_float(getattr(signal_request, 'account_balance', 10000.0))
                )
            else:
                # Dictì¸ ê²½ìš°
                return TradingSignal(
                    symbol=str(signal_request.get('symbol', '')).upper().strip(),
                    action=str(signal_request.get('action', '')).lower().strip(),
                    price=SafeMath.safe_float(signal_request.get('price', 0.0)),
                    confidence=SafeMath.clamp(signal_request.get('confidence', 0.8), 0.0, 1.0),
                    strategy=str(signal_request.get('strategy', 'phoenix95')),
                    timeframe=str(signal_request.get('timeframe', '1h')),
                    rsi=SafeMath.safe_float(signal_request.get('rsi')) if signal_request.get('rsi') else None,
                    macd=SafeMath.safe_float(signal_request.get('macd')) if signal_request.get('macd') else None,
                    volume=SafeMath.safe_float(signal_request.get('volume')) if signal_request.get('volume') else None,
                    account_balance=SafeMath.safe_float(signal_request.get('account_balance', 10000.0))
                )
        except Exception as e:
            secure_logger.error(f"ì‹ í˜¸ ë³€í™˜ ì˜¤ë¥˜: {e}")
            raise ValueError(f"ì‹ í˜¸ ë³€í™˜ ì‹¤íŒ¨: {e}") from e
    
    def _update_stats(self, trade_result: TradeResult, start_time: float):
        """í†µê³„ ì—…ë°ì´íŠ¸ (ê°œì„ ë¨)"""
        try:
            with self._lock:
                if trade_result.execution_status == "EXECUTED":
                    self.stats["executed_trades"] += 1
                else:
                    self.stats["held_trades"] += 1
                
                processing_time = (time.time() - start_time) * 1000
                total_signals = self.stats["total_signals"]
                
                # ì´ë™ í‰ê·  ê³„ì‚°
                current_avg = self.stats["avg_processing_time_ms"]
                self.stats["avg_processing_time_ms"] = (
                    (current_avg * (total_signals - 1) + processing_time) / total_signals
                )
                
                # ì„±ê³µë¥  ê³„ì‚°
                self.stats["success_rate"] = SafeMath.safe_divide(
                    self.stats["executed_trades"],
                    total_signals
                )
                
                # ìºì‹œ íˆíŠ¸ìœ¨ ì—…ë°ì´íŠ¸
                cache_stats = self.brain.analysis_cache.get_stats()
                self.stats["cache_hit_rate"] = cache_stats.get('hit_rate', 0.0)
                
        except Exception as e:
            secure_logger.error(f"í†µê³„ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
    
    def _create_success_response(self, trade_result: TradeResult, analysis: AnalysisResult, 
                               position_info: PositionInfo, risk_check: Dict, start_time: float) -> Dict[str, Any]:
        """ì„±ê³µ ì‘ë‹µ ìƒì„± (ê°œì„ ë¨)"""
        try:
            processing_time = (time.time() - start_time) * 1000
            
            # ê¸°ë³¸ ì‘ë‹µ
            response = {
                "status": "success",
                "trade_result": {
                    "trade_id": trade_result.trade_id,
                    "symbol": trade_result.symbol,
                    "action": trade_result.action,
                    "phoenix_95_score": trade_result.phoenix_95_score,
                    "execution_status": trade_result.execution_status,
                    "execution_reason": trade_result.execution_reason,
                    "leveraged_size": position_info.leveraged_size,
                    "leverage": position_info.leverage,
                    "stop_loss": position_info.stop_loss_price,
                    "take_profit": position_info.take_profit_price,
                    "risk_score": position_info.risk_score
                },
                "performance": {
                    "processing_time_ms": round(processing_time, 2),
                    "hedge_fund_grade": processing_time <= self.config.PERFORMANCE_TARGETS["max_response_time_ms"],
                    "final_confidence": analysis.final_confidence,
                    "quality_score": analysis.quality_score
                },
                "system_info": {
                    "version": self.config.SYSTEM_VERSION,
                    "architecture": self.config.ARCHITECTURE,
                    "execution_mode": self.config.EXECUTION_MODE,
                    "components": ["BRAIN", "RISK", "EXECUTE", "NOTIFY"]
                },
                "timestamp": time.time()
            }
            
            # ê³ ê¸‰ ëª¨ë“œì—ì„œëŠ” ì¶”ê°€ ì •ë³´ í¬í•¨
            if self.config.EXECUTION_MODE == "ADVANCED":
                response["advanced_info"] = {
                    "analysis_details": {
                        "technical_indicators": analysis.technical_indicators,
                        "analysis_time_ms": analysis.analysis_time_ms,
                        "cache_used": analysis.metadata.get('from_cache', False)
                    },
                    "risk_details": {
                        "kelly_fraction": position_info.kelly_fraction,
                        "margin_required": position_info.margin_required,
                        "liquidation_price": position_info.liquidation_price,
                        "risk_metrics": risk_check.get('risk_metrics', {}),
                        "kelly_sizing": risk_check.get('kelly_sizing', {})
                    },
                    "system_metrics": {
                        "cache_hit_rate": self.stats["cache_hit_rate"],
                        "avg_processing_time": self.stats["avg_processing_time_ms"],
                        "success_rate": self.stats["success_rate"]
                    }
                }
            
            return response
            
        except Exception as e:
            secure_logger.error(f"ì„±ê³µ ì‘ë‹µ ìƒì„± ì˜¤ë¥˜: {e}")
            return {"status": "response_error", "message": str(e)}
    
    def _create_risk_rejection_response(self, risk_check: Dict, analysis: AnalysisResult, start_time: float) -> Dict[str, Any]:
        """ë¦¬ìŠ¤í¬ ê±°ì ˆ ì‘ë‹µ ìƒì„±"""
        processing_time = (time.time() - start_time) * 1000
        
        return {
            "status": "rejected",
            "reason": "Risk management rejection",
            "risk_check": risk_check,
            "analysis": {
                "phoenix_95_score": analysis.phoenix_95_score,
                "final_confidence": analysis.final_confidence,
                "quality_score": analysis.quality_score,
                "execution_timing": analysis.execution_timing,
                "risk_level": analysis.risk_level
            },
            "performance": {
                "processing_time_ms": round(processing_time, 2),
                "hedge_fund_grade": processing_time <= self.config.PERFORMANCE_TARGETS["max_response_time_ms"]
            },
            "timestamp": time.time()
        }
    
    def _create_error_response(self, error_message: str) -> Dict[str, Any]:
        """ì˜¤ë¥˜ ì‘ë‹µ ìƒì„±"""
        return {
            "status": "error",
            "message": error_message,
            "system_info": {
                "version": self.config.SYSTEM_VERSION,
                "execution_mode": self.config.EXECUTION_MODE
            },
            "timestamp": time.time()
        }
    
    def get_stats(self) -> Dict[str, Any]:
        """ì‹œìŠ¤í…œ í†µê³„ ì¡°íšŒ (ê°œì„ ë¨)"""
        try:
            with self._lock:
                uptime = time.time() - self.stats["system_uptime"]
                
                # ì»´í¬ë„ŒíŠ¸ë³„ í†µê³„ ìˆ˜ì§‘
                brain_stats = self.brain.analysis_cache.get_stats()
                risk_stats = self.risk_manager.get_risk_status()
                execution_stats = self.execution_engine.get_stats()
                notification_stats = self.notification_hub.get_stats()
                
                return {
                    "system_overview": {
                        "version": self.config.SYSTEM_VERSION,
                        "architecture": self.config.ARCHITECTURE,
                        "execution_mode": self.config.EXECUTION_MODE,
                        "uptime_hours": round(uptime / 3600, 2),
                        "components": ["ğŸ§  BRAIN", "âš–ï¸ RISK", "âš¡ EXECUTE", "ğŸ“± NOTIFY"]
                    },
                    "performance_stats": {
                        **self.stats,
                        "avg_processing_time_ms": round(self.stats["avg_processing_time_ms"], 2),
                        "success_rate": round(self.stats["success_rate"] * 100, 1),
                        "error_rate": round(SafeMath.safe_divide(self.stats["total_errors"], self.stats["total_signals"]) * 100, 1),
                        "cache_hit_rate": round(self.stats["cache_hit_rate"] * 100, 1)
                    },
                    "component_stats": {
                        "brain": brain_stats,
                        "risk": risk_stats,
                        "execution": execution_stats,
                        "notifications": notification_stats
                    },
                    "configuration": {
                        "trade_mode": self.config.TRADE_MODE,
                        "leverage": self.config.LEVERAGE,
                        "min_confidence": self.config.MIN_CONFIDENCE,
                        "max_daily_loss": self.config.MAX_DAILY_LOSS,
                        "max_positions": self.config.MAX_POSITIONS,
                        "allowed_symbols": len(self.config.ALLOWED_SYMBOLS),
                        "telegram_enabled": self.config.TELEGRAM_CONFIG.get("enabled", False)
                    }
                }
        except Exception as e:
            secure_logger.error(f"í†µê³„ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return {"error": str(e)}

# =============================================================================
# ğŸŒ FastAPI Application (ì„ íƒì )
# =============================================================================

# ì‹œìŠ¤í…œ ì´ˆê¸°í™”
phoenix_system = Phoenix95System()

if FASTAPI_AVAILABLE:
    # ë³´ì•ˆ ë¯¸ë“¤ì›¨ì–´
    class PayloadSizeLimitMiddleware(BaseHTTPMiddleware):
        """ìš”ì²­ í¬ê¸° ì œí•œ ë¯¸ë“¤ì›¨ì–´ (DoS ë°©ì§€)"""
        
        def __init__(self, app, max_size_bytes: int = 1024 * 1024):  # 1MB
            super().__init__(app)
            self.max_size = max_size_bytes
        
        async def dispatch(self, request: Request, call_next):
            if hasattr(request, 'headers'):
                content_length = request.headers.get('content-length')
                if content_length and int(content_length) > self.max_size:
                    secure_logger.warning(f"í˜ì´ë¡œë“œ í¬ê¸° ì´ˆê³¼: {content_length} bytes")
                    raise HTTPException(
                        status_code=413, 
                        detail=f"Payload too large. Max size: {self.max_size} bytes"
                    )
            
            response = await call_next(request)
            return response
    
    # FastAPI ì•± ìƒì„±
    app = FastAPI(
        title="ğŸ¦ Phoenix 95 Complete System",
        description=f"""
        **í—¤ì§€í€ë“œê¸‰ ì™„ì „ í†µí•© ê±°ë˜ ì‹œìŠ¤í…œ**
        
        ## ğŸ¯ í•µì‹¬ ê¸°ëŠ¥
        - ğŸ§  **BRAIN**: Phoenix 95 AI ë¶„ì„ (ìºì‹œ ì§€ì›)
        - âš–ï¸ **RISK**: Kelly + í—¤ì§€í€ë“œê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬
        - âš¡ **EXECUTE**: ì‹¤ì‹œê°„ ê±°ë˜ ì‹¤í–‰
        - ğŸ“± **NOTIFY**: ë©€í‹°ì±„ë„ ì•Œë¦¼ ì‹œìŠ¤í…œ
        
        ## ğŸ›¡ï¸ ì•ˆì „ì„± ë³´ì¥
        - ì˜ì¡´ì„± ì˜¤ë¥˜ ë°©ì§€ (ì„ íƒì  import)
        - íƒ€ì… ì•ˆì „ì„± í™•ë³´ (SafeMath)
        - ë©”ëª¨ë¦¬ ì•ˆì „ ê´€ë¦¬ (ìºì‹œ + GC)
        - ì˜ˆì™¸ ì²˜ë¦¬ ê°•í™” (ëª¨ë“  í•¨ìˆ˜)
        - ë³´ì•ˆ ê°ì‚¬ ë¡œê¹… (ë¯¼ê°ì •ë³´ í•„í„°ë§)
        
        ## âš™ï¸ ì‹¤í–‰ ëª¨ë“œ
        - **SIMPLE**: ê¸°ë³¸ ê¸°ëŠ¥ë§Œ (ë¹ ë¥¸ ì‘ë‹µ)
        - **ADVANCED**: ëª¨ë“  ê³ ê¸‰ ê¸°ëŠ¥ í™œì„±í™”
        
        í˜„ì¬ ëª¨ë“œ: **{CONFIG.EXECUTION_MODE}**
        """,
        version="5.0.0-complete"
    )
    
    # ë¯¸ë“¤ì›¨ì–´ ì¶”ê°€
    app.add_middleware(PayloadSizeLimitMiddleware, max_size_bytes=1024*1024)
    
    # CORS ì„¤ì •
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    @app.get("/")
    async def root():
        """ì‹œìŠ¤í…œ ì •ë³´"""
        stats = phoenix_system.get_stats()
        return {
            "system": "ğŸ¦ Phoenix 95 Complete System",
            "status": "ğŸš€ ACTIVE",
            "mode": CONFIG.EXECUTION_MODE,
            "version": CONFIG.SYSTEM_VERSION,
            "architecture": CONFIG.ARCHITECTURE,
            "components": stats["system_overview"]["components"],
            "performance": {
                "uptime_hours": stats["system_overview"]["uptime_hours"],
                "success_rate": stats["performance_stats"]["success_rate"],
                "avg_processing_time": stats["performance_stats"]["avg_processing_time_ms"],
                "cache_hit_rate": stats["performance_stats"]["cache_hit_rate"]
            },
            "features": {
                "fastapi": True,
                "telegram": CONFIG.TELEGRAM_CONFIG.get("enabled", False),
                "security_logging": True,
                "cache_system": True,
                "multi_mode": True,
                "dependencies": {
                    "fastapi": FASTAPI_AVAILABLE,
                    "requests": REQUESTS_AVAILABLE,
                    "aiohttp": AIOHTTP_AVAILABLE,
                    "psutil": PSUTIL_AVAILABLE,
                    "numpy": NUMPY_AVAILABLE
                }
            }
        }
    
    @app.get("/health")
    async def health():
        """í—¬ìŠ¤ì²´í¬"""
        stats = phoenix_system.get_stats()
        performance = stats["performance_stats"]
        
        # ê±´ê°• ìƒíƒœ ê²°ì •
        health_score = 100
        issues = []
        
        if performance["error_rate"] > 5:
            health_score -= 20
            issues.append(f"High error rate: {performance['error_rate']}%")
        
        if performance["avg_processing_time_ms"] > CONFIG.PERFORMANCE_TARGETS["max_response_time_ms"]:
            health_score -= 15
            issues.append(f"Slow response time: {performance['avg_processing_time_ms']:.1f}ms")
        
        if performance["cache_hit_rate"] < 50:
            health_score -= 10
            issues.append(f"Low cache hit rate: {performance['cache_hit_rate']:.1f}%")
        
        status = "healthy" if health_score >= 80 else "degraded" if health_score >= 60 else "unhealthy"
        
        return {
            "status": status,
            "health_score": health_score,
            "issues": issues,
            "stats": performance,
            "timestamp": time.time()
        }
    
    @app.post("/webhook/signal")
    async def process_signal(signal_request: SignalRequest):
        """ì‹ í˜¸ ì²˜ë¦¬ (ë©”ì¸ API)"""
        try:
            result = await phoenix_system.process_signal(signal_request)
            
            # ê°ì‚¬ ë¡œê·¸
            audit_logger.log_event(
                'API_SIGNAL_PROCESSED',
                'api_user',
                {
                    'symbol': signal_request.symbol,
                    'status': result.get('status'),
                    'processing_time': result.get('performance', {}).get('processing_time_ms', 0)
                }
            )
            
            return result
            
        except Exception as e:
            secure_logger.error(f"API ì‹ í˜¸ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
            
            # ê°ì‚¬ ë¡œê·¸
            audit_logger.log_event(
                'API_SIGNAL_ERROR',
                'api_user',
                {'error': str(e)},
                'HIGH'
            )
            
            raise HTTPException(status_code=500, detail=f"ì‹ í˜¸ ì²˜ë¦¬ ì‹¤íŒ¨: {str(e)}")
    
    @app.get("/stats")
    async def get_stats():
        """ì‹œìŠ¤í…œ í†µê³„"""
        return phoenix_system.get_stats()
    
    @app.get("/stats/components")
    async def get_component_stats():
        """ì»´í¬ë„ŒíŠ¸ë³„ ìƒì„¸ í†µê³„"""
        stats = phoenix_system.get_stats()
        return stats.get("component_stats", {})
    
    @app.get("/audit")
    async def get_audit_logs(count: int = 100, event_type: Optional[str] = None):
        """ê°ì‚¬ ë¡œê·¸ ì¡°íšŒ"""
        try:
            events = audit_logger.get_recent_events(count, event_type)
            summary = audit_logger.get_risk_summary()
            
            return {
                "events": events,
                "summary": summary,
                "total_requested": count,
                "total_returned": len(events),
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            secure_logger.error(f"ê°ì‚¬ ë¡œê·¸ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            raise HTTPException(status_code=500, detail="ê°ì‚¬ ë¡œê·¸ ì¡°íšŒ ì‹¤íŒ¨")
    
    @app.post("/system/alert")
    async def send_system_alert(data: dict):
        """ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡"""
        try:
            alert_type = data.get('type', 'SYSTEM')
            message = data.get('message', 'Unknown system event')
            severity = data.get('severity', 'INFO')
            
            await phoenix_system.notification_hub.send_system_alert(alert_type, message, severity)
            
            return {
                'status': 'sent', 
                'alert_type': alert_type,
                'severity': severity,
                'timestamp': datetime.now().isoformat()
            }
        except Exception as e:
            secure_logger.error(f"ì‹œìŠ¤í…œ ì•Œë¦¼ API ì˜¤ë¥˜: {e}")
            raise HTTPException(status_code=500, detail="ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨")
    
    @app.get("/config")
    async def get_config():
        """ì‹œìŠ¤í…œ ì„¤ì • ì¡°íšŒ (ë¯¼ê°ì •ë³´ ì œì™¸)"""
        return {
            "system": {
                "version": CONFIG.SYSTEM_VERSION,
                "execution_mode": CONFIG.EXECUTION_MODE,
                "trade_mode": CONFIG.TRADE_MODE
            },
            "trading": {
                "leverage": CONFIG.LEVERAGE,
                "stop_loss": CONFIG.STOP_LOSS,
                "take_profit": CONFIG.TAKE_PROFIT,
                "min_confidence": CONFIG.MIN_CONFIDENCE,
                "max_positions": CONFIG.MAX_POSITIONS,
                "allowed_symbols_count": len(CONFIG.ALLOWED_SYMBOLS)
            },
            "performance_targets": CONFIG.PERFORMANCE_TARGETS,
            "telegram_enabled": CONFIG.TELEGRAM_CONFIG.get("enabled", False)
        }
    
    @app.get("/dashboard", response_class=HTMLResponse)
    async def dashboard():
        """ì‹¤ì‹œê°„ ëŒ€ì‹œë³´ë“œ"""
        stats = phoenix_system.get_stats()
        
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Phoenix 95 Complete Dashboard</title>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{ 
                    font-family: 'Arial', sans-serif; 
                    margin: 0; 
                    padding: 20px; 
                    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); 
                    color: #fff; 
                }}
                .container {{ max-width: 1400px; margin: 0 auto; }}
                .header {{ 
                    text-align: center; 
                    margin-bottom: 40px; 
                    background: rgba(255,255,255,0.05);
                    padding: 30px;
                    border-radius: 15px;
                    backdrop-filter: blur(10px);
                }}
                .mode-badge {{
                    display: inline-block;
                    padding: 8px 16px;
                    background: {'#4CAF50' if CONFIG.EXECUTION_MODE == 'SIMPLE' else '#FF9800'};
                    color: white;
                    border-radius: 20px;
                    font-size: 14px;
                    font-weight: bold;
                    margin-left: 10px;
                }}
                .stats-grid {{ 
                    display: grid; 
                    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); 
                    gap: 25px; 
                    margin-bottom: 30px;
                }}
                .stat-card {{ 
                    background: rgba(255,255,255,0.08); 
                    padding: 25px; 
                    border-radius: 15px; 
                    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255,255,255,0.1);
                    transition: transform 0.3s ease, box-shadow 0.3s ease;
                }}
                .stat-card:hover {{
                    transform: translateY(-5px);
                    box-shadow: 0 12px 35px rgba(0,0,0,0.4);
                }}
                .stat-value {{ 
                    font-size: 2.5em; 
                    font-weight: bold; 
                    background: linear-gradient(45deg, #4CAF50, #45a049);
                    -webkit-background-clip: text;
                    -webkit-text-fill-color: transparent;
                    background-clip: text;
                }}
                .stat-label {{ 
                    color: #bbb; 
                    margin-top: 8px; 
                    font-size: 1.1em;
                }}
                .component-status {{
                    display: flex;
                    justify-content: space-around;
                    margin: 30px 0;
                    padding: 25px;
                    background: rgba(255,255,255,0.05);
                    border-radius: 15px;
                }}
                .component {{
                    text-align: center;
                    padding: 15px;
                }}
                .component-icon {{
                    font-size: 2em;
                    margin-bottom: 10px;
                }}
                .refresh {{ 
                    text-align: center; 
                    margin-top: 30px; 
                }}
                .refresh button {{ 
                    padding: 15px 30px; 
                    background: linear-gradient(45deg, #4CAF50, #45a049); 
                    color: white; 
                    border: none; 
                    border-radius: 25px; 
                    cursor: pointer; 
                    font-size: 16px;
                    font-weight: bold;
                    transition: all 0.3s ease;
                }}
                .refresh button:hover {{
                    transform: translateY(-2px);
                    box-shadow: 0 8px 20px rgba(76, 175, 80, 0.3);
                }}
                .health-indicator {{
                    display: inline-block;
                    width: 12px;
                    height: 12px;
                    background: #4CAF50;
                    border-radius: 50%;
                    margin-right: 8px;
                    animation: pulse 2s infinite;
                }}
                @keyframes pulse {{
                    0% {{ opacity: 1; }}
                    50% {{ opacity: 0.5; }}
                    100% {{ opacity: 1; }}
                }}
                .dependency-status {{
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                    gap: 15px;
                    margin-top: 20px;
                }}
                .dependency {{
                    padding: 10px;
                    background: rgba(255,255,255,0.05);
                    border-radius: 8px;
                    text-align: center;
                }}
                .available {{ border-left: 4px solid #4CAF50; }}
                .unavailable {{ border-left: 4px solid #f44336; }}
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>ğŸ¦ Phoenix 95 Complete Dashboard</h1>
                    <span class="health-indicator"></span>
                    <span>í—¤ì§€í€ë“œê¸‰ ì™„ì „ í†µí•© ê±°ë˜ ì‹œìŠ¤í…œ</span>
                    <span class="mode-badge">{CONFIG.EXECUTION_MODE} MODE</span>
                    <p style="margin-top: 15px; color: #bbb;">
                        Version {CONFIG.SYSTEM_VERSION} â€¢ {CONFIG.ARCHITECTURE} â€¢ Trade Mode: {CONFIG.TRADE_MODE}
                    </p>
                </div>
                
                <div class="component-status">
                    <div class="component">
                        <div class="component-icon">ğŸ§ </div>
                        <div><strong>BRAIN</strong></div>
                        <div>AI Analysis Engine</div>
                    </div>
                    <div class="component">
                        <div class="component-icon">âš–ï¸</div>
                        <div><strong>RISK</strong></div>
                        <div>Position Manager</div>
                    </div>
                    <div class="component">
                        <div class="component-icon">âš¡</div>
                        <div><strong>EXECUTE</strong></div>
                        <div>Trade Engine</div>
                    </div>
                    <div class="component">
                        <div class="component-icon">ğŸ“±</div>
                        <div><strong>NOTIFY</strong></div>
                        <div>Alert Hub</div>
                    </div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">{stats['performance_stats']['total_signals']}</div>
                        <div class="stat-label">ì´ ì‹ í˜¸ ì²˜ë¦¬</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-value">{stats['performance_stats']['executed_trades']}</div>
                        <div class="stat-label">ì‹¤í–‰ëœ ê±°ë˜</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-value">{stats['performance_stats']['success_rate']:.1f}%</div>
                        <div class="stat-label">ì„±ê³µë¥ </div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-value">{stats['performance_stats']['avg_processing_time_ms']:.1f}ms</div>
                        <div class="stat-label">í‰ê·  ì²˜ë¦¬ì‹œê°„</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-value">{stats['system_overview']['uptime_hours']:.1f}h</div>
                        <div class="stat-label">ê°€ë™ì‹œê°„</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-value">{stats['performance_stats']['cache_hit_rate']:.1f}%</div>
                        <div class="stat-label">ìºì‹œ íˆíŠ¸ìœ¨</div>
                    </div>
                </div>
                
                <div class="stat-card">
                    <h3>ğŸ”§ ì˜ì¡´ì„± ìƒíƒœ</h3>
                    <div class="dependency-status">
                        <div class="dependency {'available' if FASTAPI_AVAILABLE else 'unavailable'}">
                            <strong>FastAPI</strong><br>
                            {'âœ… ì‚¬ìš© ê°€ëŠ¥' if FASTAPI_AVAILABLE else 'âŒ ë¯¸ì„¤ì¹˜'}
                        </div>
                        <div class="dependency {'available' if REQUESTS_AVAILABLE else 'unavailable'}">
                            <strong>Requests</strong><br>
                            {'âœ… ì‚¬ìš© ê°€ëŠ¥' if REQUESTS_AVAILABLE else 'âŒ ë¯¸ì„¤ì¹˜'}
                        </div>
                        <div class="dependency {'available' if AIOHTTP_AVAILABLE else 'unavailable'}">
                            <strong>aiohttp</strong><br>
                            {'âœ… ì‚¬ìš© ê°€ëŠ¥' if AIOHTTP_AVAILABLE else 'âŒ ë¯¸ì„¤ì¹˜'}
                        </div>
                        <div class="dependency {'available' if PSUTIL_AVAILABLE else 'unavailable'}">
                            <strong>psutil</strong><br>
                            {'âœ… ì‚¬ìš© ê°€ëŠ¥' if PSUTIL_AVAILABLE else 'âŒ ë¯¸ì„¤ì¹˜'}
                        </div>
                        <div class="dependency {'available' if NUMPY_AVAILABLE else 'unavailable'}">
                            <strong>numpy</strong><br>
                            {'âœ… ì‚¬ìš© ê°€ëŠ¥' if NUMPY_AVAILABLE else 'âŒ ë¯¸ì„¤ì¹˜'}
                        </div>
                    </div>
                </div>
                
                <div class="refresh">
                    <button onclick="location.reload()">ğŸ”„ ìƒˆë¡œê³ ì¹¨</button>
                </div>
            </div>
            
            <script>
                // 30ì´ˆë§ˆë‹¤ ìë™ ìƒˆë¡œê³ ì¹¨
                setTimeout(() => location.reload(), 30000);
                
                // ì‹¤ì‹œê°„ ì‹œê³„
                function updateTime() {{
                    const now = new Date();
                    const timeStr = now.toLocaleTimeString('ko-KR');
                    document.title = `Phoenix 95 Dashboard - ${{timeStr}}`;
                }}
                setInterval(updateTime, 1000);
            </script>
        </body>
        </html>
        """
        
        return HTMLResponse(content=html)

else:
    app = None

# =============================================================================
# ğŸ§ª Test Functions (í…ŒìŠ¤íŠ¸ í•¨ìˆ˜)
# =============================================================================

def create_test_signals():
    """í…ŒìŠ¤íŠ¸ ì‹ í˜¸ ìƒì„± (ê°œì„ ë¨)"""
    return [
        {
            "symbol": "BTCUSDT",
            "action": "buy",
            "price": 45000.0,
            "confidence": 0.85,
            "rsi": 35.5,
            "macd": 0.003,
            "volume": 2500000,
            "account_balance": 10000.0,
            "description": "ê³ ì‹ ë¢°ë„ BTC ë§¤ìˆ˜ ì‹ í˜¸"
        },
        {
            "symbol": "ETHUSDT",
            "action": "sell",
            "price": 2800.0,
            "confidence": 0.72,
            "rsi": 75.2,
            "macd": -0.002,
            "volume": 1800000,
            "account_balance": 10000.0,
            "description": "ì¤‘ê°„ì‹ ë¢°ë„ ETH ë§¤ë„ ì‹ í˜¸"
        },
        {
            "symbol": "BNBUSDT",
            "action": "long",
            "price": 320.0,
            "confidence": 0.92,
            "rsi": 45.0,
            "macd": 0.008,
            "volume": 3200000,
            "account_balance": 10000.0,
            "description": "ì´ˆê³ ì‹ ë¢°ë„ BNB ë¡± ì‹ í˜¸"
        },
        {
            "symbol": "ADAUSDT",
            "action": "buy",
            "price": 0.45,
            "confidence": 0.38,
            "rsi": 52.1,
            "volume": 800000,
            "account_balance": 10000.0,
            "description": "ì €ì‹ ë¢°ë„ ADA ë§¤ìˆ˜ ì‹ í˜¸ (HOLD ì˜ˆìƒ)"
        },
        {
            "symbol": "SOLUSDT",
            "action": "short",
            "price": 95.0,
            "confidence": 0.78,
            "rsi": 68.5,
            "macd": -0.005,
            "volume": 2100000,
            "account_balance": 10000.0,
            "description": "ê³ ì‹ ë¢°ë„ SOL ìˆ ì‹ í˜¸"
        }
    ]

async def run_comprehensive_test():
    """ì¢…í•© í…ŒìŠ¤íŠ¸ ì‹¤í–‰ (ê°œì„ ë¨)"""
    print("\nğŸ§ª Phoenix 95 Complete System ì¢…í•© í…ŒìŠ¤íŠ¸")
    print("=" * 70)
    print(f"ì‹¤í–‰ ëª¨ë“œ: {CONFIG.EXECUTION_MODE}")
    print(f"ê±°ë˜ ëª¨ë“œ: {CONFIG.TRADE_MODE}")
    print(f"ë ˆë²„ë¦¬ì§€: {CONFIG.LEVERAGE}x")
    print("=" * 70)
    
    test_signals = create_test_signals()
    results = []
    
    for i, test_data in enumerate(test_signals, 1):
        print(f"\nğŸ“Š í…ŒìŠ¤íŠ¸ {i}/{len(test_signals)}: {test_data['description']}")
        
        try:
            start_time = time.time()
            result = await phoenix_system.process_signal(test_data)
            processing_time = (time.time() - start_time) * 1000
            
            if result["status"] == "success":
                trade = result["trade_result"]
                perf = result["performance"]
                
                print(f"   âœ… ì²˜ë¦¬ ì„±ê³µ:")
                print(f"      ğŸ”¥ Phoenix 95: {trade['phoenix_95_score']:.1%}")
                print(f"      âš¡ ìƒíƒœ: {trade['execution_status']}")
                print(f"      ğŸ’° í¬ì§€ì…˜: ${trade['leveraged_size']:,.0f}")
                print(f"      â±ï¸ ì‹œê°„: {perf['processing_time_ms']:.1f}ms")
                print(f"      ğŸ† í—¤ì§€í€ë“œê¸‰: {'âœ…' if perf['hedge_fund_grade'] else 'âŒ'}")
                
                if CONFIG.EXECUTION_MODE == "ADVANCED" and "advanced_info" in result:
                    adv = result["advanced_info"]
                    print(f"      ğŸ“ˆ ìºì‹œ ì‚¬ìš©: {'âœ…' if adv['analysis_details']['cache_used'] else 'âŒ'}")
                    print(f"      ğŸ¯ Kelly Fraction: {adv['risk_details']['kelly_fraction']:.4f}")
                
            elif result["status"] == "rejected":
                risk_check = result["risk_check"]
                print(f"   âŒ ë¦¬ìŠ¤í¬ ê±°ì ˆ:")
                print(f"      ğŸ“‹ ì‚¬ìœ : {'; '.join(risk_check['checks'][:2])}")
                print(f"      ğŸ“Š ë¦¬ìŠ¤í¬ ë ˆë²¨: {risk_check['risk_level']}")
                
            else:
                print(f"   âŒ ì²˜ë¦¬ ì‹¤íŒ¨: {result['message']}")
            
            results.append({
                'test_id': i,
                'symbol': test_data['symbol'],
                'status': result['status'],
                'processing_time': processing_time
            })
                
        except Exception as e:
            print(f"   âŒ í…ŒìŠ¤íŠ¸ ì˜¤ë¥˜: {e}")
            results.append({
                'test_id': i,
                'symbol': test_data['symbol'],
                'status': 'error',
                'processing_time': 0
            })
    
    # ì¢…í•© í†µê³„
    print(f"\nğŸ“Š í…ŒìŠ¤íŠ¸ ê²°ê³¼ ìš”ì•½:")
    print("=" * 50)
    
    total_tests = len(results)
    successful = len([r for r in results if r['status'] == 'success'])
    rejected = len([r for r in results if r['status'] == 'rejected'])
    errors = len([r for r in results if r['status'] == 'error'])
    avg_time = sum(r['processing_time'] for r in results) / total_tests if total_tests > 0 else 0
    
    print(f"ì´ í…ŒìŠ¤íŠ¸: {total_tests}")
    print(f"ì„±ê³µ: {successful} ({successful/total_tests*100:.1f}%)")
    print(f"ê±°ì ˆ: {rejected} ({rejected/total_tests*100:.1f}%)")
    print(f"ì˜¤ë¥˜: {errors} ({errors/total_tests*100:.1f}%)")
    print(f"í‰ê·  ì²˜ë¦¬ì‹œê°„: {avg_time:.1f}ms")
    
    # ì‹œìŠ¤í…œ í†µê³„
    stats = phoenix_system.get_stats()
    print(f"\nğŸ“ˆ ì‹œìŠ¤í…œ ì„±ëŠ¥:")
    print(f"   ì „ì²´ ì‹ í˜¸: {stats['performance_stats']['total_signals']}")
    print(f"   ì„±ê³µë¥ : {stats['performance_stats']['success_rate']:.1f}%")
    print(f"   í‰ê·  ì²˜ë¦¬ì‹œê°„: {stats['performance_stats']['avg_processing_time_ms']:.1f}ms")
    print(f"   ìºì‹œ íˆíŠ¸ìœ¨: {stats['performance_stats']['cache_hit_rate']:.1f}%")
    
    # ì»´í¬ë„ŒíŠ¸ ìƒíƒœ
    comp_stats = stats.get('component_stats', {})
    print(f"\nğŸ”§ ì»´í¬ë„ŒíŠ¸ ìƒíƒœ:")
    if 'brain' in comp_stats:
        print(f"   ğŸ§  BRAIN - ìºì‹œ í¬ê¸°: {comp_stats['brain']['size']}")
    if 'risk' in comp_stats:
        print(f"   âš–ï¸ RISK - í™œì„± í¬ì§€ì…˜: {comp_stats['risk']['current_status']['active_positions']}")
    if 'execution' in comp_stats:
        print(f"   âš¡ EXECUTE - ì´ ê±°ë˜: {comp_stats['execution']['execution_stats']['total_trades']}")
    
    print("\nâœ… ì¢…í•© í…ŒìŠ¤íŠ¸ ì™„ë£Œ!")

# =============================================================================
# ğŸƒâ€â™‚ï¸ Main Execution Functions (ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜ë“¤)
# =============================================================================

def run_simple_mode():
    """ë‹¨ìˆœ ëª¨ë“œ ì‹¤í–‰ (FastAPI ì—†ì´)"""
    print(f"""
ğŸ¦ Phoenix 95 Complete System - SIMPLE Mode
================================================================================

ğŸ¯ í™œì„±í™”ëœ ê¸°ëŠ¥:
âœ… í•µì‹¬ 4ëŒ€ ì»´í¬ë„ŒíŠ¸ (BRAIN, RISK, EXECUTE, NOTIFY)  
âœ… Phoenix 95 AI ë¶„ì„ ì—”ì§„
âœ… í—¤ì§€í€ë“œê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬
âœ… ì•ˆì „í•œ íƒ€ì… ì‹œìŠ¤í…œ
âœ… ìºì‹œ ì‹œìŠ¤í…œ (5ë¶„ TTL)
âœ… í…”ë ˆê·¸ë¨ ì•Œë¦¼
âœ… ë³´ì•ˆ ê°ì‚¬ ë¡œê¹…

âš™ï¸ ì„¤ì •:
â€¢ ë ˆë²„ë¦¬ì§€: {CONFIG.LEVERAGE}x ISOLATED
â€¢ ìµì ˆ/ì†ì ˆ: Â±{CONFIG.STOP_LOSS:.1%}
â€¢ ìµœì†Œ ì‹ ë¢°ë„: {CONFIG.MIN_CONFIDENCE:.1%}
â€¢ ìµœëŒ€ ì¼ì¼ì†ì‹¤: {CONFIG.MAX_DAILY_LOSS:.1%}

================================================================================
""")
    
    try:
        # ì‹œì‘ ì•Œë¦¼
        async def send_start_notification():
            await phoenix_system.notification_hub.send_system_alert(
                "SYSTEM_START",
                f"Phoenix 95 Complete System ì‹œì‘ (SIMPLE ëª¨ë“œ)",
                "INFO"
            )
        
        asyncio.run(send_start_notification())
        
        # í…ŒìŠ¤íŠ¸ ì‹¤í–‰
        print("ğŸ§ª ìë™ í…ŒìŠ¤íŠ¸ ì‹œì‘...")
        asyncio.run(run_comprehensive_test())
        
        print("\n" + "="*50)
        print("ğŸ’¡ ì‚¬ìš©ë²•:")
        print("   Python ì½”ë“œì—ì„œ phoenix_system.process_signal(data) í˜¸ì¶œ")
        print("   ë˜ëŠ” --server ì˜µì…˜ìœ¼ë¡œ FastAPI ì„œë²„ ì‹¤í–‰")
        print("="*50)
        
    except KeyboardInterrupt:
        print("\nğŸ‘‹ Phoenix 95 ì‹œìŠ¤í…œ ì¢…ë£Œ")
    except Exception as e:
        secure_logger.error(f"Simple ëª¨ë“œ ì‹¤í–‰ ì˜¤ë¥˜: {e}")

def run_server_mode():
    """ì„œë²„ ëª¨ë“œ ì‹¤í–‰ (FastAPI)"""
    if not FASTAPI_AVAILABLE:
        print("âŒ FastAPIê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤.")
        print("ì„¤ì¹˜: pip install fastapi uvicorn")
        return
    
    print(f"""
ğŸ¦ Phoenix 95 Complete System - SERVER Mode
================================================================================

ğŸŒ ì„œë²„ ì •ë³´:
â€¢ ë©”ì¸ ì„œë²„: http://localhost:8000
â€¢ API ë¬¸ì„œ: http://localhost:8000/docs  
â€¢ ëŒ€ì‹œë³´ë“œ: http://localhost:8000/dashboard
â€¢ í—¬ìŠ¤ì²´í¬: http://localhost:8000/health

ğŸ¯ ì£¼ìš” ì—”ë“œí¬ì¸íŠ¸:
â€¢ POST /webhook/signal - ì‹ í˜¸ ì²˜ë¦¬
â€¢ GET /stats - ì‹œìŠ¤í…œ í†µê³„
â€¢ GET /audit - ê°ì‚¬ ë¡œê·¸
â€¢ GET /config - ì„¤ì • ì¡°íšŒ

âš™ï¸ ì‹¤í–‰ ëª¨ë“œ: {CONFIG.EXECUTION_MODE}
ğŸ”§ ê±°ë˜ ëª¨ë“œ: {CONFIG.TRADE_MODE}

================================================================================
""")
    
    try:
        import uvicorn
        
        # ì„œë²„ ì‹œì‘ ì•Œë¦¼
        async def send_server_start():
            await phoenix_system.notification_hub.send_system_alert(
                "SERVER_START",
                f"Phoenix 95 ì„œë²„ ì‹œì‘ (í¬íŠ¸: 8000, ëª¨ë“œ: {CONFIG.EXECUTION_MODE})",
                "INFO"
            )
        
        # ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì•Œë¦¼ ì „ì†¡
        def background_notification():
            asyncio.run(send_server_start())
        
        notification_thread = threading.Thread(target=background_notification, daemon=True)
        notification_thread.start()
        
        # ì„œë²„ ì‹¤í–‰
        uvicorn.run(
            app, 
            host="0.0.0.0", 
            port=8000, 
            log_level="info"
        )
        
    except KeyboardInterrupt:
        print("\nğŸ‘‹ Phoenix 95 ì„œë²„ ì¢…ë£Œ")
    except Exception as e:
        secure_logger.error(f"ì„œë²„ ëª¨ë“œ ì‹¤í–‰ ì˜¤ë¥˜: {e}")

def run_demo_mode():
    """ë°ëª¨ ëª¨ë“œ (ëŒ€í™”í˜•)"""
    print(f"""
ğŸ­ Phoenix 95 Complete System - DEMO Mode
================================================================================

ëŒ€í™”í˜• ë°ëª¨ ëª¨ë“œì…ë‹ˆë‹¤.
ì‹¤ì‹œê°„ìœ¼ë¡œ ì‹ í˜¸ë¥¼ ì…ë ¥í•˜ê³  ê²°ê³¼ë¥¼ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ğŸ’¡ ì‚¬ìš©ë²•:
1. ì‹¬ë³¼ ì…ë ¥ (ì˜ˆ: BTCUSDT)
2. ì•¡ì…˜ ì…ë ¥ (buy/sell/long/short)
3. ê°€ê²© ì…ë ¥ (ì˜ˆ: 45000)
4. ì‹ ë¢°ë„ ì…ë ¥ (0.1-1.0, ê¸°ë³¸ê°’: 0.8)

ì¢…ë£Œí•˜ë ¤ë©´ 'quit' ì…ë ¥

================================================================================
""")
    
    try:
        while True:
            print("\n" + "â”€" * 50)
            
            # ì‚¬ìš©ì ì…ë ¥
            symbol = input("ğŸ“Š ì‹¬ë³¼ (ë˜ëŠ” 'quit'): ").strip().upper()
            if symbol.lower() == 'quit':
                break
            
            if symbol not in CONFIG.ALLOWED_SYMBOLS:
                print(f"âŒ ì§€ì›í•˜ì§€ ì•ŠëŠ” ì‹¬ë³¼ì…ë‹ˆë‹¤. ì§€ì› ì‹¬ë³¼: {', '.join(CONFIG.ALLOWED_SYMBOLS[:5])}...")
                continue
            
            action = input("âš¡ ì•¡ì…˜ (buy/sell/long/short): ").strip().lower()
            if action not in ['buy', 'sell', 'long', 'short']:
                print("âŒ ìœ íš¨í•˜ì§€ ì•Šì€ ì•¡ì…˜ì…ë‹ˆë‹¤.")
                continue
            
            try:
                price = float(input("ğŸ’° ê°€ê²©: "))
                confidence = float(input("ğŸ¯ ì‹ ë¢°ë„ (0.1-1.0, ê¸°ë³¸ê°’ 0.8): ") or "0.8")
                confidence = max(0.1, min(confidence, 1.0))
            except ValueError:
                print("âŒ ìœ íš¨í•˜ì§€ ì•Šì€ ìˆ«ìì…ë‹ˆë‹¤.")
                continue
            
            # ì‹ í˜¸ ì²˜ë¦¬
            signal_data = {
                "symbol": symbol,
                "action": action,
                "price": price,
                "confidence": confidence,
                "account_balance": 10000.0
            }
            
            print(f"\nğŸ”„ ì²˜ë¦¬ ì¤‘...")
            
            try:
                result = asyncio.run(phoenix_system.process_signal(signal_data))
                
                print(f"\nğŸ“‹ ê²°ê³¼:")
                print(f"ìƒíƒœ: {result['status']}")
                
                if result['status'] == 'success':
                    trade = result['trade_result']
                    perf = result['performance']
                    
                    print(f"Phoenix 95 ì ìˆ˜: {trade['phoenix_95_score']:.1%}")
                    print(f"ì‹¤í–‰ ìƒíƒœ: {trade['execution_status']}")
                    print(f"í¬ì§€ì…˜ í¬ê¸°: ${trade['leveraged_size']:,.0f}")
                    print(f"ì²˜ë¦¬ ì‹œê°„: {perf['processing_time_ms']:.1f}ms")
                    print(f"í—¤ì§€í€ë“œê¸‰: {'âœ…' if perf['hedge_fund_grade'] else 'âŒ'}")
                    
                    if trade['execution_status'] == 'EXECUTED':
                        print(f"ì†ì ˆê°€: ${trade['stop_loss']:,.2f}")
                        print(f"ìµì ˆê°€: ${trade['take_profit']:,.2f}")
                    else:
                        print(f"ë³´ë¥˜ ì‚¬ìœ : {trade['execution_reason']}")
                        
                elif result['status'] == 'rejected':
                    risk_check = result['risk_check']
                    print(f"ê±°ì ˆ ì‚¬ìœ : {'; '.join(risk_check['checks'])}")
                    
                else:
                    print(f"ì˜¤ë¥˜: {result['message']}")
                    
            except Exception as e:
                print(f"âŒ ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
        
        print("\nğŸ‘‹ ë°ëª¨ ëª¨ë“œ ì¢…ë£Œ")
        
    except KeyboardInterrupt:
        print("\nğŸ‘‹ ë°ëª¨ ëª¨ë“œ ì¢…ë£Œ")
    except Exception as e:
        secure_logger.error(f"ë°ëª¨ ëª¨ë“œ ì‹¤í–‰ ì˜¤ë¥˜: {e}")

# =============================================================================
# ğŸš€ Main Function (ë©”ì¸ í•¨ìˆ˜)
# =============================================================================

def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    print("""
ğŸ¦ Phoenix 95 Complete System v5.0 - ì™„ì „ í†µí•© í—¤ì§€í€ë“œê¸‰ ì‹œìŠ¤í…œ
================================================================================

ğŸ›¡ï¸ ì•ˆì „ì„± ìš°ì„  ì„¤ê³„ + ê³ ê¸‰ ê¸°ëŠ¥:
- âœ… ì˜ì¡´ì„± ì˜¤ë¥˜ ë°©ì§€ (ì„ íƒì  import + ê¸°ë³¸ê°’)
- âœ… ëŸ°íƒ€ì„ ì˜¤ë¥˜ ë°©ì§€ (íƒ€ì… ì•ˆì „ì„± + None ì²´í¬)  
- âœ… ë©”ëª¨ë¦¬ ì•ˆì „ì„± (ìºì‹œ + ìë™ ì •ë¦¬ + GC)
- âœ… ì˜ˆì™¸ ì²˜ë¦¬ ê°•í™” (ëª¨ë“  í•¨ìˆ˜ì— try-catch)
- âœ… ì„¤ì • ì•ˆì „ì„± (í™˜ê²½ë³€ìˆ˜ + ê¸°ë³¸ê°’)
- âœ… ë³´ì•ˆ ê°ì‚¬ ë¡œê¹… (ë¯¼ê°ì •ë³´ í•„í„°ë§)
- âœ… ë©€í‹°ëª¨ë“œ ì‹¤í–‰ (SIMPLE/ADVANCED)

ğŸ’ 4ëŒ€ í•µì‹¬ ì»´í¬ë„ŒíŠ¸:
- ğŸ§  BRAIN: Signal Intelligence Engine (Phoenix 95 AI + ìºì‹œ)
- âš–ï¸ RISK: Position & Risk Manager (Kelly + í—¤ì§€í€ë“œê¸‰)
- âš¡ EXECUTE: Trade Execution Engine (ì‹¤ì‹œê°„ + ì¡°ê±´ë¶€)  
- ğŸ“± NOTIFY: Alert & Monitor Hub (ë©€í‹°ì±„ë„ + ë³´ì•ˆ)

================================================================================
""")
    
    if len(sys.argv) > 1:
        command = sys.argv[1].lower()
        
        if command == "--server":
            run_server_mode()
            
        elif command == "--test":
            print("ğŸ§ª ì¢…í•© í…ŒìŠ¤íŠ¸ ëª¨ë“œ")
            asyncio.run(run_comprehensive_test())
            
        elif command == "--demo":
            run_demo_mode()
            
        elif command == "--simple":
            CONFIG.EXECUTION_MODE = "SIMPLE"
            run_simple_mode()
            
        elif command == "--advanced":
            CONFIG.EXECUTION_MODE = "ADVANCED"
            run_simple_mode()
            
        elif command == "--stats":
            print("ğŸ“Š ì‹œìŠ¤í…œ í†µê³„:")
            stats = phoenix_system.get_stats()
            for category, data in stats.items():
                print(f"\n{category.upper()}:")
                if isinstance(data, dict):
                    for key, value in data.items():
                        print(f"  {key}: {value}")
                else:
                    print(f"  {data}")
                    
        elif command == "--config":
            print("âš™ï¸ ì‹œìŠ¤í…œ ì„¤ì •:")
            print(f"  ì‹¤í–‰ ëª¨ë“œ: {CONFIG.EXECUTION_MODE}")
            print(f"  ê±°ë˜ ëª¨ë“œ: {CONFIG.TRADE_MODE}")
            print(f"  ë ˆë²„ë¦¬ì§€: {CONFIG.LEVERAGE}x")
            print(f"  ìµœì†Œ ì‹ ë¢°ë„: {CONFIG.MIN_CONFIDENCE:.1%}")
            print(f"  ìµœëŒ€ ì¼ì¼ì†ì‹¤: {CONFIG.MAX_DAILY_LOSS:.1%}")
            print(f"  ìµœëŒ€ í¬ì§€ì…˜: {CONFIG.MAX_POSITIONS}")
            print(f"  ì§€ì› ì‹¬ë³¼: {len(CONFIG.ALLOWED_SYMBOLS)}ê°œ")
            print(f"  í…”ë ˆê·¸ë¨: {'âœ…' if CONFIG.TELEGRAM_CONFIG.get('enabled') else 'âŒ'}")
            
        elif command == "--help":
            print("""
ğŸ“‹ ì‚¬ìš©ë²•:
  python phoenix95_complete.py [ì˜µì…˜]

ğŸ¯ ì˜µì…˜:
  --server      FastAPI ì„œë²„ ì‹¤í–‰ (http://localhost:8000)
  --simple      ë‹¨ìˆœ ëª¨ë“œ (ê¸°ë³¸ ê¸°ëŠ¥ë§Œ)
  --advanced    ê³ ê¸‰ ëª¨ë“œ (ëª¨ë“  ê¸°ëŠ¥)
  --test        ì¢…í•© í…ŒìŠ¤íŠ¸ ì‹¤í–‰
  --demo        ëŒ€í™”í˜• ë°ëª¨ ëª¨ë“œ
  --stats       ì‹œìŠ¤í…œ í†µê³„ ì¡°íšŒ
  --config      ì„¤ì • ì •ë³´ ì¡°íšŒ
  --help        ë„ì›€ë§ í‘œì‹œ

ğŸ”§ í™˜ê²½ë³€ìˆ˜:
  PHOENIX_MODE=SIMPLE|ADVANCED  # ì‹¤í–‰ ëª¨ë“œ
  TRADE_MODE=TEST|LIVE          # ê±°ë˜ ëª¨ë“œ
  TELEGRAM_BOT_TOKEN=xxx        # í…”ë ˆê·¸ë¨ í† í°
  TELEGRAM_CHAT_ID=xxx          # í…”ë ˆê·¸ë¨ ì±„íŒ… ID
  LEVERAGE=20                   # ë ˆë²„ë¦¬ì§€ (ê¸°ë³¸: 20)
  MIN_CONFIDENCE=0.75           # ìµœì†Œ ì‹ ë¢°ë„ (ê¸°ë³¸: 75%)

ğŸ’¡ ì˜ˆì‹œ:
  python phoenix95_complete.py --server
  PHOENIX_MODE=ADVANCED python phoenix95_complete.py --demo
  TRADE_MODE=LIVE python phoenix95_complete.py --test
""")
            
        else:
            print(f"âŒ ì•Œ ìˆ˜ ì—†ëŠ” ëª…ë ¹ì–´: {command}")
            print("ë„ì›€ë§: python phoenix95_complete.py --help")
            
    else:
        # ê¸°ë³¸ ì‹¤í–‰ (í™˜ê²½ì— ë”°ë¼ ìë™ ê²°ì •)
        if FASTAPI_AVAILABLE and CONFIG.EXECUTION_MODE == "ADVANCED":
            print("ğŸš€ ìë™ ëª¨ë“œ: FastAPI ì„œë²„ ì‹¤í–‰")
            run_server_mode()
        else:
            print("ğŸš€ ìë™ ëª¨ë“œ: Simple ëª¨ë“œ ì‹¤í–‰")
            run_simple_mode()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nğŸ‘‹ Phoenix 95 Complete System ì¢…ë£Œ")
        # ì•ˆì „í•œ ì •ë¦¬
        gc.collect()
    except Exception as e:
        secure_logger.error(f"âŒ ì‹¤í–‰ ì˜¤ë¥˜: {e}")
        print(f"âŒ ì‹œìŠ¤í…œ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
        print("ğŸ’¡ ì˜ì¡´ì„± ì„¤ì¹˜: pip install fastapi uvicorn requests aiohttp psutil numpy")
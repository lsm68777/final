#!/usr/bin/env python3
"""
üè¶ Phoenix 95 Complete System - ÏôÑÏ†Ñ ÌÜµÌï© Ìó§ÏßÄÌéÄÎìúÍ∏â ÏãúÏä§ÌÖú (ÏàòÏ†ïÎê®)
================================================================================

üîß ÏïàÏ†ÑÏÑ± Ïö∞ÏÑ† ÏÑ§Í≥Ñ + Í≥†Í∏â Í∏∞Îä•:
‚úÖ ÏùòÏ°¥ÏÑ± Ïò§Î•ò Î∞©ÏßÄ (ÏÑ†ÌÉùÏ†Å import + Í∏∞Î≥∏Í∞í)
‚úÖ Îü∞ÌÉÄÏûÑ Ïò§Î•ò Î∞©ÏßÄ (ÌÉÄÏûÖ ÏïàÏ†ÑÏÑ± + None Ï≤¥ÌÅ¨)
‚úÖ Î©îÎ™®Î¶¨ ÏïàÏ†ÑÏÑ± (ÏûêÎèô Ï†ïÎ¶¨ + GC)
‚úÖ ÏòàÏô∏ Ï≤òÎ¶¨ Í∞ïÌôî (Î™®Îì† Ìï®ÏàòÏóê try-catch)
‚úÖ ÏÑ§Ï†ï ÏïàÏ†ÑÏÑ± (ÌôòÍ≤ΩÎ≥ÄÏàò + Í∏∞Î≥∏Í∞í)
‚úÖ Î≥¥Ïïà Í∞êÏÇ¨ Î°úÍπÖ (ÎØºÍ∞êÏ†ïÎ≥¥ ÌïÑÌÑ∞ÎßÅ)
‚úÖ Ïã§ÏãúÍ∞Ñ ÏãúÏä§ÌÖú Î™®ÎãàÌÑ∞ÎßÅ
‚úÖ Í≥†Í∏â Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨ (Kelly Criterion)
‚úÖ Î©ÄÌã∞Î™®Îìú Ïã§Ìñâ (Îã®Ïàú/Í≥†Í∏â Î™®Îìú)

üíé 4ÎåÄ ÌïµÏã¨ Ïª¥Ìè¨ÎÑåÌä∏:
- üß† BRAIN: Signal Intelligence Engine (Phoenix 95 AI)
- ‚öñÔ∏è RISK: Position & Risk Manager (Kelly + Ìó§ÏßÄÌéÄÎìúÍ∏â)
- ‚ö° EXECUTE: Trade Execution Engine (Ïã§ÏãúÍ∞Ñ Í±∞Îûò)
- üì± NOTIFY: Alert & Monitor Hub (Îã§Ï§ë Ï±ÑÎÑê ÏïåÎ¶º)

================================================================================
"""

import asyncio
import time
import json
import logging
import os
import sys
import gc
import threading
import hashlib
import hmac
import secrets
import re
import html
from datetime import datetime, timedelta
from dataclasses import dataclass, field
from typing import Dict, List, Optional, Any, Union, Tuple  # Tuple Ï∂îÍ∞Ä
from pathlib import Path
import multiprocessing

# =============================================================================
# üîí Safe Imports with Fallbacks (ÏïàÏ†ÑÌïú ÏùòÏ°¥ÏÑ± Í¥ÄÎ¶¨)
# =============================================================================

# Í∏∞Î≥∏ Î°úÍπÖ ÏÑ§Ï†ï
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger(__name__)

# FastAPI ÏÑ†ÌÉùÏ†Å import
FASTAPI_AVAILABLE = False
try:
    from fastapi import FastAPI, HTTPException, Request, Response
    from fastapi.middleware.cors import CORSMiddleware
    from fastapi.middleware.base import BaseHTTPMiddleware
    from fastapi.responses import HTMLResponse, JSONResponse, PlainTextResponse
    from pydantic import BaseModel, field_validator
    import uvicorn
    FASTAPI_AVAILABLE = True
    logger.info("‚úÖ FastAPI ÏÇ¨Ïö© Í∞ÄÎä•")
except ImportError:
    logger.warning("‚ö†Ô∏è FastAPI ÎØ∏ÏÑ§Ïπò - Í∏∞Î≥∏ Î™®ÎìúÎ°ú Ïã§Ìñâ")
    class BaseModel:
        pass

# ÎÑ§Ìä∏ÏõåÌÅ¨ ÎùºÏù¥Î∏åÎü¨Î¶¨ ÏÑ†ÌÉùÏ†Å import
REQUESTS_AVAILABLE = False
try:
    import requests
    REQUESTS_AVAILABLE = True
    logger.info("‚úÖ Requests ÏÇ¨Ïö© Í∞ÄÎä•")
except ImportError:
    logger.warning("‚ö†Ô∏è Requests ÎØ∏ÏÑ§Ïπò - ÌÖîÎ†àÍ∑∏Îû® Í∏∞Îä• Ï†úÌïú")

# Í≥†Í∏â ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏
AIOHTTP_AVAILABLE = False
try:
    import aiohttp
    AIOHTTP_AVAILABLE = True
    logger.info("‚úÖ aiohttp ÏÇ¨Ïö© Í∞ÄÎä•")
except ImportError:
    logger.warning("‚ö†Ô∏è aiohttp ÎØ∏ÏÑ§Ïπò - Í≥†Í∏â ÎÑ§Ìä∏ÏõåÌÅ¨ Í∏∞Îä• Ï†úÌïú")

# ÏãúÏä§ÌÖú Î™®ÎãàÌÑ∞ÎßÅ
PSUTIL_AVAILABLE = False
try:
    import psutil
    PSUTIL_AVAILABLE = True
    logger.info("‚úÖ psutil ÏÇ¨Ïö© Í∞ÄÎä•")
except ImportError:
    logger.warning("‚ö†Ô∏è psutil ÎØ∏ÏÑ§Ïπò - ÏãúÏä§ÌÖú Î™®ÎãàÌÑ∞ÎßÅ Ï†úÌïú")

# ÏàòÏπò Ïó∞ÏÇ∞
NUMPY_AVAILABLE = False
try:
    import numpy as np
    NUMPY_AVAILABLE = True
    logger.info("‚úÖ numpy ÏÇ¨Ïö© Í∞ÄÎä•")
except ImportError:
    logger.warning("‚ö†Ô∏è numpy ÎØ∏ÏÑ§Ïπò - Í≥†Í∏â ÏàòÏπò Ïó∞ÏÇ∞ Ï†úÌïú")

# JWT ÏÑ†ÌÉùÏ†Å import
JWT_AVAILABLE = False
try:
    import jwt
    JWT_AVAILABLE = True
    logger.info("‚úÖ JWT ÏÇ¨Ïö© Í∞ÄÎä•")
except ImportError:
    logger.warning("‚ö†Ô∏è JWT ÎØ∏ÏÑ§Ïπò - ÌÜ†ÌÅ∞ Í∏∞Îä• ÎπÑÌôúÏÑ±Ìôî")

# =============================================================================
# üõ°Ô∏è Security Logging System (Î≥¥Ïïà Î°úÍπÖ ÏãúÏä§ÌÖú)
# =============================================================================

class SecureLogger:
    """ÎØºÍ∞êÏ†ïÎ≥¥Î•º ÌïÑÌÑ∞ÎßÅÌïòÎäî ÏïàÏ†ÑÌïú Î°úÍπÖ ÏãúÏä§ÌÖú"""
    
    def __init__(self):
        self.sensitive_patterns = [
            r'[A-Za-z0-9]{60,}',  # API ÌÇ§ Ìå®ÌÑ¥
            r'bot\d+:[A-Za-z0-9_-]+',  # ÌÖîÎ†àÍ∑∏Îû® Î¥á ÌÜ†ÌÅ∞
            r'password["\']?\s*[:=]\s*["\']?([^"\']+)',  # Ìå®Ïä§ÏõåÎìú
            r'secret["\']?\s*[:=]\s*["\']?([^"\']+)',  # ÏãúÌÅ¨Î¶ø
        ]
        
        # Î°úÍ∑∏ ÏÑ§Ï†ï
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
            handlers=[
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger("Phoenix95")
    
    def sanitize_log(self, message: str) -> str:
        """Î°úÍ∑∏ Î©îÏãúÏßÄÏóêÏÑú ÎØºÍ∞êÏ†ïÎ≥¥ Ï†úÍ±∞"""
        message = str(message)
        for pattern in self.sensitive_patterns:
            message = re.sub(pattern, '[REDACTED]', message, flags=re.IGNORECASE)
        return message
    
    def info(self, message: str):
        self.logger.info(self.sanitize_log(message))
    
    def warning(self, message: str):
        self.logger.warning(self.sanitize_log(message))
    
    def error(self, message: str):
        self.logger.error(self.sanitize_log(message))

# Ï†ÑÏó≠ Î≥¥Ïïà Î°úÍ±∞
secure_logger = SecureLogger()

# =============================================================================
# üõ°Ô∏è Type Safe Math Utilities (ÏïàÏ†ÑÌïú ÏàòÌïô Ïó∞ÏÇ∞)
# =============================================================================

class SafeMath:
    """ÏôÑÏ†ÑÌûà ÏïàÏ†ÑÌïú ÏàòÌïô Ïó∞ÏÇ∞ Ïú†Ìã∏Î¶¨Ìã∞"""
    
    @staticmethod
    def safe_float(value: Any, default: float = 0.0) -> float:
        """ÏïàÏ†ÑÌïú float Î≥ÄÌôò"""
        try:
            if value is None:
                return default
            if isinstance(value, bool):
                return default
            return float(value)
        except (ValueError, TypeError, OverflowError):
            return default
    
    @staticmethod
    def safe_divide(numerator: Any, denominator: Any, default: float = 0.0) -> float:
        """ÏôÑÏ†ÑÌûà ÏïàÏ†ÑÌïú ÎÇòÎàÑÍ∏∞"""
        try:
            num = SafeMath.safe_float(numerator)
            den = SafeMath.safe_float(denominator)
            
            if abs(den) < 1e-10:  # 0ÏúºÎ°ú ÎÇòÎàÑÍ∏∞ Î∞©ÏßÄ
                return default
            
            result = num / den
            
            # NaN, Infinity Ï≤¥ÌÅ¨
            if not (result == result and abs(result) != float('inf')):
                return default
                
            return result
        except Exception:
            return default
    
    @staticmethod
    def safe_multiply(a: Any, b: Any, default: float = 0.0) -> float:
        """ÏïàÏ†ÑÌïú Í≥±ÌïòÍ∏∞"""
        try:
            val_a = SafeMath.safe_float(a)
            val_b = SafeMath.safe_float(b)
            
            result = val_a * val_b
            
            # Ïò§Î≤ÑÌîåÎ°úÏö∞ Ï≤¥ÌÅ¨
            if not (result == result and abs(result) != float('inf')):
                return default
                
            return result
        except Exception:
            return default
    
    @staticmethod
    def clamp(value: Any, min_val: float, max_val: float) -> float:
        """Í∞í Î≤îÏúÑ Ï†úÌïú"""
        try:
            val = SafeMath.safe_float(value)
            min_v = SafeMath.safe_float(min_val)
            max_v = SafeMath.safe_float(max_val)
            
            if min_v > max_v:
                min_v, max_v = max_v, min_v
            
            return max(min_v, min(val, max_v))
        except Exception:
            return min_val

# =============================================================================
# üîß Configuration Management (ÏÑ§Ï†ï Í¥ÄÎ¶¨)
# =============================================================================

@dataclass
class SafeConfig:
    """ÏïàÏ†ÑÌïòÍ≥† Ïú†Ïó∞Ìïú ÏÑ§Ï†ï Í¥ÄÎ¶¨"""
    
    def __init__(self):
        # ÏãúÏä§ÌÖú Ï†ïÎ≥¥
        self.SYSTEM_VERSION: int = 5
        self.ARCHITECTURE: str = "complete_system"
        self.EXECUTION_MODE: str = os.getenv("PHOENIX_MODE", "SIMPLE")  # SIMPLE or ADVANCED
        
        # Í∏∞Î≥∏ Í±∞Îûò ÏÑ§Ï†ï
        self.TRADE_MODE: str = os.getenv('TRADE_MODE', 'TEST')
        self.LEVERAGE: int = int(os.getenv('LEVERAGE', '20'))
        self.STOP_LOSS: float = float(os.getenv('STOP_LOSS', '0.02'))
        self.TAKE_PROFIT: float = float(os.getenv('TAKE_PROFIT', '0.02'))
        
        # Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨ ÏÑ§Ï†ï
        self.MAX_DAILY_LOSS: float = float(os.getenv('MAX_DAILY_LOSS', '0.02'))
        self.MAX_POSITION_SIZE: float = float(os.getenv('MAX_POSITION_SIZE', '0.05'))
        self.MAX_POSITIONS: int = int(os.getenv('MAX_POSITIONS', '3'))
        self.MIN_CONFIDENCE: float = float(os.getenv('MIN_CONFIDENCE', '0.75'))
        
        # Phoenix 95 ÏÑ§Ï†ï
        self.PHOENIX_95_CONFIG: Dict[str, Any] = {
            "threshold": float(os.getenv('PHOENIX_THRESHOLD', '0.75')),
            "multiplier": float(os.getenv('PHOENIX_MULTIPLIER', '1.3')),
            "weight": float(os.getenv('PHOENIX_WEIGHT', '0.95')),
            "ai_score_multiplier": 0.35,
            "confidence_adjustment": 0.15,
            "analysis_timeout": 30
        }
        
        # ÌÖîÎ†àÍ∑∏Îû® ÏÑ§Ï†ï
        self.TELEGRAM_CONFIG: Dict[str, Any] = {
            "token": os.getenv("TELEGRAM_BOT_TOKEN", ""),
            "chat_id": os.getenv("TELEGRAM_CHAT_ID", ""),
            "enabled": os.getenv("TELEGRAM_ENABLED", "false").lower() == "true",
            "parse_mode": "HTML",
            "timeout": int(os.getenv("TELEGRAM_TIMEOUT", "30"))
        }
        
        # Í±∞ÎûòÏÜå API ÏÑ§Ï†ï
        if self.TRADE_MODE == 'LIVE':
            self.BINANCE_API_KEY = os.getenv('BINANCE_API_KEY')
            self.BINANCE_SECRET = os.getenv('BINANCE_SECRET')
            if not self.BINANCE_API_KEY or not self.BINANCE_SECRET:
                secure_logger.warning("LIVE Î™®ÎìúÏù¥ÏßÄÎßå Binance API ÌÇ§Í∞Ä ÏÑ§Ï†ïÎêòÏßÄ ÏïäÏùå")
                self.TRADE_MODE = 'TEST'
        else:
            self.BINANCE_API_KEY = 'TEST_MODE'
            self.BINANCE_SECRET = 'TEST_MODE'
        
        # Í±∞Îûò Í∞ÄÎä• Ïã¨Î≥º
        self.ALLOWED_SYMBOLS: List[str] = [
            "BTCUSDT", "ETHUSDT", "BNBUSDT", "ADAUSDT", "DOGEUSDT",
            "SOLUSDT", "XRPUSDT", "MATICUSDT", "DOTUSDT", "AVAXUSDT"
        ]
        
        # ÏÑ±Îä• Î™©Ìëú
        self.PERFORMANCE_TARGETS: Dict[str, Any] = {
            "max_response_time_ms": 100.0,
            "max_memory_mb": 200.0,
            "target_success_rate": 0.95,
            "health_check_interval": 30
        }
        
        secure_logger.info(f"üîß Phoenix 95 ÏÑ§Ï†ï Î°úÎìú ÏôÑÎ£å - Î™®Îìú: {self.EXECUTION_MODE}")

# Ï†ÑÏó≠ ÏÑ§Ï†ï
CONFIG = SafeConfig()

# =============================================================================
# üõ°Ô∏è Input Validation (ÏûÖÎ†• Í≤ÄÏ¶ù)
# =============================================================================

class InputValidator:
    """ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù Î∞è Î≥¥Ïïà"""
    
    @staticmethod
    def sanitize_symbol(symbol: str) -> str:
        """Ïã¨Î≥º ÏûÖÎ†• Ï†ïÎ¶¨"""
        if not isinstance(symbol, str):
            raise ValueError("Ïã¨Î≥ºÏùÄ Î¨∏ÏûêÏó¥Ïù¥Ïñ¥Ïïº Ìï©ÎãàÎã§")
        
        clean_symbol = re.sub(r'[^A-Za-z0-9]', '', symbol).upper()
        
        if not clean_symbol or len(clean_symbol) > 20:
            raise ValueError("Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ïã¨Î≥ºÏûÖÎãàÎã§")
        
        return clean_symbol
    
    @staticmethod
    def validate_numeric(value: Any, min_val: float, max_val: float, name: str) -> float:
        """Ïà´Ïûê Î≤îÏúÑ Í≤ÄÏ¶ù"""
        try:
            num_value = float(value)
            if not min_val <= num_value <= max_val:
                raise ValueError(f"{name}Ïù¥ Î≤îÏúÑÎ•º Î≤óÏñ¥ÎÇ®: {num_value}")
            return num_value
        except (TypeError, ValueError) as e:
            raise ValueError(f"{name} Î≥ÄÌôò Ïã§Ìå®: {value}") from e

# =============================================================================
# üìä Safe Cache System (ÏïàÏ†ÑÌïú Ï∫êÏãú ÏãúÏä§ÌÖú)
# =============================================================================

class SafeCache:
    """Ïä§Î†àÎìú ÏïàÏ†ÑÌïú Ï∫êÏãú (Î©îÎ™®Î¶¨ ÎàÑÏàò Î∞©ÏßÄ)"""
    
    def __init__(self, max_size: int = 1000, ttl: int = 300):
        self.cache = {}
        self.access_times = {}
        self.max_size = max_size
        self.ttl = ttl
        self.lock = threading.RLock()
        self.stats = {'hits': 0, 'misses': 0, 'cleanups': 0}
    
    def get(self, key: str) -> Optional[Any]:
        """Ï∫êÏãúÏóêÏÑú Í∞í Ï°∞Ìöå"""
        with self.lock:
            if key not in self.cache:
                self.stats['misses'] += 1
                return None
            
            # TTL ÌôïÏù∏
            if time.time() - self.access_times[key] > self.ttl:
                del self.cache[key]
                del self.access_times[key]
                self.stats['misses'] += 1
                return None
            
            self.stats['hits'] += 1
            return self.cache[key]
    
    def set(self, key: str, value: Any):
        """Ï∫êÏãúÏóê Í∞í Ï†ÄÏû•"""
        with self.lock:
            # Ï∫êÏãú ÌÅ¨Í∏∞ Í¥ÄÎ¶¨
            if len(self.cache) >= self.max_size:
                self._cleanup_old_entries()
            
            self.cache[key] = value
            self.access_times[key] = time.time()
    
    def _cleanup_old_entries(self):
        """Ïò§ÎûòÎêú Ìï≠Î™© Ï†ïÎ¶¨"""
        current_time = time.time()
        to_remove = []
        
        # TTL ÎßåÎ£åÎêú Ìï≠Î™© Ï∞æÍ∏∞
        for key, access_time in self.access_times.items():
            if current_time - access_time > self.ttl:
                to_remove.append(key)
        
        # ÎßåÎ£åÎêú Ìï≠Î™© Ï†úÍ±∞
        for key in to_remove:
            self.cache.pop(key, None)
            self.access_times.pop(key, None)
            self.stats['cleanups'] += 1
        
        # Ïó¨Ï†ÑÌûà ÌÅ¨Í∏∞Í∞Ä ÌÅ¨Î©¥ Í∞ÄÏû• Ïò§ÎûòÎêú Ìï≠Î™© Ï†úÍ±∞
        if len(self.cache) >= self.max_size:
            oldest_key = min(self.access_times, key=self.access_times.get)
            self.cache.pop(oldest_key, None)
            self.access_times.pop(oldest_key, None)
            self.stats['cleanups'] += 1
    
    def get_stats(self) -> Dict:
        """Ï∫êÏãú ÌÜµÍ≥Ñ"""
        with self.lock:
            total_requests = self.stats['hits'] + self.stats['misses']
            hit_rate = self.stats['hits'] / total_requests if total_requests > 0 else 0
            
            return {
                'size': len(self.cache),
                'max_size': self.max_size,
                'hit_rate': round(hit_rate, 3),
                'total_hits': self.stats['hits'],
                'total_misses': self.stats['misses'],
                'cleanups': self.stats['cleanups']
            }

# =============================================================================
# üìä Audit Logger (Í∞êÏÇ¨ Î°úÍ±∞)
# =============================================================================

class AuditLogger:
    """Î≥¥Ïïà Í∞êÏÇ¨ Î°úÍ∑∏ ÏãúÏä§ÌÖú"""
    
    def __init__(self, max_entries: int = 10000):
        self.audit_log = []
        self.max_entries = max_entries
        self.lock = threading.RLock()
    
    def log_event(self, event_type: str, user_id: str, details: Dict, risk_level: str = 'LOW'):
        """Í∞êÏÇ¨ Ïù¥Î≤§Ìä∏ Î°úÍ∑∏"""
        with self.lock:
            audit_entry = {
                'timestamp': datetime.now().isoformat(),
                'event_type': event_type,
                'user_id': user_id,
                'details': details,
                'risk_level': risk_level,
                'thread_id': threading.get_ident(),
                'session_id': self._generate_session_id()
            }
            
            # Î°úÍ∑∏ ÌÅ¨Í∏∞ Í¥ÄÎ¶¨
            if len(self.audit_log) >= self.max_entries:
                self.audit_log = self.audit_log[-int(self.max_entries * 0.8):]
            
            self.audit_log.append(audit_entry)
            
            # Í≥†ÏúÑÌóò Ïù¥Î≤§Ìä∏Îäî Ï¶âÏãú Î°úÍπÖ
            if risk_level in ['HIGH', 'CRITICAL']:
                secure_logger.warning(f"Í∞êÏÇ¨ Ïù¥Î≤§Ìä∏ [{risk_level}]: {event_type} - {details}")
    
    def _generate_session_id(self) -> str:
        """ÏÑ∏ÏÖò ID ÏÉùÏÑ±"""
        return hashlib.md5(f"{time.time()}{threading.get_ident()}".encode()).hexdigest()[:8]
    
    def get_recent_events(self, count: int = 100, event_type: Optional[str] = None) -> List[Dict]:
        """ÏµúÍ∑º Ïù¥Î≤§Ìä∏ Ï°∞Ìöå"""
        with self.lock:
            events = self.audit_log[-count:] if not event_type else [
                event for event in self.audit_log[-count*2:] 
                if event['event_type'] == event_type
            ][-count:]
            
            return events
    
    def get_risk_summary(self) -> Dict:
        """Î¶¨Ïä§ÌÅ¨ ÏöîÏïΩ"""
        with self.lock:
            if not self.audit_log:
                return {'total': 0, 'by_risk': {}}
            
            risk_counts = {}
            for event in self.audit_log[-1000:]:  # ÏµúÍ∑º 1000Í∞ú
                risk_level = event['risk_level']
                risk_counts[risk_level] = risk_counts.get(risk_level, 0) + 1
            
            return {
                'total': len(self.audit_log),
                'recent_count': min(1000, len(self.audit_log)),
                'by_risk': risk_counts
            }

# Ï†ÑÏó≠ Í∞êÏÇ¨ Î°úÍ±∞
audit_logger = AuditLogger()

# =============================================================================
# üåê Network Client (ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏)
# =============================================================================

class SecureNetworkClient:
    """Ïû¨ÏãúÎèÑ Î°úÏßÅ Î∞è ÌÉÄÏûÑÏïÑÏõÉÏù¥ Í∞ïÌôîÎêú ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏"""
    
    def __init__(self):
        self.enabled = AIOHTTP_AVAILABLE
        if self.enabled:
            self.timeout = aiohttp.ClientTimeout(
                total=30,      # Ï†ÑÏ≤¥ 30Ï¥à
                connect=5,     # Ïó∞Í≤∞ 5Ï¥à
                sock_read=10   # ÏùΩÍ∏∞ 10Ï¥à
            )
    
    async def safe_post(self, url: str, data: Optional[Dict] = None, json_data: Optional[Dict] = None) -> Dict:
        """ÏïàÏ†ÑÌïú POST ÏöîÏ≤≠ (Ïû¨ÏãúÎèÑ + ÌÉÄÏûÑÏïÑÏõÉ)"""
        if not self.enabled:
            secure_logger.warning("aiohttp ÎØ∏ÏÑ§ÏπòÎ°ú ÎÑ§Ìä∏ÏõåÌÅ¨ Í∏∞Îä• Ï†úÌïú")
            return {'error': 'aiohttp not available'}
        
        max_retries = 3
        retry_count = 0
        
        while retry_count < max_retries:
            try:
                async with aiohttp.ClientSession(timeout=self.timeout) as session:
                    kwargs = {}
                    if data:
                        kwargs['data'] = data
                    if json_data:
                        kwargs['json'] = json_data
                    
                    async with session.post(url, **kwargs) as response:
                        if response.status == 200:
                            return await response.json()
                        else:
                            error_text = await response.text()
                            secure_logger.error(f"HTTP Ïò§Î•ò {response.status}: {url}")
                            if retry_count == max_retries - 1:
                                return {'error': f'HTTP {response.status}: {error_text}'}
                            
            except asyncio.TimeoutError:
                secure_logger.error(f"ÌÉÄÏûÑÏïÑÏõÉ: {url} (ÏãúÎèÑ {retry_count + 1}/{max_retries})")
                if retry_count == max_retries - 1:
                    return {'error': 'Request timeout'}
            except Exception as e:
                secure_logger.error(f"ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•ò: {url} - {e} (ÏãúÎèÑ {retry_count + 1}/{max_retries})")
                if retry_count == max_retries - 1:
                    return {'error': str(e)}
            
            retry_count += 1
            if retry_count < max_retries:
                await asyncio.sleep(min(2 ** retry_count, 10))  # ÏßÄÏàò Î∞±Ïò§ÌîÑ
        
        return {'error': 'Max retries exceeded'}
    
    async def safe_get(self, url: str) -> Dict:
        """ÏïàÏ†ÑÌïú GET ÏöîÏ≤≠"""
        if not self.enabled:
            return {'error': 'aiohttp not available'}
        
        max_retries = 3
        retry_count = 0
        
        while retry_count < max_retries:
            try:
                async with aiohttp.ClientSession(timeout=self.timeout) as session:
                    async with session.get(url) as response:
                        if response.status == 200:
                            return await response.json()
                        else:
                            if retry_count == max_retries - 1:
                                return {'error': f'HTTP {response.status}'}
                            
            except Exception as e:
                if retry_count == max_retries - 1:
                    return {'error': str(e)}
            
            retry_count += 1
            if retry_count < max_retries:
                await asyncio.sleep(min(2 ** retry_count, 5))
        
        return {'error': 'Max retries exceeded'}

# Ï†ÑÏó≠ ÎÑ§Ìä∏ÏõåÌÅ¨ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏
network_client = SecureNetworkClient()

# =============================================================================
# üéØ Safe Data Models (ÏïàÏ†ÑÌïú Îç∞Ïù¥ÌÑ∞ Î™®Îç∏)
# =============================================================================

if FASTAPI_AVAILABLE:
    class SignalRequest(BaseModel):
        """Ïã†Ìò∏ ÏöîÏ≤≠ Î™®Îç∏"""
        symbol: str
        action: str
        price: float
        confidence: Optional[float] = 0.8
        strategy: Optional[str] = "phoenix95"
        timeframe: Optional[str] = "1h"
        rsi: Optional[float] = None
        macd: Optional[float] = None
        volume: Optional[float] = None
        account_balance: Optional[float] = 10000.0
        
        @field_validator('symbol')
        @classmethod
        def validate_symbol(cls, v):
            if not v or not isinstance(v, str):
                raise ValueError('symbol must be a non-empty string')
            clean_symbol = re.sub(r'[^A-Za-z0-9]', '', v.upper())
            if clean_symbol not in CONFIG.ALLOWED_SYMBOLS:
                raise ValueError(f'symbol must be one of: {CONFIG.ALLOWED_SYMBOLS}')
            return clean_symbol
        
        @field_validator('action')
        @classmethod
        def validate_action(cls, v):
            if v.lower() not in ['buy', 'sell', 'long', 'short']:
                raise ValueError('action must be buy/sell/long/short')
            return v.lower()
        
        @field_validator('price')
        @classmethod
        def validate_price(cls, v):
            if v <= 0:
                raise ValueError('price must be positive')
            return v
else:
    class SignalRequest:
        """Í∏∞Î≥∏ Ïã†Ìò∏ ÏöîÏ≤≠ ÌÅ¥ÎûòÏä§"""
        def __init__(self, symbol, action, price, confidence=0.8, **kwargs):
            self.symbol = str(symbol).upper().strip() if symbol else ""
            self.action = str(action).lower().strip() if action else ""
            self.price = SafeMath.safe_float(price, 0.0)
            self.confidence = SafeMath.safe_float(confidence, 0.8)
            self.strategy = kwargs.get('strategy', 'phoenix95')
            self.timeframe = kwargs.get('timeframe', '1h')
            self.rsi = SafeMath.safe_float(kwargs.get('rsi')) if kwargs.get('rsi') else None
            self.macd = SafeMath.safe_float(kwargs.get('macd')) if kwargs.get('macd') else None
            self.volume = SafeMath.safe_float(kwargs.get('volume')) if kwargs.get('volume') else None
            self.account_balance = SafeMath.safe_float(kwargs.get('account_balance', 10000.0))

@dataclass
class TradingSignal:
    """Í±∞Îûò Ïã†Ìò∏ ÎèÑÎ©îÏù∏ Î™®Îç∏"""
    symbol: str
    action: str
    price: float
    confidence: float
    strategy: str = "phoenix95"
    timeframe: str = "1h"
    rsi: Optional[float] = None
    macd: Optional[float] = None
    volume: Optional[float] = None
    account_balance: float = 10000.0
    timestamp: float = field(default_factory=time.time)
    signal_id: str = field(default_factory=lambda: f"SIG_{int(time.time() * 1000)}")

@dataclass
class AnalysisResult:
    """Î∂ÑÏÑù Í≤∞Í≥º"""
    signal_id: str
    original_confidence: float
    phoenix_95_score: float
    final_confidence: float
    quality_score: float
    execution_timing: str
    risk_level: str
    recommended_position_size: float
    analysis_time_ms: float
    technical_indicators: Dict[str, float] = field(default_factory=dict)
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class PositionInfo:
    """Ìè¨ÏßÄÏÖò Ï†ïÎ≥¥"""
    kelly_fraction: float
    position_size: float
    margin_required: float
    leveraged_size: float
    leverage: int
    stop_loss_price: float
    take_profit_price: float
    liquidation_price: float
    margin_mode: str
    risk_score: float = 0.0

@dataclass
class TradeResult:
    """Í±∞Îûò Í≤∞Í≥º"""
    trade_id: str
    signal_id: str
    symbol: str
    action: str
    phoenix_95_score: float
    position_info: PositionInfo
    execution_status: str
    execution_reason: str
    timestamp: float
    processing_time_ms: float
    hedge_fund_grade: bool = False

# =============================================================================
# üß† BRAIN - Signal Intelligence Engine (AI Î∂ÑÏÑù ÏóîÏßÑ)
# =============================================================================

class SignalBrain:
    """Phoenix 95 AI Ïã†Ìò∏ Î∂ÑÏÑù ÏóîÏßÑ"""
    
    def __init__(self, config: SafeConfig):
        self.config = config
        self.phoenix_config = config.PHOENIX_95_CONFIG
        self.validator = InputValidator()
        self.analysis_cache = SafeCache(max_size=1000, ttl=300)  # 5Î∂Ñ TTL
        
        # V5 Í∞ÄÏ§ëÏπò Îß§Ìïë (Í∞úÏÑ†Îê®)
        self.timeframe_weights = {
            "1m": 0.8, "5m": 0.9, "15m": 1.0,
            "1h": 1.1, "4h": 1.2, "1d": 1.3
        }
        
        self.strategy_weights = {
            "momentum": 1.1, "mean_reversion": 1.05, "breakout": 1.15,
            "scalping": 0.95, "swing": 1.1, "phoenix95": 1.3, "unknown": 1.0
        }
        
        secure_logger.info("üß† BRAIN: Phoenix 95 Signal Intelligence Engine Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    def analyze_signal(self, signal: TradingSignal) -> AnalysisResult:
        """Phoenix 95 AI Î∂ÑÏÑù (Í∞úÏÑ†Îêú Î≤ÑÏ†Ñ)"""
        try:
            start_time = time.time()
            
            # Ï∫êÏãú ÌÇ§ ÏÉùÏÑ± Î∞è ÌôïÏù∏
            cache_key = self._generate_cache_key(signal)
            cached_result = self.analysis_cache.get(cache_key)
            
            if cached_result:
                cached_result.metadata['from_cache'] = True
                cached_result.metadata['cache_stats'] = self.analysis_cache.get_stats()
                return cached_result
            
            # 1. Í∏∞Î≥∏ Phoenix 95 Ï†êÏàò Í≥ÑÏÇ∞
            original_confidence = SafeMath.clamp(signal.confidence, 0.0, 1.0)
            phoenix_multiplier = SafeMath.safe_float(self.phoenix_config.get("multiplier", 1.3))
            base_phoenix_score = SafeMath.clamp(
                SafeMath.safe_multiply(original_confidence, phoenix_multiplier),
                0.0, 1.0
            )
            
            # 2. Í≥†Í∏â Í∏∞Ïà†Ï†Å ÏßÄÌëú Î∂ÑÏÑù
            technical_score = self._analyze_technical_advanced(signal)
            volume_score = self._analyze_volume_advanced(signal)
            momentum_score = self._analyze_momentum_advanced(signal)
            
            # 3. Phoenix 95 Ï¢ÖÌï© Ï†êÏàò Í≥ÑÏÇ∞ (Í∞ÄÏ§ë ÌèâÍ∑†)
            component_scores = {
                'technical': technical_score,
                'volume': volume_score,
                'momentum': momentum_score,
                'base_phoenix': base_phoenix_score
            }
            
            # Í∞ÄÏ§ëÏπò Ï†ÅÏö©
            technical_weight = 0.25
            volume_weight = 0.25
            momentum_weight = 0.25
            phoenix_weight = 0.25
            
            phoenix_95_score = (
                technical_score * technical_weight +
                volume_score * volume_weight +
                momentum_score * momentum_weight +
                base_phoenix_score * phoenix_weight
            )
            
            # 4. ÏãúÍ∞ÑÎåÄ Î∞è Ï†ÑÎûµ Í∞ÄÏ§ëÏπò Ï†ÅÏö©
            timeframe_weight = self.timeframe_weights.get(signal.timeframe, 1.0)
            strategy_weight = self.strategy_weights.get(signal.strategy, 1.0)
            
            phoenix_95_score = SafeMath.clamp(
                SafeMath.safe_multiply(
                    phoenix_95_score,
                    SafeMath.safe_multiply(timeframe_weight, strategy_weight)
                ),
                0.0, 1.0
            )
            
            # 5. ÏµúÏ¢Ö Ïã†Î¢∞ÎèÑ Ï°∞Ï†ï
            confidence_adjustment = SafeMath.safe_float(self.phoenix_config.get("confidence_adjustment", 0.15))
            final_confidence = SafeMath.clamp(phoenix_95_score + confidence_adjustment, 0.0, 1.0)
            
            # 6. ÌíàÏßà Ï†êÏàò Í≥ÑÏÇ∞
            quality_factors = [
                1.0 if signal.rsi is not None else 0.8,
                1.0 if signal.macd is not None else 0.8,
                1.0 if signal.volume is not None else 0.9,
                1.0 if signal.strategy != "unknown" else 0.7,
                1.0 if signal.account_balance > 0 else 0.5
            ]
            quality_score = sum(quality_factors) / len(quality_factors) if quality_factors else 0.0
            
            # 7. Ïã§Ìñâ ÌÉÄÏù¥Î∞ç Î∞è Î¶¨Ïä§ÌÅ¨ Î†àÎ≤® Í≤∞Ï†ï
            threshold = SafeMath.safe_float(self.phoenix_config.get("threshold", 0.75))
            execution_timing, risk_level = self._determine_execution_strategy(final_confidence, threshold, quality_score)
            
            # 8. Kelly Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
            recommended_position_size = self._calculate_kelly_position_size(final_confidence, signal.account_balance)
            
            analysis_time = (time.time() - start_time) * 1000
            
            # Í≤∞Í≥º ÏÉùÏÑ±
            result = AnalysisResult(
                signal_id=signal.signal_id,
                original_confidence=original_confidence,
                phoenix_95_score=phoenix_95_score,
                final_confidence=final_confidence,
                quality_score=quality_score,
                execution_timing=execution_timing,
                risk_level=risk_level,
                recommended_position_size=recommended_position_size,
                analysis_time_ms=round(analysis_time, 2),
                technical_indicators=component_scores,
                metadata={
                    'engine': 'Phoenix 95 V5.0 Complete',
                    'timeframe_weight': timeframe_weight,
                    'strategy_weight': strategy_weight,
                    'from_cache': False,
                    'cache_stats': self.analysis_cache.get_stats()
                }
            )
            
            # Ï∫êÏãúÏóê Ï†ÄÏû•
            self.analysis_cache.set(cache_key, result)
            
            return result
            
        except Exception as e:
            secure_logger.error(f"üß† BRAIN Î∂ÑÏÑù Ïò§Î•ò: {e}")
            # ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞í Î∞òÌôò
            return AnalysisResult(
                signal_id=signal.signal_id,
                original_confidence=0.0,
                phoenix_95_score=0.0,
                final_confidence=0.0,
                quality_score=0.0,
                execution_timing="HOLD",
                risk_level="HIGH",
                recommended_position_size=0.01,
                analysis_time_ms=0.0,
                technical_indicators={},
                metadata={'error': str(e)}
            )
    
    def _analyze_technical_advanced(self, signal: TradingSignal) -> float:
        """Í≥†Í∏â Í∏∞Ïà†Ï†Å Î∂ÑÏÑù"""
        try:
            scores = []
            
            # RSI Î∂ÑÏÑù (Í∞úÏÑ†Îê®)
            if signal.rsi is not None:
                rsi_value = SafeMath.clamp(signal.rsi, 0.0, 100.0)
                if signal.action in ['buy', 'long']:
                    if rsi_value < 30:
                        rsi_score = 0.9  # Í≥ºÎß§ÎèÑ ÏÉÅÌÉúÏóêÏÑú Îß§Ïàò - Îß§Ïö∞ Ï¢ãÏùå
                    elif rsi_value < 40:
                        rsi_score = 0.7
                    elif rsi_value < 50:
                        rsi_score = 0.6
                    else:
                        rsi_score = 0.3  # Í≥ºÎß§Ïàò ÏÉÅÌÉúÏóêÏÑú Îß§Ïàò - Ï¢ãÏßÄ ÏïäÏùå
                else:  # sell, short
                    if rsi_value > 70:
                        rsi_score = 0.9  # Í≥ºÎß§Ïàò ÏÉÅÌÉúÏóêÏÑú Îß§ÎèÑ - Îß§Ïö∞ Ï¢ãÏùå
                    elif rsi_value > 60:
                        rsi_score = 0.7
                    elif rsi_value > 50:
                        rsi_score = 0.6
                    else:
                        rsi_score = 0.3  # Í≥ºÎß§ÎèÑ ÏÉÅÌÉúÏóêÏÑú Îß§ÎèÑ - Ï¢ãÏßÄ ÏïäÏùå
                
                scores.append(rsi_score)
            
            # MACD Î∂ÑÏÑù (Í∞úÏÑ†Îê®)
            if signal.macd is not None:
                macd_value = signal.macd
                if signal.action in ['buy', 'long']:
                    macd_score = 0.5 + SafeMath.clamp(macd_value / 100, -0.4, 0.4)
                else:
                    macd_score = 0.5 - SafeMath.clamp(macd_value / 100, -0.4, 0.4)
                
                scores.append(macd_score)
            
            # Í∏∞Î≥∏ Ï†êÏàò (ÏßÄÌëúÍ∞Ä ÏóÜÎäî Í≤ΩÏö∞)
            if not scores:
                return 0.5
            
            return sum(scores) / len(scores)
            
        except Exception:
            return 0.5
    
    def _analyze_volume_advanced(self, signal: TradingSignal) -> float:
        """Í≥†Í∏â Í±∞ÎûòÎüâ Î∂ÑÏÑù"""
        try:
            if signal.volume is None:
                return 0.5
            
            current_volume = SafeMath.safe_float(signal.volume)
            
            # Í±∞ÎûòÎüâ Í∏∞Î∞ò Ïã†Î¢∞ÎèÑ Í≥ÑÏÇ∞
            if current_volume > 5000000:  # Îß§Ïö∞ ÎÜíÏùÄ Í±∞ÎûòÎüâ
                return 0.9
            elif current_volume > 2000000:  # ÎÜíÏùÄ Í±∞ÎûòÎüâ
                return 0.8
            elif current_volume > 1000000:  # Î≥¥ÌÜµ Í±∞ÎûòÎüâ
                return 0.6
            elif current_volume > 500000:   # ÎÇÆÏùÄ Í±∞ÎûòÎüâ
                return 0.4
            else:  # Îß§Ïö∞ ÎÇÆÏùÄ Í±∞ÎûòÎüâ
                return 0.2
                
        except Exception:
            return 0.5
    
    def _analyze_momentum_advanced(self, signal: TradingSignal) -> float:
        """Í≥†Í∏â Î™®Î©òÌÖÄ Î∂ÑÏÑù"""
        try:
            # Í∞ÄÍ≤© Í∏∞Î∞ò Î™®Î©òÌÖÄ Ï∂îÏ†ï
            price = SafeMath.safe_float(signal.price)
            confidence = SafeMath.safe_float(signal.confidence)
            
            # Ïã†Î¢∞ÎèÑ Í∏∞Î∞ò Î™®Î©òÌÖÄ Ï†êÏàò
            momentum_score = confidence
            
            # Ï∂îÍ∞Ä Ï°∞Ï†ï (Í∞ÄÍ≤© ÏàòÏ§ÄÏóê Îî∞Î•∏)
            if price > 50000:  # BTC Îì± Í≥†Í∞Ä ÏûêÏÇ∞
                momentum_score *= 1.1
            elif price > 1000:  # ETH Îì± Ï§ëÍ∞Ä ÏûêÏÇ∞
                momentum_score *= 1.05
            elif price < 1:     # Ï†ÄÍ∞Ä ÏïåÌä∏ÏΩîÏù∏
                momentum_score *= 0.9
            
            return SafeMath.clamp(momentum_score, 0.0, 1.0)
            
        except Exception:
            return 0.5
    
    def _determine_execution_strategy(self, confidence: float, threshold: float, quality: float) -> Tuple[str, str]:
        """Ïã§Ìñâ Ï†ÑÎûµ Î∞è Î¶¨Ïä§ÌÅ¨ Î†àÎ≤® Í≤∞Ï†ï"""
        try:
            # Ïã§Ìñâ ÌÉÄÏù¥Î∞ç Í≤∞Ï†ï
            if confidence >= threshold and quality >= 0.8:
                execution_timing = "IMMEDIATE"
            elif confidence >= threshold * 0.9 and quality >= 0.7:
                execution_timing = "CAREFUL"
            elif confidence >= threshold * 0.8:
                execution_timing = "MONITOR"
            else:
                execution_timing = "HOLD"
            
            # Î¶¨Ïä§ÌÅ¨ Î†àÎ≤® Í≤∞Ï†ï
            if confidence >= 0.85 and quality >= 0.8:
                risk_level = "LOW"
            elif confidence >= 0.75 and quality >= 0.7:
                risk_level = "MEDIUM"
            elif confidence >= 0.65:
                risk_level = "HIGH"
            else:
                risk_level = "CRITICAL"
            
            return execution_timing, risk_level
            
        except Exception:
            return "HOLD", "HIGH"
    
    def _calculate_kelly_position_size(self, confidence: float, account_balance: float) -> float:
        """Kelly Criterion Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ Í≥ÑÏÇ∞ (Í∞úÏÑ†Îê®)"""
        try:
            if account_balance <= 0:
                return 0.01
            
            # Kelly Criterion Í≥ÑÏÇ∞
            win_rate = SafeMath.clamp(confidence * 0.85, 0.01, 0.99)
            avg_win = 1.03  # 3% ÏàòÏùµ Í∞ÄÏ†ï
            avg_loss = 0.97  # 3% ÏÜêÏã§ Í∞ÄÏ†ï
            
            # Kelly fraction = (bp - q) / b
            # b = avg_win/avg_loss, p = win_rate, q = 1-win_rate
            b = SafeMath.safe_divide(avg_win, avg_loss, 1.0)
            kelly_fraction = SafeMath.safe_divide(
                (b * win_rate - (1 - win_rate)), 
                b, 
                0.01
            )
            
            # Kelly fraction Ï†úÌïú (1%-20%)
            kelly_fraction = SafeMath.clamp(kelly_fraction, 0.01, 0.20)
            
            # ÏµúÎåÄ Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ Ï†úÌïú
            max_position = SafeMath.safe_float(CONFIG.MAX_POSITION_SIZE)
            position_size = min(kelly_fraction * account_balance, max_position * account_balance)
            
            return max(account_balance * 0.001, position_size)  # ÏµúÏÜå 0.1%
            
        except Exception as e:
            secure_logger.error(f"Kelly Í≥ÑÏÇ∞ Ïò§Î•ò: {e}")
            return account_balance * 0.01  # 1% ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞í
    
    def _generate_cache_key(self, signal: TradingSignal) -> str:
        """Ï∫êÏãú ÌÇ§ ÏÉùÏÑ±"""
        try:
            key_data = {
                'symbol': signal.symbol,
                'action': signal.action,
                'price': round(signal.price, 2),
                'confidence': round(signal.confidence, 3),
                'rsi': round(signal.rsi, 1) if signal.rsi else None,
                'macd': round(signal.macd, 4) if signal.macd else None,
                'volume': signal.volume,
                'timeframe': signal.timeframe,
                'strategy': signal.strategy
            }
            
            # Ìï¥Ïãú Ï∂©Îèå Î∞©ÏßÄÎ•º ÏúÑÌï¥ SHA-256 ÏÇ¨Ïö©
            return hashlib.sha256(json.dumps(key_data, sort_keys=True).encode()).hexdigest()[:16]
            
        except Exception:
            return f"fallback_{int(time.time())}"

# =============================================================================
# ‚öñÔ∏è RISK - Position & Risk Manager (Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨Ïûê)
# =============================================================================

class RiskManager:
    """Ìó§ÏßÄÌéÄÎìúÍ∏â Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨ ÏãúÏä§ÌÖú"""
    
    def __init__(self, config: SafeConfig):
        self.config = config
        self.daily_pnl = 0.0
        self.active_positions = 0
        self.total_exposure = 0.0
        self.last_reset = datetime.now().date()
        self.lock = threading.RLock()
        
        # Í±∞Îûò Í∏∞Î°ù (Kelly Criterion Í≥ÑÏÇ∞Ïö©)
        self.trade_history = []
        
        # Î¶¨Ïä§ÌÅ¨ Î©îÌä∏Î¶≠
        self.risk_metrics = {
            'daily_trades': 0,
            'success_rate': 0.0,
            'max_drawdown': 0.0,
            'win_streak': 0,
            'loss_streak': 0,
            'largest_win': 0.0,
            'largest_loss': 0.0,
            'volatility_multiplier': 1.0
        }
        
        secure_logger.info("‚öñÔ∏è RISK: Position & Risk Manager Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    def check_trade_approval(self, signal_data: Dict, analysis: Dict) -> Dict:
        """Í±∞Îûò ÏäπÏù∏ Ïó¨Î∂Ä Í≤∞Ï†ï (Ìó§ÏßÄÌéÄÎìúÍ∏â)"""
        
        with self.lock:
            checks = []
            approved = True
            risk_level = 'LOW'
            
            try:
                # Í∞êÏÇ¨ Î°úÍ∑∏
                audit_logger.log_event(
                    'TRADE_APPROVAL_REQUEST',
                    'system',
                    {
                        'symbol': signal_data.get('symbol', 'UNKNOWN'),
                        'confidence': analysis.get('confidence', 0)
                    }
                )
                
                # ÏùºÏùº Î¶¨ÏÖã Ï≤¥ÌÅ¨
                self._check_daily_reset()
                
                # ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞ Í≤ÄÏ¶ù
                if not self._validate_inputs(signal_data, analysis):
                    audit_logger.log_event(
                        'TRADE_APPROVAL_DENIED',
                        'system',
                        {'reason': 'Invalid input data'},
                        'HIGH'
                    )
                    return self._create_error_response("ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞ Ïò§Î•ò")
                
                # 1. ÏùºÏùº ÏÜêÏã§ ÌïúÎèÑ Ï≤¥ÌÅ¨ (ÏµúÏö∞ÏÑ†)
                if abs(self.daily_pnl) >= CONFIG.MAX_DAILY_LOSS:
                    approved = False
                    risk_level = 'CRITICAL'
                    checks.append(f"ÏùºÏùº ÏÜêÏã§ ÌïúÎèÑ Ï¥àÍ≥º: {self.daily_pnl:.2%}")
                
                # 2. Ìè¨ÏßÄÏÖò Ïàò ÌïúÎèÑ Ï≤¥ÌÅ¨
                if self.active_positions >= CONFIG.MAX_POSITIONS:
                    approved = False
                    risk_level = 'HIGH'
                    checks.append(f"ÏµúÎåÄ Ìè¨ÏßÄÏÖò Ïàò ÎèÑÎã¨: {self.active_positions}/{CONFIG.MAX_POSITIONS}")
                
                # 3. Ïã†Î¢∞ÎèÑ Ï≤¥ÌÅ¨
                confidence = analysis.get('confidence', 0)
                if confidence < CONFIG.MIN_CONFIDENCE:
                    approved = False
                    risk_level = 'MEDIUM'
                    checks.append(f"Ïã†Î¢∞ÎèÑ Î∂ÄÏ°±: {confidence:.3f} < {CONFIG.MIN_CONFIDENCE}")
                
                # 4. Í≥†Í∏â Kelly Criterion Ìè¨ÏßÄÏÖò ÏÇ¨Ïù¥Ïßï
                account_balance = signal_data.get('account_balance', 10000)
                position_size = self._calculate_advanced_kelly_size(
                    account_balance, confidence
                ) if approved else 0
                
                # 5. Ï¥ù ÎÖ∏Ï∂ú ÌïúÎèÑ Ï≤¥ÌÅ¨
                if account_balance > 0:
                    projected_exposure = self.total_exposure + (position_size / account_balance)
                    max_exposure = 0.20 * self.risk_metrics['volatility_multiplier']
                    if projected_exposure > max_exposure:
                        approved = False
                        risk_level = 'HIGH'
                        checks.append(f"Ï¥ù ÎÖ∏Ï∂ú ÌïúÎèÑ Ï¥àÍ≥º: {projected_exposure:.2%} > {max_exposure:.2%}")
                else:
                    projected_exposure = 0
                
                # 6. Ïó∞ÏÜç ÏÜêÏã§ Ï≤¥ÌÅ¨
                if self.risk_metrics['loss_streak'] >= 3:
                    position_size *= 0.5  # Ïó∞ÏÜç ÏÜêÏã§Ïãú Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ 50% Í∞êÏÜå
                    checks.append(f"Ïó∞ÏÜç ÏÜêÏã§Î°ú Ïù∏Ìïú Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ Í∞êÏÜå: {self.risk_metrics['loss_streak']}Ìöå")
                
                # 7. Ïã¨Î≥ºÎ≥Ñ Ï∂îÍ∞Ä Ï≤¥ÌÅ¨
                symbol = signal_data.get('symbol', '')
                if symbol not in CONFIG.ALLOWED_SYMBOLS:
                    approved = False
                    risk_level = 'HIGH'
                    checks.append(f"ÌóàÏö©ÎêòÏßÄ ÏïäÎäî Ïã¨Î≥º: {symbol}")
                
                # Í∞êÏÇ¨ Î°úÍ∑∏
                audit_logger.log_event(
                    'TRADE_APPROVAL_RESULT',
                    'system',
                    {
                        'approved': approved,
                        'risk_level': risk_level,
                        'position_size': position_size,
                        'checks_count': len(checks)
                    },
                    'HIGH' if not approved else 'LOW'
                )
                
                return {
                    'approved': approved,
                    'position_size': round(position_size, 2),
                    'position_size_pct': round(position_size / account_balance, 4) if account_balance > 0 else 0,
                    'risk_level': risk_level,
                    'checks': checks,
                    'risk_metrics': {
                        'current_exposure': round(self.total_exposure, 4),
                        'projected_exposure': round(projected_exposure, 4),
                        'daily_pnl': round(self.daily_pnl, 4),
                        'active_positions': self.active_positions,
                        'volatility_multiplier': round(self.risk_metrics['volatility_multiplier'], 3),
                        'loss_streak': self.risk_metrics['loss_streak']
                    },
                    'kelly_sizing': {
                        'base_size': round(position_size * 0.8, 2),
                        'confidence_adjusted': round(position_size, 2),
                        'max_allowed': round(account_balance * CONFIG.MAX_POSITION_SIZE, 2) if account_balance > 0 else 0
                    }
                }
                
            except Exception as e:
                secure_logger.error(f"Î¶¨Ïä§ÌÅ¨ Ï≤¥ÌÅ¨ Ïò§Î•ò: {e}")
                audit_logger.log_event(
                    'TRADE_APPROVAL_ERROR',
                    'system',
                    {'error': str(e)},
                    'CRITICAL'
                )
                return self._create_error_response("Î¶¨Ïä§ÌÅ¨ Ï≤¥ÌÅ¨ ÏãúÏä§ÌÖú Ïò§Î•ò")
    
    def calculate_position(self, signal: TradingSignal, analysis: AnalysisResult) -> PositionInfo:
        """Ìè¨ÏßÄÏÖò Í≥ÑÏÇ∞ (Ìó§ÏßÄÌéÄÎìúÍ∏â)"""
        try:
            # Kelly Í∏∞Î∞ò Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞
            kelly_fraction = analysis.recommended_position_size / signal.account_balance if signal.account_balance > 0 else 0.01
            base_position = analysis.recommended_position_size
            
            # Î†àÎ≤ÑÎ¶¨ÏßÄ Ï†ÅÏö©
            leverage = CONFIG.LEVERAGE
            leveraged_size = SafeMath.safe_multiply(base_position, leverage)
            margin_required = base_position
            
            # ÏÜêÏ†à/ÏùµÏ†à Í∞ÄÍ≤© Í≥ÑÏÇ∞ (Í∞úÏÑ†Îê®)
            stop_loss_pct = CONFIG.STOP_LOSS
            take_profit_pct = CONFIG.TAKE_PROFIT
            
            # Ïã†Î¢∞ÎèÑÏóê Îî∞Î•∏ ÏÜêÏùµÎπÑ Ï°∞Ï†ï
            confidence_factor = SafeMath.clamp(analysis.final_confidence, 0.5, 1.0)
            adjusted_take_profit = take_profit_pct * (1 + confidence_factor * 0.5)  # Ïã†Î¢∞ÎèÑ ÎÜíÏúºÎ©¥ Îçî ÌÅ∞ ÏàòÏùµ Î™©Ìëú
            
            if signal.action in ['buy', 'long']:
                stop_loss_price = SafeMath.safe_multiply(signal.price, (1 - stop_loss_pct))
                take_profit_price = SafeMath.safe_multiply(signal.price, (1 + adjusted_take_profit))
            else:
                stop_loss_price = SafeMath.safe_multiply(signal.price, (1 + stop_loss_pct))
                take_profit_price = SafeMath.safe_multiply(signal.price, (1 - adjusted_take_profit))
            
            # Ï≤≠ÏÇ∞Í∞Ä Í≥ÑÏÇ∞ (Í∞úÏÑ†Îê®)
            liquidation_buffer = 0.1  # 10% Î≤ÑÌçº
            if signal.action in ['buy', 'long']:
                liquidation_price = SafeMath.safe_multiply(
                    signal.price,
                    (1 - SafeMath.safe_divide(1, leverage) + liquidation_buffer)
                )
            else:
                liquidation_price = SafeMath.safe_multiply(
                    signal.price,
                    (1 + SafeMath.safe_divide(1, leverage) - liquidation_buffer)
                )
            
            # Î¶¨Ïä§ÌÅ¨ Ï†êÏàò Í≥ÑÏÇ∞ (0-10)
            risk_score = self._calculate_risk_score(
                kelly_fraction, leveraged_size, analysis.final_confidence, analysis.quality_score
            )
            
            return PositionInfo(
                kelly_fraction=kelly_fraction,
                position_size=base_position,
                margin_required=margin_required,
                leveraged_size=leveraged_size,
                leverage=leverage,
                stop_loss_price=stop_loss_price,
                take_profit_price=take_profit_price,
                liquidation_price=liquidation_price,
                margin_mode="ISOLATED",
                risk_score=risk_score
            )
            
        except Exception as e:
            secure_logger.error(f"‚öñÔ∏è RISK Ìè¨ÏßÄÏÖò Í≥ÑÏÇ∞ Ïò§Î•ò: {e}")
            # ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞í Î∞òÌôò
            return PositionInfo(
                kelly_fraction=0.01,
                position_size=100.0,
                margin_required=100.0,
                leveraged_size=2000.0,
                leverage=CONFIG.LEVERAGE,
                stop_loss_price=signal.price * 0.98,
                take_profit_price=signal.price * 1.02,
                liquidation_price=signal.price * 0.95,
                margin_mode="ISOLATED",
                risk_score=5.0
            )
    
    def _calculate_advanced_kelly_size(self, balance: float, confidence: float) -> float:
        """Í≥†Í∏â Kelly Criterion Ìè¨ÏßÄÏÖò ÏÇ¨Ïù¥Ïßï"""
        try:
            # Í∏∞Î≥∏ Î¶¨Ïä§ÌÅ¨ (Í≥ÑÏ¢åÏùò ÏùºÏùº ÏÜêÏã§ ÌïúÎèÑ)
            base_risk_amount = balance * CONFIG.MAX_DAILY_LOSS
            
            # Ïã†Î¢∞ÎèÑ Í≤ÄÏ¶ù Î∞è Ï†ïÍ∑úÌôî
            confidence = SafeMath.clamp(confidence, 0.5, 1.0)
            
            # Í≥ºÍ±∞ Í±∞Îûò Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò ÏäπÎ•† Î∞è ÏàòÏùµÎ•† Í≥ÑÏÇ∞
            win_rate, avg_win, avg_loss = self._calculate_historical_metrics()
            
            # Kelly Criterion Í≥ÑÏÇ∞
            if avg_loss > 0 and win_rate > 0:
                kelly_fraction = SafeMath.safe_divide(
                    (win_rate * avg_win - (1 - win_rate) * avg_loss), 
                    avg_win, 
                    0.01
                )
            else:
                # Í∏∞Î≥∏Í∞í ÏÇ¨Ïö© (Ïã†Î¢∞ÎèÑ Í∏∞Î∞ò Ï∂îÏ†ï)
                estimated_win_rate = 0.6 + (confidence - 0.75) * 0.4
                estimated_win_rate = SafeMath.clamp(estimated_win_rate, 0.5, 0.95)
                kelly_fraction = SafeMath.safe_divide(
                    (estimated_win_rate * 1.5 - (1 - estimated_win_rate) * 1.0), 
                    1.5, 
                    0.01
                )
            
            # Kelly fraction Ï†úÌïú (1%-25%)
            kelly_fraction = SafeMath.clamp(kelly_fraction, 0.01, 0.25)
            
            # Ïã†Î¢∞ÎèÑ Ï°∞Ï†ï
            confidence_factor = 0.8 + (confidence - 0.75) * 1.6
            confidence_factor = SafeMath.clamp(confidence_factor, 0.5, 1.2)
            
            # Î≥ÄÎèôÏÑ± Ï°∞Ï†ï
            volatility_factor = self.risk_metrics['volatility_multiplier']
            volatility_factor = SafeMath.clamp(volatility_factor, 0.5, 1.5)
            
            # ÏµúÏ¢Ö Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ Í≥ÑÏÇ∞
            kelly_size = balance * kelly_fraction
            adjusted_size = kelly_size * confidence_factor * volatility_factor
            
            # ÏµúÎåÄ ÌïúÎèÑ Ï†ÅÏö©
            max_position = balance * CONFIG.MAX_POSITION_SIZE
            final_size = min(adjusted_size, max_position)
            
            # ÏµúÏÜå/ÏµúÎåÄ Ï†úÌïú
            final_size = SafeMath.clamp(final_size, balance * 0.001, balance * 0.1)
            
            return final_size
            
        except Exception as e:
            secure_logger.error(f"Kelly Ìè¨ÏßÄÏÖò ÏÇ¨Ïù¥Ïßï Ïò§Î•ò: {e}")
            return balance * 0.01  # 1% ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞í
    
    def _calculate_historical_metrics(self) -> Tuple[float, float, float]:
        """Í≥ºÍ±∞ Í±∞Îûò Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò Î©îÌä∏Î¶≠ Í≥ÑÏÇ∞"""
        if len(self.trade_history) < 10:
            return 0.6, 1.5, 1.0  # Í∏∞Î≥∏Í∞í
        
        recent_trades = self.trade_history[-50:]  # ÏµúÍ∑º 50Í∞ú Í±∞Îûò
        
        wins = [trade for trade in recent_trades if trade['pnl'] > 0]
        losses = [trade for trade in recent_trades if trade['pnl'] < 0]
        
        win_rate = len(wins) / len(recent_trades) if recent_trades else 0.6
        avg_win = sum(trade['pnl'] for trade in wins) / len(wins) if wins else 1.5
        avg_loss = abs(sum(trade['pnl'] for trade in losses) / len(losses)) if losses else 1.0
        
        return win_rate, avg_win, avg_loss
    
    def _calculate_risk_score(self, kelly_fraction: float, leveraged_size: float, 
                             confidence: float, quality: float) -> float:
        """Î¶¨Ïä§ÌÅ¨ Ï†êÏàò Í≥ÑÏÇ∞ (0-10)"""
        try:
            # Í∞Å ÏöîÏÜåÎ≥Ñ Î¶¨Ïä§ÌÅ¨ Ï†êÏàò
            kelly_risk = SafeMath.clamp(kelly_fraction * 20, 0.0, 3.0)
            leverage_risk = SafeMath.clamp(leveraged_size / 50000, 0.0, 3.0)
            confidence_risk = SafeMath.clamp(2 * (1 - confidence), 0.0, 2.0)
            quality_risk = SafeMath.clamp(2 * (1 - quality), 0.0, 2.0)
            
            total_risk = kelly_risk + leverage_risk + confidence_risk + quality_risk
            return SafeMath.clamp(total_risk, 0.0, 10.0)
            
        except Exception as e:
            secure_logger.error(f"Î¶¨Ïä§ÌÅ¨ Ï†êÏàò Í≥ÑÏÇ∞ Ïò§Î•ò: {e}")
            return 5.0
    
    def update_position_status(self, position_update: Dict):
        """Ìè¨ÏßÄÏÖò ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ (Í≥†Í∏â Ï∂îÏ†Å)"""
        with self.lock:
            try:
                action = position_update.get('action')
                
                if action == 'open':
                    self.active_positions += 1
                    self.total_exposure += position_update.get('size_pct', 0)
                    self.risk_metrics['daily_trades'] += 1
                    
                elif action == 'close':
                    self.active_positions = max(0, self.active_positions - 1)
                    self.total_exposure -= position_update.get('size_pct', 0)
                    self.total_exposure = max(0, self.total_exposure)
                    
                    # P&L ÏóÖÎç∞Ïù¥Ìä∏ Î∞è Í±∞Îûò Í∏∞Î°ù
                    pnl_pct = position_update.get('pnl_pct', 0)
                    self.daily_pnl += pnl_pct
                    
                    # Í±∞Îûò Í∏∞Î°ù Ï†ÄÏû•
                    trade_record = {
                        'timestamp': datetime.now().isoformat(),
                        'symbol': position_update.get('symbol', 'UNKNOWN'),
                        'pnl': pnl_pct,
                        'size_pct': position_update.get('size_pct', 0),
                        'duration': position_update.get('duration_minutes', 0)
                    }
                    self.trade_history.append(trade_record)
                    
                    # Í±∞Îûò Í∏∞Î°ù ÌÅ¨Í∏∞ Ï†úÌïú
                    if len(self.trade_history) > 500:
                        self.trade_history = self.trade_history[-400:]
                    
                    # Ïó∞Ïäπ/Ïó∞Ìå® Ï∂îÏ†Å
                    if pnl_pct > 0:
                        self.risk_metrics['win_streak'] += 1
                        self.risk_metrics['loss_streak'] = 0
                        self.risk_metrics['largest_win'] = max(
                            self.risk_metrics['largest_win'], pnl_pct
                        )
                    else:
                        self.risk_metrics['loss_streak'] += 1
                        self.risk_metrics['win_streak'] = 0
                        self.risk_metrics['largest_loss'] = min(
                            self.risk_metrics['largest_loss'], pnl_pct
                        )
                    
                    # ÏäπÎ•† ÏóÖÎç∞Ïù¥Ìä∏
                    recent_trades = self.trade_history[-20:] if len(self.trade_history) >= 20 else self.trade_history
                    if recent_trades:
                        wins = sum(1 for trade in recent_trades if trade['pnl'] > 0)
                        self.risk_metrics['success_rate'] = wins / len(recent_trades)
                    
                    # Î≥ÄÎèôÏÑ± ÏäπÏàò ÏóÖÎç∞Ïù¥Ìä∏
                    self._update_volatility_multiplier()
                
                # Í∞êÏÇ¨ Î°úÍ∑∏
                audit_logger.log_event(
                    'POSITION_UPDATE',
                    'system',
                    {
                        'action': action,
                        'active_positions': self.active_positions,
                        'total_exposure': self.total_exposure
                    }
                )
                    
            except Exception as e:
                secure_logger.error(f"Ìè¨ÏßÄÏÖò ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò: {e}")
                audit_logger.log_event(
                    'POSITION_UPDATE_ERROR',
                    'system',
                    {'error': str(e)},
                    'HIGH'
                )
    
    def _update_volatility_multiplier(self):
        """Î≥ÄÎèôÏÑ± Í∏∞Î∞ò Î¶¨Ïä§ÌÅ¨ ÏäπÏàò ÏóÖÎç∞Ïù¥Ìä∏"""
        try:
            if len(self.trade_history) < 10:
                return
            
            recent_trades = self.trade_history[-20:]
            pnl_values = [trade['pnl'] for trade in recent_trades]
            
            if NUMPY_AVAILABLE:
                volatility = np.std(pnl_values)
            else:
                # numpy ÏóÜÏù¥ ÌëúÏ§ÄÌé∏Ï∞® Í≥ÑÏÇ∞
                mean_pnl = sum(pnl_values) / len(pnl_values)
                variance = sum((x - mean_pnl) ** 2 for x in pnl_values) / len(pnl_values)
                volatility = variance ** 0.5
            
            # Î≥ÄÎèôÏÑ±Ïóê Îî∞Î•∏ ÏäπÏàò Ï°∞Ï†ï
            if volatility > 0.05:  # ÎÜíÏùÄ Î≥ÄÎèôÏÑ±
                self.risk_metrics['volatility_multiplier'] = 0.7
            elif volatility > 0.03:  # Ï§ëÍ∞Ñ Î≥ÄÎèôÏÑ±
                self.risk_metrics['volatility_multiplier'] = 0.85
            else:  # ÎÇÆÏùÄ Î≥ÄÎèôÏÑ±
                self.risk_metrics['volatility_multiplier'] = 1.0
                
        except Exception as e:
            secure_logger.error(f"Î≥ÄÎèôÏÑ± ÏäπÏàò ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò: {e}")
    
    def _validate_inputs(self, signal_data: Dict, analysis: Dict) -> bool:
        """ÏûÖÎ†• Îç∞Ïù¥ÌÑ∞ Ïú†Ìö®ÏÑ± Í≤ÄÏ¶ù"""
        try:
            if not isinstance(signal_data, dict) or not isinstance(analysis, dict):
                return False
            
            required_signal_fields = ['symbol', 'price', 'account_balance']
            for field in required_signal_fields:
                if field not in signal_data:
                    return False
            
            required_analysis_fields = ['confidence', 'final_confidence']
            for field in required_analysis_fields:
                if field not in analysis:
                    return False
            
            return True
        except Exception:
            return False
    
    def _check_daily_reset(self):
        """ÏùºÏùº Î¶¨ÏÖã Ï≤¥ÌÅ¨"""
        today = datetime.now().date()
        if today != self.last_reset:
            self.daily_pnl = 0.0
            self.risk_metrics['daily_trades'] = 0
            self.last_reset = today
            secure_logger.info("‚öñÔ∏è RISK: ÏùºÏùº ÌÜµÍ≥Ñ Î¶¨ÏÖã")
    
    def _create_error_response(self, error_msg: str) -> Dict:
        """ÏóêÎü¨ ÏùëÎãµ ÏÉùÏÑ±"""
        return {
            'approved': False,
            'position_size': 0,
            'position_size_pct': 0,
            'risk_level': 'CRITICAL',
            'checks': [error_msg],
            'error': error_msg
        }
    
    def get_risk_status(self) -> Dict:
        """Î¶¨Ïä§ÌÅ¨ ÏÉÅÌÉú Ï°∞Ìöå"""
        with self.lock:
            return {
                'current_status': {
                    'daily_pnl': round(self.daily_pnl, 4),
                    'active_positions': self.active_positions,
                    'total_exposure': round(self.total_exposure, 4),
                    'risk_utilization': round(abs(self.daily_pnl) / CONFIG.MAX_DAILY_LOSS, 4) if CONFIG.MAX_DAILY_LOSS > 0 else 0
                },
                'limits': {
                    'max_daily_loss': CONFIG.MAX_DAILY_LOSS,
                    'max_positions': CONFIG.MAX_POSITIONS,
                    'max_position_size': CONFIG.MAX_POSITION_SIZE,
                    'min_confidence': CONFIG.MIN_CONFIDENCE
                },
                'metrics': self.risk_metrics,
                'trade_history_count': len(self.trade_history),
                'timestamp': datetime.now().isoformat()
            }

# =============================================================================
# ‚ö° EXECUTE - Trade Execution Engine (Ïã§Ìñâ ÏóîÏßÑ)
# =============================================================================

class ExecutionEngine:
    """Ìó§ÏßÄÌéÄÎìúÍ∏â Í±∞Îûò Ïã§Ìñâ ÏóîÏßÑ"""
    
    def __init__(self, config: SafeConfig):
        self.config = config
        self.execution_threshold = SafeMath.safe_float(config.PHOENIX_95_CONFIG.get("threshold", 0.75))
        
        # Ïã§Ìñâ Ï°∞Í±¥ Îß§Ìä∏Î¶≠Ïä§ (Í∞úÏÑ†Îê®)
        self.execution_matrix = {
            ("IMMEDIATE", "LOW"): True,
            ("IMMEDIATE", "MEDIUM"): True,
            ("IMMEDIATE", "HIGH"): False,
            ("IMMEDIATE", "CRITICAL"): False,
            ("CAREFUL", "LOW"): True,
            ("CAREFUL", "MEDIUM"): True,
            ("CAREFUL", "HIGH"): False,
            ("CAREFUL", "CRITICAL"): False,
            ("MONITOR", "LOW"): True,
            ("MONITOR", "MEDIUM"): False,
            ("MONITOR", "HIGH"): False,
            ("MONITOR", "CRITICAL"): False,
            ("HOLD", "LOW"): False,
            ("HOLD", "MEDIUM"): False,
            ("HOLD", "HIGH"): False,
            ("HOLD", "CRITICAL"): False,
        }
        
        # Ïã§Ìñâ ÌÜµÍ≥Ñ
        self.execution_stats = {
            'total_trades': 0,
            'successful_trades': 0,
            'failed_trades': 0,
            'avg_execution_time': 0.0,
            'total_volume': 0.0,
            'slippage_stats': {
                'avg_slippage': 0.0,
                'max_slippage': 0.0
            }
        }
        
        self.lock = threading.RLock()
        
        secure_logger.info("‚ö° EXECUTE: Trade Execution Engine Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    def execute_trade(self, signal: TradingSignal, analysis: AnalysisResult, position_info: PositionInfo) -> TradeResult:
        """Í±∞Îûò Ïã§Ìñâ Í≤∞Ï†ï (Ìó§ÏßÄÌéÄÎìúÍ∏â)"""
        try:
            start_time = time.time()
            trade_id = f"T95_{int(start_time * 1000)}"
            
            # Ïã§Ìñâ Ï°∞Í±¥ Ï≤¥ÌÅ¨
            should_execute, reason = self._check_execution_conditions(analysis, position_info)
            
            # Ïã§Ìñâ ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
            processing_time = (time.time() - start_time) * 1000
            
            with self.lock:
                self.execution_stats['total_trades'] += 1
                
                if should_execute:
                    execution_status = "EXECUTED"
                    self.execution_stats['successful_trades'] += 1
                    self.execution_stats['total_volume'] += position_info.leveraged_size
                    
                    # ÌèâÍ∑† Ïã§Ìñâ ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
                    current_avg = self.execution_stats['avg_execution_time']
                    total_successful = self.execution_stats['successful_trades']
                    new_avg = ((current_avg * (total_successful - 1)) + processing_time) / total_successful
                    self.execution_stats['avg_execution_time'] = new_avg
                    
                    secure_logger.info(f"‚ö° EXECUTE: {signal.symbol} Í±∞Îûò Ïã§Ìñâ - Phoenix={analysis.phoenix_95_score:.2%}")
                    
                    # Í∞êÏÇ¨ Î°úÍ∑∏
                    audit_logger.log_event(
                        'TRADE_EXECUTED',
                        'system',
                        {
                            'trade_id': trade_id,
                            'symbol': signal.symbol,
                            'action': signal.action,
                            'phoenix_score': analysis.phoenix_95_score,
                            'position_size': position_info.leveraged_size
                        }
                    )
                    
                else:
                    execution_status = "HOLD"
                    self.execution_stats['failed_trades'] += 1
                    secure_logger.info(f"‚ö° EXECUTE: {signal.symbol} Î≥¥Î•ò - {reason}")
                    
                    # Í∞êÏÇ¨ Î°úÍ∑∏
                    audit_logger.log_event(
                        'TRADE_HOLD',
                        'system',
                        {
                            'trade_id': trade_id,
                            'symbol': signal.symbol,
                            'reason': reason
                        }
                    )
            
            hedge_fund_grade = processing_time <= CONFIG.PERFORMANCE_TARGETS["max_response_time_ms"]
            
            return TradeResult(
                trade_id=trade_id,
                signal_id=analysis.signal_id,
                symbol=signal.symbol,
                action=signal.action,
                phoenix_95_score=analysis.phoenix_95_score,
                position_info=position_info,
                execution_status=execution_status,
                execution_reason=reason,
                timestamp=time.time(),
                processing_time_ms=round(processing_time, 2),
                hedge_fund_grade=hedge_fund_grade
            )
            
        except Exception as e:
            secure_logger.error(f"‚ö° EXECUTE Í±∞Îûò Ïã§Ìñâ Ïò§Î•ò: {e}")
            
            # Í∞êÏÇ¨ Î°úÍ∑∏
            audit_logger.log_event(
                'TRADE_EXECUTION_ERROR',
                'system',
                {'error': str(e)},
                'CRITICAL'
            )
            
            # ÏïàÏ†ÑÌïú Í∏∞Î≥∏Í∞í Î∞òÌôò
            return TradeResult(
                trade_id=f"ERROR_{int(time.time() * 1000)}",
                signal_id=analysis.signal_id,
                symbol=signal.symbol,
                action=signal.action,
                phoenix_95_score=0.0,
                position_info=position_info,
                execution_status="ERROR",
                execution_reason=f"Ïã§Ìñâ Ïò§Î•ò: {e}",
                timestamp=time.time(),
                processing_time_ms=0.0,
                hedge_fund_grade=False
            )
    
    def _check_execution_conditions(self, analysis: AnalysisResult, position_info: PositionInfo) -> Tuple[bool, str]:
        """Ïã§Ìñâ Ï°∞Í±¥ Ï≤¥ÌÅ¨ (Ìó§ÏßÄÌéÄÎìúÍ∏â)"""
        try:
            # 1. Phoenix 95 ÏûÑÍ≥ÑÍ∞í Ï≤¥ÌÅ¨
            if analysis.final_confidence < self.execution_threshold:
                return False, f"Phoenix 95 ÏûÑÍ≥ÑÍ∞í ÎØ∏Îã¨ ({analysis.final_confidence:.1%} < {self.execution_threshold:.0%})"
            
            # 2. ÌÉÄÏù¥Î∞ç/Î¶¨Ïä§ÌÅ¨ Îß§Ìä∏Î¶≠Ïä§ Ï≤¥ÌÅ¨
            key = (analysis.execution_timing, analysis.risk_level)
            if not self.execution_matrix.get(key, False):
                return False, f"ÌÉÄÏù¥Î∞ç/Î¶¨Ïä§ÌÅ¨ Î∂ÄÏ†ÅÏ†à ({analysis.execution_timing}/{analysis.risk_level})"
            
            # 3. Î¶¨Ïä§ÌÅ¨ Ï†êÏàò Ï≤¥ÌÅ¨
            if position_info.risk_score >= 8.0:
                return False, f"Î¶¨Ïä§ÌÅ¨ Ï†êÏàò Í≥ºÎã§ ({position_info.risk_score}/10)"
            
            # 4. ÌíàÏßà Ï†êÏàò Ï≤¥ÌÅ¨
            if analysis.quality_score < 0.7:
                return False, f"ÌíàÏßà Ï†êÏàò Î∂ÄÏ°± ({analysis.quality_score:.1%})"
            
            # 5. Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ Ï≤¥ÌÅ¨
            if position_info.position_size <= 0:
                return False, "Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞ Î∂ÄÏ†ÅÏ†à"
            
            # 6. Ï≤≠ÏÇ∞Í∞Ä ÏïàÏ†ÑÏÑ± Ï≤¥ÌÅ¨
            liquidation_distance = abs(position_info.liquidation_price - position_info.stop_loss_price) / position_info.stop_loss_price
            if liquidation_distance < 0.1:  # Ï≤≠ÏÇ∞Í∞ÄÏôÄ ÏÜêÏ†àÍ∞ÄÍ∞Ä ÎÑàÎ¨¥ Í∞ÄÍπåÏõÄ
                return False, f"Ï≤≠ÏÇ∞Í∞Ä ÏúÑÌóò (Í±∞Î¶¨: {liquidation_distance:.1%})"
            
            return True, "Î™®Îì† Ïã§Ìñâ Ï°∞Í±¥ Ï∂©Ï°±"
            
        except Exception as e:
            secure_logger.error(f"Ïã§Ìñâ Ï°∞Í±¥ Ï≤¥ÌÅ¨ Ïò§Î•ò: {e}")
            return False, f"Ï°∞Í±¥ Ï≤¥ÌÅ¨ Ïã§Ìå®: {e}"
    
    def get_stats(self) -> Dict:
        """Ïã§Ìñâ ÌÜµÍ≥Ñ Ï°∞Ìöå"""
        with self.lock:
            total = self.execution_stats['total_trades']
            success_rate = (
                self.execution_stats['successful_trades'] / total * 100 
                if total > 0 else 0
            )
            
            return {
                'execution_stats': {
                    **self.execution_stats,
                    'success_rate_pct': round(success_rate, 2)
                },
                'configuration': {
                    'execution_threshold': self.execution_threshold,
                    'trade_mode': self.config.TRADE_MODE,
                    'leverage': self.config.LEVERAGE
                },
                'execution_matrix_size': len(self.execution_matrix)
            }

# =============================================================================
# üì± NOTIFY - Alert & Monitor Hub (ÏïåÎ¶º ÌóàÎ∏å)
# =============================================================================

class NotificationHub:
    """Ìó§ÏßÄÌéÄÎìúÍ∏â ÏïåÎ¶º Î∞è Î™®ÎãàÌÑ∞ÎßÅ ÌóàÎ∏å"""
    
    def __init__(self, config: SafeConfig):
        self.config = config
        self.telegram_config = config.TELEGRAM_CONFIG
        
        self.stats = {
            "total_sent": 0,
            "success_count": 0,
            "error_count": 0,
            "telegram_sent": 0,
            "console_sent": 0
        }
        
        self.lock = threading.RLock()
        
        secure_logger.info("üì± NOTIFY: Alert & Monitor Hub Ï¥àÍ∏∞Ìôî ÏôÑÎ£å")
    
    async def send_alert(self, trade_result: TradeResult):
        """Í±∞Îûò ÏïåÎ¶º Ï†ÑÏÜ° (Î©ÄÌã∞ Ï±ÑÎÑê)"""
        try:
            message = self._format_message(trade_result)
            
            with self.lock:
                self.stats["total_sent"] += 1
            
            # ÌÖîÎ†àÍ∑∏Îû® Ï†ÑÏÜ° ÏãúÎèÑ
            telegram_success = False
            if self.telegram_config.get("enabled", False) and REQUESTS_AVAILABLE:
                telegram_success = await self._send_telegram_message(message)
                if telegram_success:
                    with self.lock:
                        self.stats["telegram_sent"] += 1
            
            # ÏΩòÏÜî Ï∂úÎ†• (Î∞±ÏóÖ)
            if not telegram_success or CONFIG.EXECUTION_MODE == "SIMPLE":
                self._send_console_message(message)
                with self.lock:
                    self.stats["console_sent"] += 1
            
            with self.lock:
                self.stats["success_count"] += 1
            
            secure_logger.info(f"üì± NOTIFY: {trade_result.symbol} ÏïåÎ¶º Ï†ÑÏÜ° ÏôÑÎ£å")
            
        except Exception as e:
            with self.lock:
                self.stats["error_count"] += 1
            secure_logger.error(f"üì± NOTIFY ÏïåÎ¶º Ï†ÑÏÜ° Ïò§Î•ò: {e}")
    
    async def send_system_alert(self, alert_type: str, message: str, severity: str = 'INFO'):
        """ÏãúÏä§ÌÖú ÏïåÎ¶º Ï†ÑÏÜ°"""
        try:
            emoji_map = {
                'INFO': '‚ÑπÔ∏è',
                'WARNING': '‚ö†Ô∏è',
                'ERROR': '‚ùå',
                'CRITICAL': 'üö®'
            }
            
            emoji = emoji_map.get(severity, '‚ÑπÔ∏è')
            
            formatted_message = f"""
{emoji} <b>Phoenix 95 ÏãúÏä§ÌÖú ÏïåÎ¶º</b>

üìã <b>Ïú†Ìòï:</b> {alert_type}
üîç <b>ÎÇ¥Ïö©:</b> {message}
üìä <b>Ïã¨Í∞ÅÎèÑ:</b> {severity}

‚è∞ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
            
            # Ïã¨Í∞ÅÎèÑÏóê Îî∞Î•∏ Ï†ÑÏÜ° Î∞©Ïãù Í≤∞Ï†ï
            if severity in ['CRITICAL', 'ERROR'] or CONFIG.EXECUTION_MODE == "ADVANCED":
                if self.telegram_config.get("enabled", False) and REQUESTS_AVAILABLE:
                    await self._send_telegram_message(formatted_message)
                else:
                    self._send_console_message(formatted_message)
            else:
                self._send_console_message(formatted_message)
            
            with self.lock:
                self.stats["total_sent"] += 1
                self.stats["success_count"] += 1
                
        except Exception as e:
            with self.lock:
                self.stats["error_count"] += 1
            secure_logger.error(f"ÏãúÏä§ÌÖú ÏïåÎ¶º Ï†ÑÏÜ° Ïò§Î•ò: {e}")
    
    def _format_message(self, trade_result: TradeResult) -> str:
        """ÏïåÎ¶º Î©îÏãúÏßÄ Ìè¨Îß∑ (Í∞úÏÑ†Îê®)"""
        try:
            # ÏÉÅÌÉúÎ≥Ñ Ïù¥Î™®ÏßÄ
            status_emoji_map = {
                "EXECUTED": "üöÄ",
                "HOLD": "‚è≥",
                "ERROR": "‚ùå"
            }
            status_emoji = status_emoji_map.get(trade_result.execution_status, "‚ùì")
            
            # Î†àÎ≤ÑÎ¶¨ÏßÄ Ï†ïÎ≥¥
            leverage_info = f"{trade_result.position_info.leverage}x {trade_result.position_info.margin_mode}"
            
            # ÏÉÅÌÉúÎ≥Ñ Î©îÏãúÏßÄ ÎÇ¥Ïö©
            if trade_result.execution_status == "EXECUTED":
                potential_profit = SafeMath.safe_multiply(trade_result.position_info.leveraged_size, CONFIG.TAKE_PROFIT)
                roi_text = f"üí∞ **ÏàòÏùµ ÏòàÏÉÅ:** ${potential_profit:,.0f} ({CONFIG.TAKE_PROFIT:.1%} Îã¨ÏÑ±Ïãú)"
                
                # Í≥†Í∏â Ï†ïÎ≥¥ (ADVANCED Î™®ÎìúÏóêÏÑúÎßå)
                if CONFIG.EXECUTION_MODE == "ADVANCED":
                    advanced_info = f"""
üîç **Í≥†Í∏â Ï†ïÎ≥¥:**
‚Ä¢ Kelly Fraction: {trade_result.position_info.kelly_fraction:.3f}
‚Ä¢ Î¶¨Ïä§ÌÅ¨ Ïä§ÏΩîÏñ¥: {trade_result.position_info.risk_score:.1f}/10
‚Ä¢ Ï≤≠ÏÇ∞Í∞Ä: ${trade_result.position_info.liquidation_price:,.2f}
‚Ä¢ Ï≤òÎ¶¨ÏãúÍ∞Ñ: {trade_result.processing_time_ms:.1f}ms
‚Ä¢ Ìó§ÏßÄÌéÄÎìúÍ∏â: {'‚úÖ' if trade_result.hedge_fund_grade else '‚ùå'}"""
                else:
                    advanced_info = ""
                
            else:
                roi_text = f"üí≠ **ÏÉÅÌÉú:** {trade_result.execution_reason}"
                advanced_info = ""
            
            # Í∏∞Î≥∏ Î©îÏãúÏßÄ
            if CONFIG.EXECUTION_MODE == "SIMPLE":
                message = f"""
{status_emoji} **Phoenix 95 ÏãúÏä§ÌÖú**

üìä **{trade_result.symbol}** {trade_result.action.upper()}
üî• **Phoenix Score:** {trade_result.phoenix_95_score:.1%}
üíé **Ìè¨ÏßÄÏÖò:** ${trade_result.position_info.leveraged_size:,.0f}
‚öñÔ∏è **Î†àÎ≤ÑÎ¶¨ÏßÄ:** {leverage_info}
üõë **ÏÜêÏ†à:** ${trade_result.position_info.stop_loss_price:,.2f}
üéØ **ÏùµÏ†à:** ${trade_result.position_info.take_profit_price:,.2f}
‚ö° **ÏÉÅÌÉú:** {trade_result.execution_status}

{roi_text}

üÜî **Trade:** {trade_result.trade_id}
"""
            else:  # ADVANCED Î™®Îìú
                message = f"""
{status_emoji} **Phoenix 95 Ìó§ÏßÄÌéÄÎìú ÏãúÏä§ÌÖú**

üìä **Í∏∞Î≥∏ Ï†ïÎ≥¥**
‚Ä¢ Ïã¨Î≥º: **{trade_result.symbol}**
‚Ä¢ Î∞©Ìñ•: **{trade_result.action.upper()}**
‚Ä¢ Phoenix Score: **{trade_result.phoenix_95_score:.1%}**

üí∞ **Ìè¨ÏßÄÏÖò Ï†ïÎ≥¥**
‚Ä¢ Ìè¨ÏßÄÏÖò: **${trade_result.position_info.leveraged_size:,.0f}**
‚Ä¢ Î†àÎ≤ÑÎ¶¨ÏßÄ: **{leverage_info}**
‚Ä¢ ÎßàÏßÑ: **${trade_result.position_info.margin_required:,.0f}**

üéØ **Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨**
‚Ä¢ ÏÜêÏ†àÍ∞Ä: **${trade_result.position_info.stop_loss_price:,.2f}**
‚Ä¢ ÏùµÏ†àÍ∞Ä: **${trade_result.position_info.take_profit_price:,.2f}**
‚Ä¢ ÏÉÅÌÉú: **{trade_result.execution_status}**

{roi_text}
{advanced_info}

üÜî **Trade ID:** {trade_result.trade_id}
‚è∞ {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
            
            return message
            
        except Exception as e:
            secure_logger.error(f"Î©îÏãúÏßÄ Ìè¨Îß∑ Ïò§Î•ò: {e}")
            return f"Phoenix 95 ÏïåÎ¶º: {trade_result.symbol} {trade_result.execution_status} (Ìè¨Îß∑ Ïò§Î•ò)"
    
    async def _send_telegram_message(self, message: str) -> bool:
        """ÌÖîÎ†àÍ∑∏Îû® Î©îÏãúÏßÄ Ï†ÑÏÜ°"""
        try:
            if not REQUESTS_AVAILABLE or not self.telegram_config.get("token"):
                return False
            
            url = f"https://api.telegram.org/bot{self.telegram_config['token']}/sendMessage"
            payload = {
                "chat_id": self.telegram_config["chat_id"],
                "text": message,
                "parse_mode": self.telegram_config.get("parse_mode", "Markdown"),
                "disable_web_page_preview": True
            }
            
            if AIOHTTP_AVAILABLE:
                # ÎπÑÎèôÍ∏∞ ÏöîÏ≤≠
                result = await network_client.safe_post(url, json_data=payload)
                success = 'error' not in result
            else:
                # ÎèôÍ∏∞ ÏöîÏ≤≠ (fallback)
                response = requests.post(url, json=payload, timeout=self.telegram_config.get("timeout", 30))
                success = response.status_code == 200
            
            if success:
                secure_logger.info("üì± ÌÖîÎ†àÍ∑∏Îû® ÏïåÎ¶º ÏÑ±Í≥µ")
                return True
            else:
                secure_logger.warning("üì± ÌÖîÎ†àÍ∑∏Îû® Ï†ÑÏÜ° Ïã§Ìå®")
                return False
                
        except Exception as e:
            secure_logger.error(f"üì± ÌÖîÎ†àÍ∑∏Îû® Ïò§Î•ò: {e}")
            return False
    
    def _send_console_message(self, message: str):
        """ÏΩòÏÜî Î©îÏãúÏßÄ Ï∂úÎ†•"""
        try:
            # HTML ÌÉúÍ∑∏ Ï†úÍ±∞ (ÏΩòÏÜîÏö©)
            clean_message = re.sub(r'<[^>]+>', '', message)
            
            print(f"\nüì± Phoenix 95 ÏïåÎ¶º:")
            print("=" * 60)
            print(clean_message)
            print("=" * 60)
            
        except Exception as e:
            secure_logger.error(f"ÏΩòÏÜî Î©îÏãúÏßÄ Ï∂úÎ†• Ïò§Î•ò: {e}")
    
    def get_stats(self) -> Dict:
        """ÏïåÎ¶º ÌÜµÍ≥Ñ Ï°∞Ìöå"""
        with self.lock:
            return {
                **self.stats,
                'telegram_enabled': self.telegram_config.get("enabled", False),
                'success_rate': (
                    self.stats["success_count"] / self.stats["total_sent"] * 100
                    if self.stats["total_sent"] > 0 else 0
                )
            }

# =============================================================================
# üè¶ Phoenix 95 System (Î©îÏù∏ ÏãúÏä§ÌÖú)
# =============================================================================

class Phoenix95System:
    """Phoenix 95 ÏôÑÏ†Ñ ÌÜµÌï© Î©îÏù∏ ÏãúÏä§ÌÖú"""
    
    def __init__(self):
        self.config = CONFIG
        
        # 4Í∞ú ÌïµÏã¨ Ïª¥Ìè¨ÎÑåÌä∏ Ï¥àÍ∏∞Ìôî
        self.brain = SignalBrain(self.config)
        self.risk_manager = RiskManager(self.config)
        self.execution_engine = ExecutionEngine(self.config)
        self.notification_hub = NotificationHub(self.config)
        
        # ÏÑ±Îä• ÌÜµÍ≥Ñ
        self.stats = {
            "total_signals": 0,
            "executed_trades": 0,
            "held_trades": 0,
            "total_errors": 0,
            "avg_processing_time_ms": 0.0,
            "success_rate": 0.0,
            "system_uptime": time.time(),
            "cache_hit_rate": 0.0
        }
        
        self._lock = threading.RLock()
        
        secure_logger.info(f"üè¶ Phoenix 95 ÏôÑÏ†Ñ ÌÜµÌï© ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî ÏôÑÎ£å - Î™®Îìú: {self.config.EXECUTION_MODE}")
    
    async def process_signal(self, signal_request) -> Dict[str, Any]:
        """Ïã†Ìò∏ Ï≤òÎ¶¨ Î©îÏù∏ ÌååÏù¥ÌîÑÎùºÏù∏"""
        start_time = time.time()
        
        with self._lock:
            self.stats["total_signals"] += 1
        
        try:
            # 1. ÏûÖÎ†• Ïã†Ìò∏ Î≥ÄÌôò Î∞è Í≤ÄÏ¶ù
            signal = self._convert_signal_request(signal_request)
            
            # 2. Ïã¨Î≥º Í≤ÄÏ¶ù
            if signal.symbol not in self.config.ALLOWED_SYMBOLS:
                return self._create_error_response(f"ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Ïã¨Î≥º: {signal.symbol}")
            
            # 3. üß† BRAIN: AI Î∂ÑÏÑù
            analysis = self.brain.analyze_signal(signal)
            
            # 4. ‚öñÔ∏è RISK: Î¶¨Ïä§ÌÅ¨ Ï≤¥ÌÅ¨ Î∞è Ìè¨ÏßÄÏÖò Í≥ÑÏÇ∞
            risk_check = self.risk_manager.check_trade_approval(
                signal.__dict__, 
                analysis.__dict__
            )
            
            if not risk_check.get('approved', False):
                # Í±∞Îûò Í±∞Ï†à
                with self._lock:
                    self.stats["held_trades"] += 1
                
                # ÏïåÎ¶º Ï†ÑÏÜ° (Í±∞Ï†à ÏÇ¨Ïú†)
                dummy_position = PositionInfo(
                    kelly_fraction=0, position_size=0, margin_required=0,
                    leveraged_size=0, leverage=self.config.LEVERAGE,
                    stop_loss_price=signal.price, take_profit_price=signal.price,
                    liquidation_price=signal.price, margin_mode="ISOLATED", risk_score=10.0
                )
                
                trade_result = TradeResult(
                    trade_id=f"REJECTED_{int(time.time() * 1000)}",
                    signal_id=analysis.signal_id,
                    symbol=signal.symbol,
                    action=signal.action,
                    phoenix_95_score=analysis.phoenix_95_score,
                    position_info=dummy_position,
                    execution_status="REJECTED",
                    execution_reason="; ".join(risk_check.get('checks', ['Unknown reason'])),
                    timestamp=time.time(),
                    processing_time_ms=(time.time() - start_time) * 1000,
                    hedge_fund_grade=False
                )
                
                await self.notification_hub.send_alert(trade_result)
                
                return self._create_risk_rejection_response(risk_check, analysis, start_time)
            
            # 5. Ìè¨ÏßÄÏÖò Ï†ïÎ≥¥ Í≥ÑÏÇ∞
            position_info = self.risk_manager.calculate_position(signal, analysis)
            
            # 6. ‚ö° EXECUTE: Ïã§Ìñâ Í≤∞Ï†ï
            trade_result = self.execution_engine.execute_trade(signal, analysis, position_info)
            
            # 7. üì± NOTIFY: ÏïåÎ¶º Ï†ÑÏÜ°
            await self.notification_hub.send_alert(trade_result)
            
            # 8. ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏
            self._update_stats(trade_result, start_time)
            
            # 9. ÏÑ±Í≥µ ÏùëÎãµ ÏÉùÏÑ±
            return self._create_success_response(trade_result, analysis, position_info, risk_check, start_time)
            
        except Exception as e:
            with self._lock:
                self.stats["total_errors"] += 1
            
            secure_logger.error(f"‚ùå Ïã†Ìò∏ Ï≤òÎ¶¨ Ïò§Î•ò: {e}")
            
            # ÏãúÏä§ÌÖú ÏïåÎ¶º Ï†ÑÏÜ°
            await self.notification_hub.send_system_alert(
                "SYSTEM_ERROR",
                f"Ïã†Ìò∏ Ï≤òÎ¶¨ Ï§ë Ïò§Î•ò Î∞úÏÉù: {str(e)}",
                "ERROR"
            )
            
            return self._create_error_response(f"Ï≤òÎ¶¨ Ïò§Î•ò: {str(e)}")
    
    def _convert_signal_request(self, signal_request) -> TradingSignal:
        """Ïã†Ìò∏ ÏöîÏ≤≠ Î≥ÄÌôò (Í∞úÏÑ†Îê®)"""
        try:
            if hasattr(signal_request, 'symbol'):
                # Í∞ùÏ≤¥Ïù∏ Í≤ΩÏö∞
                return TradingSignal(
                    symbol=str(signal_request.symbol).upper().strip(),
                    action=str(signal_request.action).lower().strip(),
                    price=SafeMath.safe_float(signal_request.price),
                    confidence=SafeMath.clamp(getattr(signal_request, 'confidence', 0.8), 0.0, 1.0),
                    strategy=str(getattr(signal_request, 'strategy', 'phoenix95')),
                    timeframe=str(getattr(signal_request, 'timeframe', '1h')),
                    rsi=SafeMath.safe_float(getattr(signal_request, 'rsi')) if getattr(signal_request, 'rsi') else None,
                    macd=SafeMath.safe_float(getattr(signal_request, 'macd')) if getattr(signal_request, 'macd') else None,
                    volume=SafeMath.safe_float(getattr(signal_request, 'volume')) if getattr(signal_request, 'volume') else None,
                    account_balance=SafeMath.safe_float(getattr(signal_request, 'account_balance', 10000.0))
                )
            else:
                # DictÏù∏ Í≤ΩÏö∞
                return TradingSignal(
                    symbol=str(signal_request.get('symbol', '')).upper().strip(),
                    action=str(signal_request.get('action', '')).lower().strip(),
                    price=SafeMath.safe_float(signal_request.get('price', 0.0)),
                    confidence=SafeMath.clamp(signal_request.get('confidence', 0.8), 0.0, 1.0),
                    strategy=str(signal_request.get('strategy', 'phoenix95')),
                    timeframe=str(signal_request.get('timeframe', '1h')),
                    rsi=SafeMath.safe_float(signal_request.get('rsi')) if signal_request.get('rsi') else None,
                    macd=SafeMath.safe_float(signal_request.get('macd')) if signal_request.get('macd') else None,
                    volume=SafeMath.safe_float(signal_request.get('volume')) if signal_request.get('volume') else None,
                    account_balance=SafeMath.safe_float(signal_request.get('account_balance', 10000.0))
                )
        except Exception as e:
            secure_logger.error(f"Ïã†Ìò∏ Î≥ÄÌôò Ïò§Î•ò: {e}")
            raise ValueError(f"Ïã†Ìò∏ Î≥ÄÌôò Ïã§Ìå®: {e}") from e
    
    def _update_stats(self, trade_result: TradeResult, start_time: float):
        """ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏ (Í∞úÏÑ†Îê®)"""
        try:
            with self._lock:
                if trade_result.execution_status == "EXECUTED":
                    self.stats["executed_trades"] += 1
                else:
                    self.stats["held_trades"] += 1
                
                processing_time = (time.time() - start_time) * 1000
                total_signals = self.stats["total_signals"]
                
                # Ïù¥Îèô ÌèâÍ∑† Í≥ÑÏÇ∞
                current_avg = self.stats["avg_processing_time_ms"]
                self.stats["avg_processing_time_ms"] = (
                    (current_avg * (total_signals - 1) + processing_time) / total_signals
                )
                
                # ÏÑ±Í≥µÎ•† Í≥ÑÏÇ∞
                self.stats["success_rate"] = SafeMath.safe_divide(
                    self.stats["executed_trades"],
                    total_signals
                )
                
                # Ï∫êÏãú ÌûàÌä∏Ïú® ÏóÖÎç∞Ïù¥Ìä∏
                cache_stats = self.brain.analysis_cache.get_stats()
                self.stats["cache_hit_rate"] = cache_stats.get('hit_rate', 0.0)
                
        except Exception as e:
            secure_logger.error(f"ÌÜµÍ≥Ñ ÏóÖÎç∞Ïù¥Ìä∏ Ïò§Î•ò: {e}")
    
    def _create_success_response(self, trade_result: TradeResult, analysis: AnalysisResult, 
                               position_info: PositionInfo, risk_check: Dict, start_time: float) -> Dict[str, Any]:
        """ÏÑ±Í≥µ ÏùëÎãµ ÏÉùÏÑ± (Í∞úÏÑ†Îê®)"""
        try:
            processing_time = (time.time() - start_time) * 1000
            
            # Í∏∞Î≥∏ ÏùëÎãµ
            response = {
                "status": "success",
                "trade_result": {
                    "trade_id": trade_result.trade_id,
                    "symbol": trade_result.symbol,
                    "action": trade_result.action,
                    "phoenix_95_score": trade_result.phoenix_95_score,
                    "execution_status": trade_result.execution_status,
                    "execution_reason": trade_result.execution_reason,
                    "leveraged_size": position_info.leveraged_size,
                    "leverage": position_info.leverage,
                    "stop_loss": position_info.stop_loss_price,
                    "take_profit": position_info.take_profit_price,
                    "risk_score": position_info.risk_score
                },
                "performance": {
                    "processing_time_ms": round(processing_time, 2),
                    "hedge_fund_grade": processing_time <= self.config.PERFORMANCE_TARGETS["max_response_time_ms"],
                    "final_confidence": analysis.final_confidence,
                    "quality_score": analysis.quality_score
                },
                "system_info": {
                    "version": self.config.SYSTEM_VERSION,
                    "architecture": self.config.ARCHITECTURE,
                    "execution_mode": self.config.EXECUTION_MODE,
                    "components": ["BRAIN", "RISK", "EXECUTE", "NOTIFY"]
                },
                "timestamp": time.time()
            }
            
            # Í≥†Í∏â Î™®ÎìúÏóêÏÑúÎäî Ï∂îÍ∞Ä Ï†ïÎ≥¥ Ìè¨Ìï®
            if self.config.EXECUTION_MODE == "ADVANCED":
                response["advanced_info"] = {
                    "analysis_details": {
                        "technical_indicators": analysis.technical_indicators,
                        "analysis_time_ms": analysis.analysis_time_ms,
                        "cache_used": analysis.metadata.get('from_cache', False)
                    },
                    "risk_details": {
                        "kelly_fraction": position_info.kelly_fraction,
                        "margin_required": position_info.margin_required,
                        "liquidation_price": position_info.liquidation_price,
                        "risk_metrics": risk_check.get('risk_metrics', {}),
                        "kelly_sizing": risk_check.get('kelly_sizing', {})
                    },
                    "system_metrics": {
                        "cache_hit_rate": self.stats["cache_hit_rate"],
                        "avg_processing_time": self.stats["avg_processing_time_ms"],
                        "success_rate": self.stats["success_rate"]
                    }
                }
            
            return response
            
        except Exception as e:
            secure_logger.error(f"ÏÑ±Í≥µ ÏùëÎãµ ÏÉùÏÑ± Ïò§Î•ò: {e}")
            return {"status": "response_error", "message": str(e)}
    
    def _create_risk_rejection_response(self, risk_check: Dict, analysis: AnalysisResult, start_time: float) -> Dict[str, Any]:
        """Î¶¨Ïä§ÌÅ¨ Í±∞Ï†à ÏùëÎãµ ÏÉùÏÑ±"""
        processing_time = (time.time() - start_time) * 1000
        
        return {
            "status": "rejected",
            "reason": "Risk management rejection",
            "risk_check": risk_check,
            "analysis": {
                "phoenix_95_score": analysis.phoenix_95_score,
                "final_confidence": analysis.final_confidence,
                "quality_score": analysis.quality_score,
                "execution_timing": analysis.execution_timing,
                "risk_level": analysis.risk_level
            },
            "performance": {
                "processing_time_ms": round(processing_time, 2),
                "hedge_fund_grade": processing_time <= self.config.PERFORMANCE_TARGETS["max_response_time_ms"]
            },
            "timestamp": time.time()
        }
    
    def _create_error_response(self, error_message: str) -> Dict[str, Any]:
        """Ïò§Î•ò ÏùëÎãµ ÏÉùÏÑ±"""
        return {
            "status": "error",
            "message": error_message,
            "system_info": {
                "version": self.config.SYSTEM_VERSION,
                "execution_mode": self.config.EXECUTION_MODE
            },
            "timestamp": time.time()
        }
    
    def get_stats(self) -> Dict[str, Any]:
        """ÏãúÏä§ÌÖú ÌÜµÍ≥Ñ Ï°∞Ìöå (Í∞úÏÑ†Îê®)"""
        try:
            with self._lock:
                uptime = time.time() - self.stats["system_uptime"]
                
                # Ïª¥Ìè¨ÎÑåÌä∏Î≥Ñ ÌÜµÍ≥Ñ ÏàòÏßë
                brain_stats = self.brain.analysis_cache.get_stats()
                risk_stats = self.risk_manager.get_risk_status()
                execution_stats = self.execution_engine.get_stats()
                notification_stats = self.notification_hub.get_stats()
                
                return {
                    "system_overview": {
                        "version": self.config.SYSTEM_VERSION,
                        "architecture": self.config.ARCHITECTURE,
                        "execution_mode": self.config.EXECUTION_MODE,
                        "uptime_hours": round(uptime / 3600, 2),
                        "components": ["üß† BRAIN", "‚öñÔ∏è RISK", "‚ö° EXECUTE", "üì± NOTIFY"]
                    },
                    "performance_stats": {
                        **self.stats,
                        "avg_processing_time_ms": round(self.stats["avg_processing_time_ms"], 2),
                        "success_rate": round(self.stats["success_rate"] * 100, 1),
                        "error_rate": round(SafeMath.safe_divide(self.stats["total_errors"], self.stats["total_signals"]) * 100, 1),
                        "cache_hit_rate": round(self.stats["cache_hit_rate"] * 100, 1)
                    },
                    "component_stats": {
                        "brain": brain_stats,
                        "risk": risk_stats,
                        "execution": execution_stats,
                        "notifications": notification_stats
                    },
                    "configuration": {
                        "trade_mode": self.config.TRADE_MODE,
                        "leverage": self.config.LEVERAGE,
                        "min_confidence": self.config.MIN_CONFIDENCE,
                        "max_daily_loss": self.config.MAX_DAILY_LOSS,
                        "max_positions": self.config.MAX_POSITIONS,
                        "allowed_symbols": len(self.config.ALLOWED_SYMBOLS),
                        "telegram_enabled": self.config.TELEGRAM_CONFIG.get("enabled", False)
                    }
                }
        except Exception as e:
            secure_logger.error(f"ÌÜµÍ≥Ñ Ï°∞Ìöå Ïò§Î•ò: {e}")
            return {"error": str(e)}

# =============================================================================
# üåê FastAPI Application (ÏÑ†ÌÉùÏ†Å)
# =============================================================================

# ÏãúÏä§ÌÖú Ï¥àÍ∏∞Ìôî
phoenix_system = Phoenix95System()

if FASTAPI_AVAILABLE:
    # Î≥¥Ïïà ÎØ∏Îì§Ïõ®Ïñ¥
    class PayloadSizeLimitMiddleware(BaseHTTPMiddleware):
        """ÏöîÏ≤≠ ÌÅ¨Í∏∞ Ï†úÌïú ÎØ∏Îì§Ïõ®Ïñ¥ (DoS Î∞©ÏßÄ)"""
        
        def __init__(self, app, max_size_bytes: int = 1024 * 1024):  # 1MB
            super().__init__(app)
            self.max_size = max_size_bytes
        
        async def dispatch(self, request: Request, call_next):
            if hasattr(request, 'headers'):
                content_length = request.headers.get('content-length')
                if content_length and int(content_length) > self.max_size:
                    secure_logger.warning(f"ÌéòÏù¥Î°úÎìú ÌÅ¨Í∏∞ Ï¥àÍ≥º: {content_length} bytes")
                    raise HTTPException(
                        status_code=413, 
                        detail=f"Payload too large. Max size: {self.max_size} bytes"
                    )
            
            response = await call_next(request)
            return response
    
    # FastAPI Ïï± ÏÉùÏÑ±
    app = FastAPI(
        title="üè¶ Phoenix 95 Complete System",
        description=f"""
        **Ìó§ÏßÄÌéÄÎìúÍ∏â ÏôÑÏ†Ñ ÌÜµÌï© Í±∞Îûò ÏãúÏä§ÌÖú**
        
        ## üéØ ÌïµÏã¨ Í∏∞Îä•
        - üß† **BRAIN**: Phoenix 95 AI Î∂ÑÏÑù (Ï∫êÏãú ÏßÄÏõê)
        - ‚öñÔ∏è **RISK**: Kelly + Ìó§ÏßÄÌéÄÎìúÍ∏â Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨
        - ‚ö° **EXECUTE**: Ïã§ÏãúÍ∞Ñ Í±∞Îûò Ïã§Ìñâ
        - üì± **NOTIFY**: Î©ÄÌã∞Ï±ÑÎÑê ÏïåÎ¶º ÏãúÏä§ÌÖú
        
        ## üõ°Ô∏è ÏïàÏ†ÑÏÑ± Î≥¥Ïû•
        - ÏùòÏ°¥ÏÑ± Ïò§Î•ò Î∞©ÏßÄ (ÏÑ†ÌÉùÏ†Å import)
        - ÌÉÄÏûÖ ÏïàÏ†ÑÏÑ± ÌôïÎ≥¥ (SafeMath)
        - Î©îÎ™®Î¶¨ ÏïàÏ†Ñ Í¥ÄÎ¶¨ (Ï∫êÏãú + GC)
        - ÏòàÏô∏ Ï≤òÎ¶¨ Í∞ïÌôî (Î™®Îì† Ìï®Ïàò)
        - Î≥¥Ïïà Í∞êÏÇ¨ Î°úÍπÖ (ÎØºÍ∞êÏ†ïÎ≥¥ ÌïÑÌÑ∞ÎßÅ)
        
        ## ‚öôÔ∏è Ïã§Ìñâ Î™®Îìú
        - **SIMPLE**: Í∏∞Î≥∏ Í∏∞Îä•Îßå (Îπ†Î•∏ ÏùëÎãµ)
        - **ADVANCED**: Î™®Îì† Í≥†Í∏â Í∏∞Îä• ÌôúÏÑ±Ìôî
        
        ÌòÑÏû¨ Î™®Îìú: **{CONFIG.EXECUTION_MODE}**
        """,
        version="5.0.0-complete"
    )
    
    # ÎØ∏Îì§Ïõ®Ïñ¥ Ï∂îÍ∞Ä
    app.add_middleware(PayloadSizeLimitMiddleware, max_size_bytes=1024*1024)
    
    # CORS ÏÑ§Ï†ï
    app.add_middleware(
        CORSMiddleware,
        allow_origins=["*"],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )
    
    @app.get("/")
    async def root():
        """ÏãúÏä§ÌÖú Ï†ïÎ≥¥"""
        stats = phoenix_system.get_stats()
        return {
            "system": "üè¶ Phoenix 95 Complete System",
            "status": "üöÄ ACTIVE",
            "mode": CONFIG.EXECUTION_MODE,
            "version": CONFIG.SYSTEM_VERSION,
            "architecture": CONFIG.ARCHITECTURE,
            "components": stats["system_overview"]["components"],
            "performance": {
                "uptime_hours": stats["system_overview"]["uptime_hours"],
                "success_rate": stats["performance_stats"]["success_rate"],
                "avg_processing_time": stats["performance_stats"]["avg_processing_time_ms"],
                "cache_hit_rate": stats["performance_stats"]["cache_hit_rate"]
            },
            "features": {
                "fastapi": True,
                "telegram": CONFIG.TELEGRAM_CONFIG.get("enabled", False),
                "security_logging": True,
                "cache_system": True,
                "multi_mode": True,
                "dependencies": {
                    "fastapi": FASTAPI_AVAILABLE,
                    "requests": REQUESTS_AVAILABLE,
                    "aiohttp": AIOHTTP_AVAILABLE,
                    "psutil": PSUTIL_AVAILABLE,
                    "numpy": NUMPY_AVAILABLE
                }
            }
        }
    
    @app.get("/health")
    async def health():
        """Ìó¨Ïä§Ï≤¥ÌÅ¨"""
        stats = phoenix_system.get_stats()
        performance = stats["performance_stats"]
        
        # Í±¥Í∞ï ÏÉÅÌÉú Í≤∞Ï†ï
        health_score = 100
        issues = []
        
        if performance["error_rate"] > 5:
            health_score -= 20
            issues.append(f"High error rate: {performance['error_rate']}%")
        
        if performance["avg_processing_time_ms"] > CONFIG.PERFORMANCE_TARGETS["max_response_time_ms"]:
            health_score -= 15
            issues.append(f"Slow response time: {performance['avg_processing_time_ms']:.1f}ms")
        
        if performance["cache_hit_rate"] < 50:
            health_score -= 10
            issues.append(f"Low cache hit rate: {performance['cache_hit_rate']:.1f}%")
        
        status = "healthy" if health_score >= 80 else "degraded" if health_score >= 60 else "unhealthy"
        
        return {
            "status": status,
            "health_score": health_score,
            "issues": issues,
            "stats": performance,
            "timestamp": time.time()
        }
    
    @app.post("/webhook/signal")
    async def process_signal(signal_request: SignalRequest):
        """Ïã†Ìò∏ Ï≤òÎ¶¨ (Î©îÏù∏ API)"""
        try:
            result = await phoenix_system.process_signal(signal_request)
            
            # Í∞êÏÇ¨ Î°úÍ∑∏
            audit_logger.log_event(
                'API_SIGNAL_PROCESSED',
                'api_user',
                {
                    'symbol': signal_request.symbol,
                    'status': result.get('status'),
                    'processing_time': result.get('performance', {}).get('processing_time_ms', 0)
                }
            )
            
            return result
            
        except Exception as e:
            secure_logger.error(f"API Ïã†Ìò∏ Ï≤òÎ¶¨ Ïò§Î•ò: {e}")
            
            # Í∞êÏÇ¨ Î°úÍ∑∏
            audit_logger.log_event(
                'API_SIGNAL_ERROR',
                'api_user',
                {'error': str(e)},
                'HIGH'
            )
            
            raise HTTPException(status_code=500, detail=f"Ïã†Ìò∏ Ï≤òÎ¶¨ Ïã§Ìå®: {str(e)}")
    
    @app.get("/stats")
    async def get_stats():
        """ÏãúÏä§ÌÖú ÌÜµÍ≥Ñ"""
        return phoenix_system.get_stats()
    
    @app.get("/stats/components")
    async def get_component_stats():
        """Ïª¥Ìè¨ÎÑåÌä∏Î≥Ñ ÏÉÅÏÑ∏ ÌÜµÍ≥Ñ"""
        stats = phoenix_system.get_stats()
        return stats.get("component_stats", {})
    
    @app.get("/audit")
    async def get_audit_logs(count: int = 100, event_type: Optional[str] = None):
        """Í∞êÏÇ¨ Î°úÍ∑∏ Ï°∞Ìöå"""
        try:
            events = audit_logger.get_recent_events(count, event_type)
            summary = audit_logger.get_risk_summary()
            
            return {
                "events": events,
                "summary": summary,
                "total_requested": count,
                "total_returned": len(events),
                "timestamp": datetime.now().isoformat()
            }
        except Exception as e:
            secure_logger.error(f"Í∞êÏÇ¨ Î°úÍ∑∏ Ï°∞Ìöå Ïò§Î•ò: {e}")
            raise HTTPException(status_code=500, detail="Í∞êÏÇ¨ Î°úÍ∑∏ Ï°∞Ìöå Ïã§Ìå®")
    
    @app.post("/system/alert")
    async def send_system_alert(data: dict):
        """ÏãúÏä§ÌÖú ÏïåÎ¶º Ï†ÑÏÜ°"""
        try:
            alert_type = data.get('type', 'SYSTEM')
            message = data.get('message', 'Unknown system event')
            severity = data.get('severity', 'INFO')
            
            await phoenix_system.notification_hub.send_system_alert(alert_type, message, severity)
            
            return {
                'status': 'sent', 
                'alert_type': alert_type,
                'severity': severity,
                'timestamp': datetime.now().isoformat()
            }
        except Exception as e:
            secure_logger.error(f"ÏãúÏä§ÌÖú ÏïåÎ¶º API Ïò§Î•ò: {e}")
            raise HTTPException(status_code=500, detail="ÏãúÏä§ÌÖú ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®")
    
    @app.get("/config")
    async def get_config():
        """ÏãúÏä§ÌÖú ÏÑ§Ï†ï Ï°∞Ìöå (ÎØºÍ∞êÏ†ïÎ≥¥ Ï†úÏô∏)"""
        return {
            "system": {
                "version": CONFIG.SYSTEM_VERSION,
                "execution_mode": CONFIG.EXECUTION_MODE,
                "trade_mode": CONFIG.TRADE_MODE
            },
            "trading": {
                "leverage": CONFIG.LEVERAGE,
                "stop_loss": CONFIG.STOP_LOSS,
                "take_profit": CONFIG.TAKE_PROFIT,
                "min_confidence": CONFIG.MIN_CONFIDENCE,
                "max_positions": CONFIG.MAX_POSITIONS,
                "allowed_symbols_count": len(CONFIG.ALLOWED_SYMBOLS)
            },
            "performance_targets": CONFIG.PERFORMANCE_TARGETS,
            "telegram_enabled": CONFIG.TELEGRAM_CONFIG.get("enabled", False)
        }
    
    @app.get("/dashboard", response_class=HTMLResponse)
    async def dashboard():
        """Ïã§ÏãúÍ∞Ñ ÎåÄÏãúÎ≥¥Îìú"""
        stats = phoenix_system.get_stats()
        
        html = f"""
        <!DOCTYPE html>
        <html>
        <head>
            <title>Phoenix 95 Complete Dashboard</title>
            <meta charset="utf-8">
            <meta name="viewport" content="width=device-width, initial-scale=1">
            <style>
                body {{ 
                    font-family: 'Arial', sans-serif; 
                    margin: 0; 
                    padding: 20px; 
                    background: linear-gradient(135deg, #1a1a1a 0%, #2d2d2d 100%); 
                    color: #fff; 
                }}
                .container {{ max-width: 1400px; margin: 0 auto; }}
                .header {{ 
                    text-align: center; 
                    margin-bottom: 40px; 
                    background: rgba(255,255,255,0.05);
                    padding: 30px;
                    border-radius: 15px;
                    backdrop-filter: blur(10px);
                }}
                .mode-badge {{
                    display: inline-block;
                    padding: 8px 16px;
                    background: {'#4CAF50' if CONFIG.EXECUTION_MODE == 'SIMPLE' else '#FF9800'};
                    color: white;
                    border-radius: 20px;
                    font-size: 14px;
                    font-weight: bold;
                    margin-left: 10px;
                }}
                .stats-grid {{ 
                    display: grid; 
                    grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); 
                    gap: 25px; 
                    margin-bottom: 30px;
                }}
                .stat-card {{ 
                    background: rgba(255,255,255,0.08); 
                    padding: 25px; 
                    border-radius: 15px; 
                    box-shadow: 0 8px 25px rgba(0,0,0,0.3);
                    backdrop-filter: blur(10px);
                    border: 1px solid rgba(255,255,255,0.1);
                    transition: transform 0.3s ease, box-shadow 0.3s ease;
                }}
                .stat-card:hover {{
                    transform: translateY(-5px);
                    box-shadow: 0 12px 35px rgba(0,0,0,0.4);
                }}
                .stat-value {{ 
                    font-size: 2.5em; 
                    font-weight: bold; 
                    background: linear-gradient(45deg, #4CAF50, #45a049);
                    -webkit-background-clip: text;
                    -webkit-text-fill-color: transparent;
                    background-clip: text;
                }}
                .stat-label {{ 
                    color: #bbb; 
                    margin-top: 8px; 
                    font-size: 1.1em;
                }}
                .component-status {{
                    display: flex;
                    justify-content: space-around;
                    margin: 30px 0;
                    padding: 25px;
                    background: rgba(255,255,255,0.05);
                    border-radius: 15px;
                }}
                .component {{
                    text-align: center;
                    padding: 15px;
                }}
                .component-icon {{
                    font-size: 2em;
                    margin-bottom: 10px;
                }}
                .refresh {{ 
                    text-align: center; 
                    margin-top: 30px; 
                }}
                .refresh button {{ 
                    padding: 15px 30px; 
                    background: linear-gradient(45deg, #4CAF50, #45a049); 
                    color: white; 
                    border: none; 
                    border-radius: 25px; 
                    cursor: pointer; 
                    font-size: 16px;
                    font-weight: bold;
                    transition: all 0.3s ease;
                }}
                .refresh button:hover {{
                    transform: translateY(-2px);
                    box-shadow: 0 8px 20px rgba(76, 175, 80, 0.3);
                }}
                .health-indicator {{
                    display: inline-block;
                    width: 12px;
                    height: 12px;
                    background: #4CAF50;
                    border-radius: 50%;
                    margin-right: 8px;
                    animation: pulse 2s infinite;
                }}
                @keyframes pulse {{
                    0% {{ opacity: 1; }}
                    50% {{ opacity: 0.5; }}
                    100% {{ opacity: 1; }}
                }}
                .dependency-status {{
                    display: grid;
                    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
                    gap: 15px;
                    margin-top: 20px;
                }}
                .dependency {{
                    padding: 10px;
                    background: rgba(255,255,255,0.05);
                    border-radius: 8px;
                    text-align: center;
                }}
                .available {{ border-left: 4px solid #4CAF50; }}
                .unavailable {{ border-left: 4px solid #f44336; }}
            </style>
        </head>
        <body>
            <div class="container">
                <div class="header">
                    <h1>üè¶ Phoenix 95 Complete Dashboard</h1>
                    <span class="health-indicator"></span>
                    <span>Ìó§ÏßÄÌéÄÎìúÍ∏â ÏôÑÏ†Ñ ÌÜµÌï© Í±∞Îûò ÏãúÏä§ÌÖú</span>
                    <span class="mode-badge">{CONFIG.EXECUTION_MODE} MODE</span>
                    <p style="margin-top: 15px; color: #bbb;">
                        Version {CONFIG.SYSTEM_VERSION} ‚Ä¢ {CONFIG.ARCHITECTURE} ‚Ä¢ Trade Mode: {CONFIG.TRADE_MODE}
                    </p>
                </div>
                
                <div class="component-status">
                    <div class="component">
                        <div class="component-icon">üß†</div>
                        <div><strong>BRAIN</strong></div>
                        <div>AI Analysis Engine</div>
                    </div>
                    <div class="component">
                        <div class="component-icon">‚öñÔ∏è</div>
                        <div><strong>RISK</strong></div>
                        <div>Position Manager</div>
                    </div>
                    <div class="component">
                        <div class="component-icon">‚ö°</div>
                        <div><strong>EXECUTE</strong></div>
                        <div>Trade Engine</div>
                    </div>
                    <div class="component">
                        <div class="component-icon">üì±</div>
                        <div><strong>NOTIFY</strong></div>
                        <div>Alert Hub</div>
                    </div>
                </div>
                
                <div class="stats-grid">
                    <div class="stat-card">
                        <div class="stat-value">{stats['performance_stats']['total_signals']}</div>
                        <div class="stat-label">Ï¥ù Ïã†Ìò∏ Ï≤òÎ¶¨</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-value">{stats['performance_stats']['executed_trades']}</div>
                        <div class="stat-label">Ïã§ÌñâÎêú Í±∞Îûò</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-value">{stats['performance_stats']['success_rate']:.1f}%</div>
                        <div class="stat-label">ÏÑ±Í≥µÎ•†</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-value">{stats['performance_stats']['avg_processing_time_ms']:.1f}ms</div>
                        <div class="stat-label">ÌèâÍ∑† Ï≤òÎ¶¨ÏãúÍ∞Ñ</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-value">{stats['system_overview']['uptime_hours']:.1f}h</div>
                        <div class="stat-label">Í∞ÄÎèôÏãúÍ∞Ñ</div>
                    </div>
                    
                    <div class="stat-card">
                        <div class="stat-value">{stats['performance_stats']['cache_hit_rate']:.1f}%</div>
                        <div class="stat-label">Ï∫êÏãú ÌûàÌä∏Ïú®</div>
                    </div>
                </div>
                
                <div class="stat-card">
                    <h3>üîß ÏùòÏ°¥ÏÑ± ÏÉÅÌÉú</h3>
                    <div class="dependency-status">
                        <div class="dependency {'available' if FASTAPI_AVAILABLE else 'unavailable'}">
                            <strong>FastAPI</strong><br>
                            {'‚úÖ ÏÇ¨Ïö© Í∞ÄÎä•' if FASTAPI_AVAILABLE else '‚ùå ÎØ∏ÏÑ§Ïπò'}
                        </div>
                        <div class="dependency {'available' if REQUESTS_AVAILABLE else 'unavailable'}">
                            <strong>Requests</strong><br>
                            {'‚úÖ ÏÇ¨Ïö© Í∞ÄÎä•' if REQUESTS_AVAILABLE else '‚ùå ÎØ∏ÏÑ§Ïπò'}
                        </div>
                        <div class="dependency {'available' if AIOHTTP_AVAILABLE else 'unavailable'}">
                            <strong>aiohttp</strong><br>
                            {'‚úÖ ÏÇ¨Ïö© Í∞ÄÎä•' if AIOHTTP_AVAILABLE else '‚ùå ÎØ∏ÏÑ§Ïπò'}
                        </div>
                        <div class="dependency {'available' if PSUTIL_AVAILABLE else 'unavailable'}">
                            <strong>psutil</strong><br>
                            {'‚úÖ ÏÇ¨Ïö© Í∞ÄÎä•' if PSUTIL_AVAILABLE else '‚ùå ÎØ∏ÏÑ§Ïπò'}
                        </div>
                        <div class="dependency {'available' if NUMPY_AVAILABLE else 'unavailable'}">
                            <strong>numpy</strong><br>
                            {'‚úÖ ÏÇ¨Ïö© Í∞ÄÎä•' if NUMPY_AVAILABLE else '‚ùå ÎØ∏ÏÑ§Ïπò'}
                        </div>
                    </div>
                </div>
                
                <div class="refresh">
                    <button onclick="location.reload()">üîÑ ÏÉàÎ°úÍ≥†Ïπ®</button>
                </div>
            </div>
            
            <script>
                // 30Ï¥àÎßàÎã§ ÏûêÎèô ÏÉàÎ°úÍ≥†Ïπ®
                setTimeout(() => location.reload(), 30000);
                
                // Ïã§ÏãúÍ∞Ñ ÏãúÍ≥Ñ
                function updateTime() {{
                    const now = new Date();
                    const timeStr = now.toLocaleTimeString('ko-KR');
                    document.title = `Phoenix 95 Dashboard - ${{timeStr}}`;
                }}
                setInterval(updateTime, 1000);
            </script>
        </body>
        </html>
        """
        
        return HTMLResponse(content=html)

else:
    app = None

# =============================================================================
# üß™ Test Functions (ÌÖåÏä§Ìä∏ Ìï®Ïàò)
# =============================================================================

def create_test_signals():
    """ÌÖåÏä§Ìä∏ Ïã†Ìò∏ ÏÉùÏÑ± (Í∞úÏÑ†Îê®)"""
    return [
        {
            "symbol": "BTCUSDT",
            "action": "buy",
            "price": 45000.0,
            "confidence": 0.85,
            "rsi": 35.5,
            "macd": 0.003,
            "volume": 2500000,
            "account_balance": 10000.0,
            "description": "Í≥†Ïã†Î¢∞ÎèÑ BTC Îß§Ïàò Ïã†Ìò∏"
        },
        {
            "symbol": "ETHUSDT",
            "action": "sell",
            "price": 2800.0,
            "confidence": 0.72,
            "rsi": 75.2,
            "macd": -0.002,
            "volume": 1800000,
            "account_balance": 10000.0,
            "description": "Ï§ëÍ∞ÑÏã†Î¢∞ÎèÑ ETH Îß§ÎèÑ Ïã†Ìò∏"
        },
        {
            "symbol": "BNBUSDT",
            "action": "long",
            "price": 320.0,
            "confidence": 0.92,
            "rsi": 45.0,
            "macd": 0.008,
            "volume": 3200000,
            "account_balance": 10000.0,
            "description": "Ï¥àÍ≥†Ïã†Î¢∞ÎèÑ BNB Î°± Ïã†Ìò∏"
        },
        {
            "symbol": "ADAUSDT",
            "action": "buy",
            "price": 0.45,
            "confidence": 0.38,
            "rsi": 52.1,
            "volume": 800000,
            "account_balance": 10000.0,
            "description": "Ï†ÄÏã†Î¢∞ÎèÑ ADA Îß§Ïàò Ïã†Ìò∏ (HOLD ÏòàÏÉÅ)"
        },
        {
            "symbol": "SOLUSDT",
            "action": "short",
            "price": 95.0,
            "confidence": 0.78,
            "rsi": 68.5,
            "macd": -0.005,
            "volume": 2100000,
            "account_balance": 10000.0,
            "description": "Í≥†Ïã†Î¢∞ÎèÑ SOL Ïàè Ïã†Ìò∏"
        }
    ]

async def run_comprehensive_test():
    """Ï¢ÖÌï© ÌÖåÏä§Ìä∏ Ïã§Ìñâ (Í∞úÏÑ†Îê®)"""
    print("\nüß™ Phoenix 95 Complete System Ï¢ÖÌï© ÌÖåÏä§Ìä∏")
    print("=" * 70)
    print(f"Ïã§Ìñâ Î™®Îìú: {CONFIG.EXECUTION_MODE}")
    print(f"Í±∞Îûò Î™®Îìú: {CONFIG.TRADE_MODE}")
    print(f"Î†àÎ≤ÑÎ¶¨ÏßÄ: {CONFIG.LEVERAGE}x")
    print("=" * 70)
    
    test_signals = create_test_signals()
    results = []
    
    for i, test_data in enumerate(test_signals, 1):
        print(f"\nüìä ÌÖåÏä§Ìä∏ {i}/{len(test_signals)}: {test_data['description']}")
        
        try:
            start_time = time.time()
            result = await phoenix_system.process_signal(test_data)
            processing_time = (time.time() - start_time) * 1000
            
            if result["status"] == "success":
                trade = result["trade_result"]
                perf = result["performance"]
                
                print(f"   ‚úÖ Ï≤òÎ¶¨ ÏÑ±Í≥µ:")
                print(f"      üî• Phoenix 95: {trade['phoenix_95_score']:.1%}")
                print(f"      ‚ö° ÏÉÅÌÉú: {trade['execution_status']}")
                print(f"      üí∞ Ìè¨ÏßÄÏÖò: ${trade['leveraged_size']:,.0f}")
                print(f"      ‚è±Ô∏è ÏãúÍ∞Ñ: {perf['processing_time_ms']:.1f}ms")
                print(f"      üèÜ Ìó§ÏßÄÌéÄÎìúÍ∏â: {'‚úÖ' if perf['hedge_fund_grade'] else '‚ùå'}")
                
                if CONFIG.EXECUTION_MODE == "ADVANCED" and "advanced_info" in result:
                    adv = result["advanced_info"]
                    print(f"      üìà Ï∫êÏãú ÏÇ¨Ïö©: {'‚úÖ' if adv['analysis_details']['cache_used'] else '‚ùå'}")
                    print(f"      üéØ Kelly Fraction: {adv['risk_details']['kelly_fraction']:.4f}")
                
            elif result["status"] == "rejected":
                risk_check = result["risk_check"]
                print(f"   ‚ùå Î¶¨Ïä§ÌÅ¨ Í±∞Ï†à:")
                print(f"      üìã ÏÇ¨Ïú†: {'; '.join(risk_check['checks'][:2])}")
                print(f"      üìä Î¶¨Ïä§ÌÅ¨ Î†àÎ≤®: {risk_check['risk_level']}")
                
            else:
                print(f"   ‚ùå Ï≤òÎ¶¨ Ïã§Ìå®: {result['message']}")
            
            results.append({
                'test_id': i,
                'symbol': test_data['symbol'],
                'status': result['status'],
                'processing_time': processing_time
            })
                
        except Exception as e:
            print(f"   ‚ùå ÌÖåÏä§Ìä∏ Ïò§Î•ò: {e}")
            results.append({
                'test_id': i,
                'symbol': test_data['symbol'],
                'status': 'error',
                'processing_time': 0
            })
    
    # Ï¢ÖÌï© ÌÜµÍ≥Ñ
    print(f"\nüìä ÌÖåÏä§Ìä∏ Í≤∞Í≥º ÏöîÏïΩ:")
    print("=" * 50)
    
    total_tests = len(results)
    successful = len([r for r in results if r['status'] == 'success'])
    rejected = len([r for r in results if r['status'] == 'rejected'])
    errors = len([r for r in results if r['status'] == 'error'])
    avg_time = sum(r['processing_time'] for r in results) / total_tests if total_tests > 0 else 0
    
    print(f"Ï¥ù ÌÖåÏä§Ìä∏: {total_tests}")
    print(f"ÏÑ±Í≥µ: {successful} ({successful/total_tests*100:.1f}%)")
    print(f"Í±∞Ï†à: {rejected} ({rejected/total_tests*100:.1f}%)")
    print(f"Ïò§Î•ò: {errors} ({errors/total_tests*100:.1f}%)")
    print(f"ÌèâÍ∑† Ï≤òÎ¶¨ÏãúÍ∞Ñ: {avg_time:.1f}ms")
    
    # ÏãúÏä§ÌÖú ÌÜµÍ≥Ñ
    stats = phoenix_system.get_stats()
    print(f"\nüìà ÏãúÏä§ÌÖú ÏÑ±Îä•:")
    print(f"   Ï†ÑÏ≤¥ Ïã†Ìò∏: {stats['performance_stats']['total_signals']}")
    print(f"   ÏÑ±Í≥µÎ•†: {stats['performance_stats']['success_rate']:.1f}%")
    print(f"   ÌèâÍ∑† Ï≤òÎ¶¨ÏãúÍ∞Ñ: {stats['performance_stats']['avg_processing_time_ms']:.1f}ms")
    print(f"   Ï∫êÏãú ÌûàÌä∏Ïú®: {stats['performance_stats']['cache_hit_rate']:.1f}%")
    
    # Ïª¥Ìè¨ÎÑåÌä∏ ÏÉÅÌÉú
    comp_stats = stats.get('component_stats', {})
    print(f"\nüîß Ïª¥Ìè¨ÎÑåÌä∏ ÏÉÅÌÉú:")
    if 'brain' in comp_stats:
        print(f"   üß† BRAIN - Ï∫êÏãú ÌÅ¨Í∏∞: {comp_stats['brain']['size']}")
    if 'risk' in comp_stats:
        print(f"   ‚öñÔ∏è RISK - ÌôúÏÑ± Ìè¨ÏßÄÏÖò: {comp_stats['risk']['current_status']['active_positions']}")
    if 'execution' in comp_stats:
        print(f"   ‚ö° EXECUTE - Ï¥ù Í±∞Îûò: {comp_stats['execution']['execution_stats']['total_trades']}")
    
    print("\n‚úÖ Ï¢ÖÌï© ÌÖåÏä§Ìä∏ ÏôÑÎ£å!")

# =============================================================================
# üèÉ‚Äç‚ôÇÔ∏è Main Execution Functions (Î©îÏù∏ Ïã§Ìñâ Ìï®ÏàòÎì§)
# =============================================================================

def run_simple_mode():
    """Îã®Ïàú Î™®Îìú Ïã§Ìñâ (FastAPI ÏóÜÏù¥)"""
    print(f"""
üè¶ Phoenix 95 Complete System - SIMPLE Mode
================================================================================

üéØ ÌôúÏÑ±ÌôîÎêú Í∏∞Îä•:
‚úÖ ÌïµÏã¨ 4ÎåÄ Ïª¥Ìè¨ÎÑåÌä∏ (BRAIN, RISK, EXECUTE, NOTIFY)  
‚úÖ Phoenix 95 AI Î∂ÑÏÑù ÏóîÏßÑ
‚úÖ Ìó§ÏßÄÌéÄÎìúÍ∏â Î¶¨Ïä§ÌÅ¨ Í¥ÄÎ¶¨
‚úÖ ÏïàÏ†ÑÌïú ÌÉÄÏûÖ ÏãúÏä§ÌÖú
‚úÖ Ï∫êÏãú ÏãúÏä§ÌÖú (5Î∂Ñ TTL)
‚úÖ ÌÖîÎ†àÍ∑∏Îû® ÏïåÎ¶º
‚úÖ Î≥¥Ïïà Í∞êÏÇ¨ Î°úÍπÖ

‚öôÔ∏è ÏÑ§Ï†ï:
‚Ä¢ Î†àÎ≤ÑÎ¶¨ÏßÄ: {CONFIG.LEVERAGE}x ISOLATED
‚Ä¢ ÏùµÏ†à/ÏÜêÏ†à: ¬±{CONFIG.STOP_LOSS:.1%}
‚Ä¢ ÏµúÏÜå Ïã†Î¢∞ÎèÑ: {CONFIG.MIN_CONFIDENCE:.1%}
‚Ä¢ ÏµúÎåÄ ÏùºÏùºÏÜêÏã§: {CONFIG.MAX_DAILY_LOSS:.1%}

================================================================================
""")
    
    try:
        # ÏãúÏûë ÏïåÎ¶º
        async def send_start_notification():
            await phoenix_system.notification_hub.send_system_alert(
                "SYSTEM_START",
                f"Phoenix 95 Complete System ÏãúÏûë (SIMPLE Î™®Îìú)",
                "INFO"
            )
        
        asyncio.run(send_start_notification())
        
        # ÌÖåÏä§Ìä∏ Ïã§Ìñâ
        print("üß™ ÏûêÎèô ÌÖåÏä§Ìä∏ ÏãúÏûë...")
        asyncio.run(run_comprehensive_test())
        
        print("\n" + "="*50)
        print("üí° ÏÇ¨Ïö©Î≤ï:")
        print("   Python ÏΩîÎìúÏóêÏÑú phoenix_system.process_signal(data) Ìò∏Ï∂ú")
        print("   ÎòêÎäî --server ÏòµÏÖòÏúºÎ°ú FastAPI ÏÑúÎ≤Ñ Ïã§Ìñâ")
        print("="*50)
        
    except KeyboardInterrupt:
        print("\nüëã Phoenix 95 ÏãúÏä§ÌÖú Ï¢ÖÎ£å")
    except Exception as e:
        secure_logger.error(f"Simple Î™®Îìú Ïã§Ìñâ Ïò§Î•ò: {e}")

def run_server_mode():
    """ÏÑúÎ≤Ñ Î™®Îìú Ïã§Ìñâ (FastAPI)"""
    if not FASTAPI_AVAILABLE:
        print("‚ùå FastAPIÍ∞Ä ÏÑ§ÏπòÎêòÏßÄ ÏïäÏïòÏäµÎãàÎã§.")
        print("ÏÑ§Ïπò: pip install fastapi uvicorn")
        return
    
    print(f"""
üè¶ Phoenix 95 Complete System - SERVER Mode
================================================================================

üåê ÏÑúÎ≤Ñ Ï†ïÎ≥¥:
‚Ä¢ Î©îÏù∏ ÏÑúÎ≤Ñ: http://localhost:8000
‚Ä¢ API Î¨∏ÏÑú: http://localhost:8000/docs  
‚Ä¢ ÎåÄÏãúÎ≥¥Îìú: http://localhost:8000/dashboard
‚Ä¢ Ìó¨Ïä§Ï≤¥ÌÅ¨: http://localhost:8000/health

üéØ Ï£ºÏöî ÏóîÎìúÌè¨Ïù∏Ìä∏:
‚Ä¢ POST /webhook/signal - Ïã†Ìò∏ Ï≤òÎ¶¨
‚Ä¢ GET /stats - ÏãúÏä§ÌÖú ÌÜµÍ≥Ñ
‚Ä¢ GET /audit - Í∞êÏÇ¨ Î°úÍ∑∏
‚Ä¢ GET /config - ÏÑ§Ï†ï Ï°∞Ìöå

‚öôÔ∏è Ïã§Ìñâ Î™®Îìú: {CONFIG.EXECUTION_MODE}
üîß Í±∞Îûò Î™®Îìú: {CONFIG.TRADE_MODE}

================================================================================
""")
    
    try:
        import uvicorn
        
        # ÏÑúÎ≤Ñ ÏãúÏûë ÏïåÎ¶º
        async def send_server_start():
            await phoenix_system.notification_hub.send_system_alert(
                "SERVER_START",
                f"Phoenix 95 ÏÑúÎ≤Ñ ÏãúÏûë (Ìè¨Ìä∏: 8000, Î™®Îìú: {CONFIG.EXECUTION_MODE})",
                "INFO"
            )
        
        # Î∞±Í∑∏ÎùºÏö¥ÎìúÏóêÏÑú ÏïåÎ¶º Ï†ÑÏÜ°
        def background_notification():
            asyncio.run(send_server_start())
        
        notification_thread = threading.Thread(target=background_notification, daemon=True)
        notification_thread.start()
        
        # ÏÑúÎ≤Ñ Ïã§Ìñâ
        uvicorn.run(
            app, 
            host="0.0.0.0", 
            port=8000, 
            log_level="info"
        )
        
    except KeyboardInterrupt:
        print("\nüëã Phoenix 95 ÏÑúÎ≤Ñ Ï¢ÖÎ£å")
    except Exception as e:
        secure_logger.error(f"ÏÑúÎ≤Ñ Î™®Îìú Ïã§Ìñâ Ïò§Î•ò: {e}")

def run_demo_mode():
    """Îç∞Î™® Î™®Îìú (ÎåÄÌôîÌòï)"""
    print(f"""
üé≠ Phoenix 95 Complete System - DEMO Mode
================================================================================

ÎåÄÌôîÌòï Îç∞Î™® Î™®ÎìúÏûÖÎãàÎã§.
Ïã§ÏãúÍ∞ÑÏúºÎ°ú Ïã†Ìò∏Î•º ÏûÖÎ†•ÌïòÍ≥† Í≤∞Í≥ºÎ•º ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§.

üí° ÏÇ¨Ïö©Î≤ï:
1. Ïã¨Î≥º ÏûÖÎ†• (Ïòà: BTCUSDT)
2. Ïï°ÏÖò ÏûÖÎ†• (buy/sell/long/short)
3. Í∞ÄÍ≤© ÏûÖÎ†• (Ïòà: 45000)
4. Ïã†Î¢∞ÎèÑ ÏûÖÎ†• (0.1-1.0, Í∏∞Î≥∏Í∞í: 0.8)

Ï¢ÖÎ£åÌïòÎ†§Î©¥ 'quit' ÏûÖÎ†•

================================================================================
""")
    
    try:
        while True:
            print("\n" + "‚îÄ" * 50)
            
            # ÏÇ¨Ïö©Ïûê ÏûÖÎ†•
            symbol = input("üìä Ïã¨Î≥º (ÎòêÎäî 'quit'): ").strip().upper()
            if symbol.lower() == 'quit':
                break
            
            if symbol not in CONFIG.ALLOWED_SYMBOLS:
                print(f"‚ùå ÏßÄÏõêÌïòÏßÄ ÏïäÎäî Ïã¨Î≥ºÏûÖÎãàÎã§. ÏßÄÏõê Ïã¨Î≥º: {', '.join(CONFIG.ALLOWED_SYMBOLS[:5])}...")
                continue
            
            action = input("‚ö° Ïï°ÏÖò (buy/sell/long/short): ").strip().lower()
            if action not in ['buy', 'sell', 'long', 'short']:
                print("‚ùå Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ïï°ÏÖòÏûÖÎãàÎã§.")
                continue
            
            try:
                price = float(input("üí∞ Í∞ÄÍ≤©: "))
                confidence = float(input("üéØ Ïã†Î¢∞ÎèÑ (0.1-1.0, Í∏∞Î≥∏Í∞í 0.8): ") or "0.8")
                confidence = max(0.1, min(confidence, 1.0))
            except ValueError:
                print("‚ùå Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ Ïà´ÏûêÏûÖÎãàÎã§.")
                continue
            
            # Ïã†Ìò∏ Ï≤òÎ¶¨
            signal_data = {
                "symbol": symbol,
                "action": action,
                "price": price,
                "confidence": confidence,
                "account_balance": 10000.0
            }
            
            print(f"\nüîÑ Ï≤òÎ¶¨ Ï§ë...")
            
            try:
                result = asyncio.run(phoenix_system.process_signal(signal_data))
                
                print(f"\nüìã Í≤∞Í≥º:")
                print(f"ÏÉÅÌÉú: {result['status']}")
                
                if result['status'] == 'success':
                    trade = result['trade_result']
                    perf = result['performance']
                    
                    print(f"Phoenix 95 Ï†êÏàò: {trade['phoenix_95_score']:.1%}")
                    print(f"Ïã§Ìñâ ÏÉÅÌÉú: {trade['execution_status']}")
                    print(f"Ìè¨ÏßÄÏÖò ÌÅ¨Í∏∞: ${trade['leveraged_size']:,.0f}")
                    print(f"Ï≤òÎ¶¨ ÏãúÍ∞Ñ: {perf['processing_time_ms']:.1f}ms")
                    print(f"Ìó§ÏßÄÌéÄÎìúÍ∏â: {'‚úÖ' if perf['hedge_fund_grade'] else '‚ùå'}")
                    
                    if trade['execution_status'] == 'EXECUTED':
                        print(f"ÏÜêÏ†àÍ∞Ä: ${trade['stop_loss']:,.2f}")
                        print(f"ÏùµÏ†àÍ∞Ä: ${trade['take_profit']:,.2f}")
                    else:
                        print(f"Î≥¥Î•ò ÏÇ¨Ïú†: {trade['execution_reason']}")
                        
                elif result['status'] == 'rejected':
                    risk_check = result['risk_check']
                    print(f"Í±∞Ï†à ÏÇ¨Ïú†: {'; '.join(risk_check['checks'])}")
                    
                else:
                    print(f"Ïò§Î•ò: {result['message']}")
                    
            except Exception as e:
                print(f"‚ùå Ï≤òÎ¶¨ Ïò§Î•ò: {e}")
        
        print("\nüëã Îç∞Î™® Î™®Îìú Ï¢ÖÎ£å")
        
    except KeyboardInterrupt:
        print("\nüëã Îç∞Î™® Î™®Îìú Ï¢ÖÎ£å")
    except Exception as e:
        secure_logger.error(f"Îç∞Î™® Î™®Îìú Ïã§Ìñâ Ïò§Î•ò: {e}")

# =============================================================================
# üöÄ Main Function (Î©îÏù∏ Ìï®Ïàò)
# =============================================================================

def main():
    """Î©îÏù∏ Ïã§Ìñâ Ìï®Ïàò"""
    print("""
üè¶ Phoenix 95 Complete System v5.0 - ÏôÑÏ†Ñ ÌÜµÌï© Ìó§ÏßÄÌéÄÎìúÍ∏â ÏãúÏä§ÌÖú
================================================================================

üõ°Ô∏è ÏïàÏ†ÑÏÑ± Ïö∞ÏÑ† ÏÑ§Í≥Ñ + Í≥†Í∏â Í∏∞Îä•:
- ‚úÖ ÏùòÏ°¥ÏÑ± Ïò§Î•ò Î∞©ÏßÄ (ÏÑ†ÌÉùÏ†Å import + Í∏∞Î≥∏Í∞í)
- ‚úÖ Îü∞ÌÉÄÏûÑ Ïò§Î•ò Î∞©ÏßÄ (ÌÉÄÏûÖ ÏïàÏ†ÑÏÑ± + None Ï≤¥ÌÅ¨)  
- ‚úÖ Î©îÎ™®Î¶¨ ÏïàÏ†ÑÏÑ± (Ï∫êÏãú + ÏûêÎèô Ï†ïÎ¶¨ + GC)
- ‚úÖ ÏòàÏô∏ Ï≤òÎ¶¨ Í∞ïÌôî (Î™®Îì† Ìï®ÏàòÏóê try-catch)
- ‚úÖ ÏÑ§Ï†ï ÏïàÏ†ÑÏÑ± (ÌôòÍ≤ΩÎ≥ÄÏàò + Í∏∞Î≥∏Í∞í)
- ‚úÖ Î≥¥Ïïà Í∞êÏÇ¨ Î°úÍπÖ (ÎØºÍ∞êÏ†ïÎ≥¥ ÌïÑÌÑ∞ÎßÅ)
- ‚úÖ Î©ÄÌã∞Î™®Îìú Ïã§Ìñâ (SIMPLE/ADVANCED)

üíé 4ÎåÄ ÌïµÏã¨ Ïª¥Ìè¨ÎÑåÌä∏:
- üß† BRAIN: Signal Intelligence Engine (Phoenix 95 AI + Ï∫êÏãú)
- ‚öñÔ∏è RISK: Position & Risk Manager (Kelly + Ìó§ÏßÄÌéÄÎìúÍ∏â)
- ‚ö° EXECUTE: Trade Execution Engine (Ïã§ÏãúÍ∞Ñ + Ï°∞Í±¥Î∂Ä)  
- üì± NOTIFY: Alert & Monitor Hub (Î©ÄÌã∞Ï±ÑÎÑê + Î≥¥Ïïà)

================================================================================
""")
    
    if len(sys.argv) > 1:
        command = sys.argv[1].lower()
        
        if command == "--server":
            run_server_mode()
            
        elif command == "--test":
            print("üß™ Ï¢ÖÌï© ÌÖåÏä§Ìä∏ Î™®Îìú")
            asyncio.run(run_comprehensive_test())
            
        elif command == "--demo":
            run_demo_mode()
            
        elif command == "--simple":
            CONFIG.EXECUTION_MODE = "SIMPLE"
            run_simple_mode()
            
        elif command == "--advanced":
            CONFIG.EXECUTION_MODE = "ADVANCED"
            run_simple_mode()
            
        elif command == "--stats":
            print("üìä ÏãúÏä§ÌÖú ÌÜµÍ≥Ñ:")
            stats = phoenix_system.get_stats()
            for category, data in stats.items():
                print(f"\n{category.upper()}:")
                if isinstance(data, dict):
                    for key, value in data.items():
                        print(f"  {key}: {value}")
                else:
                    print(f"  {data}")
                    
        elif command == "--config":
            print("‚öôÔ∏è ÏãúÏä§ÌÖú ÏÑ§Ï†ï:")
            print(f"  Ïã§Ìñâ Î™®Îìú: {CONFIG.EXECUTION_MODE}")
            print(f"  Í±∞Îûò Î™®Îìú: {CONFIG.TRADE_MODE}")
            print(f"  Î†àÎ≤ÑÎ¶¨ÏßÄ: {CONFIG.LEVERAGE}x")
            print(f"  ÏµúÏÜå Ïã†Î¢∞ÎèÑ: {CONFIG.MIN_CONFIDENCE:.1%}")
            print(f"  ÏµúÎåÄ ÏùºÏùºÏÜêÏã§: {CONFIG.MAX_DAILY_LOSS:.1%}")
            print(f"  ÏµúÎåÄ Ìè¨ÏßÄÏÖò: {CONFIG.MAX_POSITIONS}")
            print(f"  ÏßÄÏõê Ïã¨Î≥º: {len(CONFIG.ALLOWED_SYMBOLS)}Í∞ú")
            print(f"  ÌÖîÎ†àÍ∑∏Îû®: {'‚úÖ' if CONFIG.TELEGRAM_CONFIG.get('enabled') else '‚ùå'}")
            
        elif command == "--help":
            print("""
üìã ÏÇ¨Ïö©Î≤ï:
  python phoenix95_complete.py [ÏòµÏÖò]

üéØ ÏòµÏÖò:
  --server      FastAPI ÏÑúÎ≤Ñ Ïã§Ìñâ (http://localhost:8000)
  --simple      Îã®Ïàú Î™®Îìú (Í∏∞Î≥∏ Í∏∞Îä•Îßå)
  --advanced    Í≥†Í∏â Î™®Îìú (Î™®Îì† Í∏∞Îä•)
  --test        Ï¢ÖÌï© ÌÖåÏä§Ìä∏ Ïã§Ìñâ
  --demo        ÎåÄÌôîÌòï Îç∞Î™® Î™®Îìú
  --stats       ÏãúÏä§ÌÖú ÌÜµÍ≥Ñ Ï°∞Ìöå
  --config      ÏÑ§Ï†ï Ï†ïÎ≥¥ Ï°∞Ìöå
  --help        ÎèÑÏõÄÎßê ÌëúÏãú

üîß ÌôòÍ≤ΩÎ≥ÄÏàò:
  PHOENIX_MODE=SIMPLE|ADVANCED  # Ïã§Ìñâ Î™®Îìú
  TRADE_MODE=TEST|LIVE          # Í±∞Îûò Î™®Îìú
  TELEGRAM_BOT_TOKEN=xxx        # ÌÖîÎ†àÍ∑∏Îû® ÌÜ†ÌÅ∞
  TELEGRAM_CHAT_ID=xxx          # ÌÖîÎ†àÍ∑∏Îû® Ï±ÑÌåÖ ID
  LEVERAGE=20                   # Î†àÎ≤ÑÎ¶¨ÏßÄ (Í∏∞Î≥∏: 20)
  MIN_CONFIDENCE=0.75           # ÏµúÏÜå Ïã†Î¢∞ÎèÑ (Í∏∞Î≥∏: 75%)

üí° ÏòàÏãú:
  python phoenix95_complete.py --server
  PHOENIX_MODE=ADVANCED python phoenix95_complete.py --demo
  TRADE_MODE=LIVE python phoenix95_complete.py --test
""")
            
        else:
            print(f"‚ùå Ïïå Ïàò ÏóÜÎäî Î™ÖÎ†πÏñ¥: {command}")
            print("ÎèÑÏõÄÎßê: python phoenix95_complete.py --help")
            
    else:
        # Í∏∞Î≥∏ Ïã§Ìñâ (ÌôòÍ≤ΩÏóê Îî∞Îùº ÏûêÎèô Í≤∞Ï†ï)
        if FASTAPI_AVAILABLE and CONFIG.EXECUTION_MODE == "ADVANCED":
            print("üöÄ ÏûêÎèô Î™®Îìú: FastAPI ÏÑúÎ≤Ñ Ïã§Ìñâ")
            run_server_mode()
        else:
            print("üöÄ ÏûêÎèô Î™®Îìú: Simple Î™®Îìú Ïã§Ìñâ")
            run_simple_mode()

if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\nüëã Phoenix 95 Complete System Ï¢ÖÎ£å")
        # ÏïàÏ†ÑÌïú Ï†ïÎ¶¨
        gc.collect()
    except Exception as e:
        secure_logger.error(f"‚ùå Ïã§Ìñâ Ïò§Î•ò: {e}")
        print(f"‚ùå ÏãúÏä§ÌÖú Ïã§Ìñâ Ïã§Ìå®: {e}")
        print("üí° ÏùòÏ°¥ÏÑ± ÏÑ§Ïπò: pip install fastapi uvicorn requests aiohttp psutil numpy")
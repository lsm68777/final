#!/usr/bin/env python3
"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Phoenix 95 Ultimate Trading System
    V3 ê²€ì¦ëœ ì•Œê³ ë¦¬ì¦˜ + V4 ê³ ê¸‰ ê¸°ëŠ¥ + í—¤ì§€í€ë“œê¸‰ ì•ˆì „ì„±
    
    ğŸ¯ ì™„ì „ í†µí•© ìµœì¢… ë²„ì „ - ëª¨ë“  ê¸°ëŠ¥ì„ í•˜ë‚˜ì˜ íŒŒì¼ì— í†µí•©
    ğŸ’° Wall Streetê¸‰ íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ
    âš¡ ì›í´ë¦­ ë°°í¬, ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§, ìë™ ë¦¬ìŠ¤í¬ ê´€ë¦¬
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import asyncio
import aiohttp
import aioredis
import asyncpg
import json
import time
import logging
import os
import sys
import uuid
import hmac
import hashlib
import secrets
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict, field
from typing import Dict, List, Optional, Tuple, Any
from decimal import Decimal
from collections import deque
import numpy as np
import pandas as pd
from fastapi import FastAPI, HTTPException, BackgroundTasks, Depends, Security, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field
import uvicorn
from contextlib import asynccontextmanager

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ”§ ì‹œìŠ¤í…œ ì„¤ì •
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SystemConfig:
    """Phoenix 95 Ultimate í†µí•© ì„¤ì •"""
    
    # ğŸ¯ í•µì‹¬ í…”ë ˆê·¸ë¨ ì„¤ì • (ê¸°ì¡´ V3 ì—°ê³„)
    TELEGRAM = {
        "bot_token": "7386542811:AAEZ21p30rES1k8NxNM2xbZ53U44PI9D5CY",
        "chat_id": "7590895952",
        "alerts": {
            "trade_execution": True,
            "position_updates": True, 
            "system_errors": True,
            "performance_reports": True,
            "liquidation_warnings": True,
            "daily_summary": True
        }
    }
    
    # ğŸ’° í—¤ì§€í€ë“œê¸‰ íŠ¸ë ˆì´ë”© ì„¤ì • (ë³´ìˆ˜ì  ì ‘ê·¼)
    TRADING = {
        "max_leverage": 10,  # V4ì—ì„œ 20x â†’ 10xë¡œ ì•ˆì „ì„± ê°•í™”
        "margin_mode": "ISOLATED",
        "position_size_pct": 0.02,  # ì „ì²´ ìë³¸ì˜ 2%ë§Œ ë¦¬ìŠ¤í¬
        "stop_loss_pct": 0.015,     # 1.5% ì†ì ˆ
        "take_profit_pct": 0.03,    # 3% ìµì ˆ (R:R = 1:2)
        "max_daily_loss": 1000,     # ì¼ì¼ ìµœëŒ€ ì†ì‹¤ $1000
        "max_positions": 3,         # ìµœëŒ€ 3ê°œ í¬ì§€ì…˜
        "confidence_threshold": 0.85, # 85% ì´ìƒë§Œ ê±°ë˜
        "kelly_max": 0.25,          # Kelly ìµœëŒ€ 25%
        "allowed_symbols": [
            "BTCUSDT", "ETHUSDT", "ADAUSDT", "SOLUSDT", "AVAXUSDT",
            "DOTUSDT", "LINKUSDT", "MATICUSDT", "ATOMUSDT", "NEARUSDT"
        ]
    }
    
    # ğŸ§  Phoenix 95 AI ì—”ì§„ ì„¤ì • (V3 ê²€ì¦ëœ íŒŒë¼ë¯¸í„°)
    PHOENIX95 = {
        "confidence_multiplier": 1.15,  # V3ì—ì„œ ìµœì í™”ëœ ê°’
        "market_condition_weight": 0.3,
        "ensemble_weights": {
            "phoenix95": 0.6,
            "lstm": 0.25, 
            "transformer": 0.15
        },
        "analysis_timeout": 2.0,  # 2ì´ˆ ì´ë‚´ ë¶„ì„ ë³´ì¥
        "min_confidence": 0.7,
        "max_confidence": 0.99
    }
    
    # ğŸ’¾ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
    DATABASE = {
        "redis_url": os.getenv("REDIS_URL", "redis://localhost:6379"),
        "postgres_url": os.getenv("POSTGRES_URL", "postgresql://postgres:password@localhost:5432/phoenix95"),
        "connection_pool_size": 20,
        "max_connections": 100
    }
    
    # ğŸ”’ ë³´ì•ˆ ì„¤ì •
    SECURITY = {
        "webhook_secret": os.getenv("WEBHOOK_SECRET", "phoenix95_ultimate_secret"),
        "api_key": os.getenv("API_KEY", secrets.token_urlsafe(32)),
        "jwt_secret": os.getenv("JWT_SECRET", secrets.token_urlsafe(32)),
        "allowed_ips": ["127.0.0.1", "localhost"],
        "rate_limit": 60  # ë¶„ë‹¹ 60íšŒ
    }
    
    # ğŸ“Š ëª¨ë‹ˆí„°ë§ ì„¤ì •
    MONITORING = {
        "metrics_interval": 30,    # 30ì´ˆë§ˆë‹¤ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
        "health_check_interval": 10,
        "alert_cooldown": 300,     # 5ë¶„ ì•Œë¦¼ ì¿¨ë‹¤ìš´
        "performance_threshold": {
            "response_time_ms": 2000,
            "error_rate_pct": 5,
            "memory_usage_pct": 85,
            "cpu_usage_pct": 80
        }
    }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“Š ë°ì´í„° ëª¨ë¸
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class TradingSignal:
    """íŠ¸ë ˆì´ë”© ì‹ í˜¸ - V3/V4 í†µí•© ëª¨ë¸"""
    signal_id: str
    symbol: str
    action: str  # buy/sell
    price: float
    confidence: float
    timestamp: datetime
    
    # Phoenix 95 ë¶„ì„ ê²°ê³¼
    phoenix95_score: Optional[float] = None
    kelly_ratio: Optional[float] = None
    recommendation: Optional[str] = None
    
    # ì‹œì¥ ë°ì´í„°
    market_conditions: Optional[Dict] = None
    technical_indicators: Optional[Dict] = None
    
    # ì²˜ë¦¬ ìƒíƒœ
    processed: bool = False
    error_message: Optional[str] = None
    
    def is_valid(self) -> bool:
        """ì‹ í˜¸ ìœ íš¨ì„± ê²€ì¦"""
        return (
            self.symbol in SystemConfig.TRADING["allowed_symbols"] and
            self.action.lower() in ["buy", "sell"] and
            self.price > 0 and
            0.0 <= self.confidence <= 1.0 and
            self.confidence >= SystemConfig.TRADING["confidence_threshold"]
        )
    
    def to_dict(self) -> Dict:
        """ë”•ì…”ë„ˆë¦¬ ë³€í™˜"""
        return {
            "signal_id": self.signal_id,
            "symbol": self.symbol,
            "action": self.action,
            "price": self.price,
            "confidence": self.confidence,
            "phoenix95_score": self.phoenix95_score,
            "kelly_ratio": self.kelly_ratio,
            "recommendation": self.recommendation,
            "timestamp": self.timestamp.isoformat(),
            "processed": self.processed
        }

@dataclass  
class Position:
    """í¬ì§€ì…˜ - ì™„ì „ í†µí•© ëª¨ë¸"""
    position_id: str
    signal_id: str
    symbol: str
    side: str  # BUY/SELL
    
    # í¬ì§€ì…˜ ì •ë³´
    entry_price: float
    quantity: float
    leverage: int
    margin_mode: str
    margin_required: float
    
    # ë¦¬ìŠ¤í¬ ê´€ë¦¬
    liquidation_price: float
    stop_loss_price: float
    take_profit_price: float
    
    # ì‹¤ì‹œê°„ ë°ì´í„°
    current_price: float = 0.0
    unrealized_pnl: float = 0.0
    pnl_percentage: float = 0.0
    liquidation_risk: float = 0.0
    
    # ìƒíƒœ
    status: str = "OPEN"  # OPEN/CLOSED/LIQUIDATED
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)
    
    # ì²­ì‚° ì •ë³´
    exit_price: Optional[float] = None
    exit_time: Optional[datetime] = None
    exit_reason: Optional[str] = None
    realized_pnl: Optional[float] = None
    
    def calculate_pnl(self, current_price: float) -> Tuple[float, float]:
        """P&L ê³„ì‚°"""
        if self.side == "BUY":
            pnl = (current_price - self.entry_price) * self.quantity
        else:
            pnl = (self.entry_price - current_price) * self.quantity
        
        pnl_pct = (pnl / self.margin_required) * 100 if self.margin_required > 0 else 0
        return pnl, pnl_pct
    
    def calculate_liquidation_risk(self, current_price: float) -> float:
        """ì²­ì‚° ìœ„í—˜ë„ ê³„ì‚° (0-1)"""
        if self.side == "BUY":
            distance = current_price - self.liquidation_price
            max_distance = self.entry_price - self.liquidation_price
        else:
            distance = self.liquidation_price - current_price  
            max_distance = self.liquidation_price - self.entry_price
        
        if max_distance <= 0:
            return 1.0
        
        risk = 1 - (distance / max_distance)
        return max(0.0, min(1.0, risk))

@dataclass
class PerformanceMetrics:
    """ì„±ëŠ¥ ë©”íŠ¸ë¦­"""
    timestamp: datetime
    
    # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­
    cpu_usage: float
    memory_usage: float  
    response_time_ms: float
    active_connections: int
    
    # íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­
    active_positions: int
    total_pnl: float
    win_rate: float
    avg_trade_duration: float
    phoenix95_avg_score: float
    
    # ë¦¬ìŠ¤í¬ ë©”íŠ¸ë¦­
    max_drawdown: float
    var_95: float  # Value at Risk
    sharpe_ratio: float

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ§  Phoenix 95 AI ì—”ì§„
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Phoenix95AIEngine:
    """Phoenix 95 Ultimate AI ì—”ì§„ - V3 ê²€ì¦ + V4 ê³ ë„í™”"""
    
    def __init__(self):
        self.config = SystemConfig.PHOENIX95
        self.analysis_cache = {}
        self.model_performance = deque(maxlen=1000)
        
        # V3ì—ì„œ ê²€ì¦ëœ íŒŒë¼ë¯¸í„°
        self.confidence_multiplier = self.config["confidence_multiplier"]
        self.market_weight = self.config["market_condition_weight"]
        
    async def analyze_signal_complete(self, signal: TradingSignal) -> Tuple[float, float, str]:
        """
        ì™„ì „ ì‹ í˜¸ ë¶„ì„ - V3 ì•Œê³ ë¦¬ì¦˜ + V4 ê³ ë„í™”
        Returns: (phoenix95_score, kelly_ratio, recommendation)
        """
        start_time = time.time()
        
        try:
            # 1. ìºì‹œ í™•ì¸
            cache_key = f"{signal.symbol}_{signal.price}_{signal.confidence}"
            if cache_key in self.analysis_cache:
                cached = self.analysis_cache[cache_key]
                if (datetime.utcnow() - cached['timestamp']).seconds < 300:  # 5ë¶„ ìºì‹œ
                    return cached['result']
            
            # 2. V3 ê²€ì¦ëœ Phoenix 95 í•µì‹¬ ë¶„ì„
            phoenix95_score = await self._phoenix95_core_analysis(signal)
            
            # 3. V4 ì•™ìƒë¸” ëª¨ë¸ ë¶„ì„
            ensemble_boost = await self._ensemble_analysis(signal)
            phoenix95_score = min(phoenix95_score * ensemble_boost, self.config["max_confidence"])
            
            # 4. ì‹œì¥ ì¡°ê±´ íŒ©í„°
            market_factor = await self._analyze_market_conditions(signal.symbol)
            phoenix95_score *= market_factor
            
            # 5. Kelly Criterion ê³„ì‚° (V3 ê²€ì¦ëœ ê³µì‹)
            kelly_ratio = await self._calculate_kelly_criterion(phoenix95_score)
            
            # 6. ìµœì¢… ì¶”ì²œ ìƒì„±
            recommendation = await self._generate_recommendation(phoenix95_score, kelly_ratio)
            
            # 7. ë¶„ì„ ì‹œê°„ ê²€ì¦
            analysis_time = time.time() - start_time
            if analysis_time > self.config["analysis_timeout"]:
                logging.warning(f"Phoenix95 ë¶„ì„ ì‹œê°„ ì´ˆê³¼: {analysis_time:.2f}ì´ˆ")
            
            # 8. ê²°ê³¼ ìºì‹±
            result = (phoenix95_score, kelly_ratio, recommendation)
            self.analysis_cache[cache_key] = {
                'result': result,
                'timestamp': datetime.utcnow()
            }
            
            # 9. ì„±ëŠ¥ ì¶”ì 
            self.model_performance.append({
                'score': phoenix95_score,
                'analysis_time': analysis_time,
                'timestamp': datetime.utcnow()
            })
            
            return result
            
        except Exception as e:
            logging.error(f"Phoenix95 ë¶„ì„ ì‹¤íŒ¨: {e}")
            return 0.0, 0.0, "REJECT"
    
    async def _phoenix95_core_analysis(self, signal: TradingSignal) -> float:
        """Phoenix 95 í•µì‹¬ ë¶„ì„ ì•Œê³ ë¦¬ì¦˜ - V3 ê²€ì¦ëœ ë¡œì§"""
        base_confidence = signal.confidence
        
        # V3ì—ì„œ ê²€ì¦ëœ ì‹ ë¢°ë„ ë¶€ìŠ¤íŒ…
        boosted_confidence = base_confidence * self.confidence_multiplier
        
        # ì‹œê°„ëŒ€ë³„ ê°€ì¤‘ì¹˜ (V3 íŒ¨í„´)
        hour = datetime.utcnow().hour
        time_weight = 1.0
        if 8 <= hour <= 16:  # ìœ ëŸ½ ì‹œê°„
            time_weight = 1.1
        elif 21 <= hour <= 5:  # ë¯¸êµ­ ì‹œê°„  
            time_weight = 1.05
        
        # ì‹¬ë³¼ë³„ ê°€ì¤‘ì¹˜
        symbol_weights = {
            "BTCUSDT": 1.0,
            "ETHUSDT": 0.95,
            "ADAUSDT": 0.9,
            "SOLUSDT": 0.9
        }
        symbol_weight = symbol_weights.get(signal.symbol, 0.85)
        
        # ìµœì¢… Phoenix 95 ì ìˆ˜
        phoenix95_score = boosted_confidence * time_weight * symbol_weight
        return min(phoenix95_score, self.config["max_confidence"])
    
    async def _ensemble_analysis(self, signal: TradingSignal) -> float:
        """ì•™ìƒë¸” ëª¨ë¸ ë¶„ì„ - V4 ê³ ë„í™”"""
        weights = self.config["ensemble_weights"]
        
        # LSTM ì˜ˆì¸¡ ì‹œë®¬ë ˆì´ì…˜
        lstm_score = min(signal.confidence * 1.05, 1.0)
        
        # Transformer ì˜ˆì¸¡ ì‹œë®¬ë ˆì´ì…˜  
        transformer_score = min(signal.confidence * 1.08, 1.0)
        
        # ê°€ì¤‘ í‰ê· ìœ¼ë¡œ ë¶€ìŠ¤íŠ¸ íŒ©í„° ê³„ì‚°
        ensemble_score = (
            weights["phoenix95"] * signal.confidence +
            weights["lstm"] * lstm_score +
            weights["transformer"] * transformer_score
        )
        
        # ë¶€ìŠ¤íŠ¸ íŒ©í„° ë°˜í™˜ (1.0 = ë³€í™”ì—†ìŒ, 1.1 = 10% ì¦ê°€)
        boost_factor = ensemble_score / signal.confidence if signal.confidence > 0 else 1.0
        return min(boost_factor, 1.15)  # ìµœëŒ€ 15% ë¶€ìŠ¤íŠ¸
    
    async def _analyze_market_conditions(self, symbol: str) -> float:
        """ì‹œì¥ ì¡°ê±´ ë¶„ì„"""
        try:
            # ì‹¤ì œë¡œëŠ” Binance APIì—ì„œ ë°ì´í„° ìˆ˜ì§‘
            # ì—¬ê¸°ì„œëŠ” ì‹œê°„ ê¸°ë°˜ ê°„ë‹¨í•œ ì‹œë®¬ë ˆì´ì…˜
            hour = datetime.utcnow().hour
            
            # ê±°ë˜ëŸ‰ í™œë°œí•œ ì‹œê°„ëŒ€
            if 8 <= hour <= 16 or 21 <= hour <= 23:
                return 1.1
            elif 2 <= hour <= 6:  # ì €ì¡°í•œ ì‹œê°„ëŒ€
                return 0.9
            else:
                return 1.0
                
        except Exception as e:
            logging.error(f"ì‹œì¥ ì¡°ê±´ ë¶„ì„ ì‹¤íŒ¨: {e}")
            return 1.0
    
    async def _calculate_kelly_criterion(self, phoenix95_score: float) -> float:
        """Kelly Criterion ê³„ì‚° - V3 ê²€ì¦ëœ ê³µì‹"""
        # ìŠ¹ë¥  ì¶”ì • (Phoenix 95 ì ìˆ˜ ê¸°ë°˜)
        win_probability = phoenix95_score
        
        # ì†ìµ ë¹„ìœ¨ (ì†ì ˆ 1.5% vs ìµì ˆ 3% = 1:2)
        win_loss_ratio = SystemConfig.TRADING["take_profit_pct"] / SystemConfig.TRADING["stop_loss_pct"]
        
        # Kelly Formula: (bp - q) / b
        # b = ì†ìµë¹„ìœ¨, p = ìŠ¹ë¥ , q = íŒ¨ë°°ìœ¨
        kelly_ratio = (win_probability * win_loss_ratio - (1 - win_probability)) / win_loss_ratio
        
        # ë³´ìˆ˜ì  ì œí•œ (ìµœëŒ€ 25%)
        kelly_ratio = max(0.01, min(kelly_ratio, SystemConfig.TRADING["kelly_max"]))
        
        return kelly_ratio
    
    async def _generate_recommendation(self, phoenix95_score: float, kelly_ratio: float) -> str:
        """ìµœì¢… ì¶”ì²œ ìƒì„±"""
        if phoenix95_score >= 0.95 and kelly_ratio >= 0.2:
            return "STRONG_BUY"
        elif phoenix95_score >= 0.85 and kelly_ratio >= 0.15:
            return "BUY"
        elif phoenix95_score >= 0.75 and kelly_ratio >= 0.1:
            return "WEAK_BUY"
        elif phoenix95_score >= 0.6:
            return "HOLD"
        else:
            return "REJECT"
    
    def get_performance_stats(self) -> Dict:
        """ëª¨ë¸ ì„±ëŠ¥ í†µê³„"""
        if not self.model_performance:
            return {}
        
        scores = [p['score'] for p in self.model_performance]
        times = [p['analysis_time'] for p in self.model_performance]
        
        return {
            "avg_score": np.mean(scores),
            "score_std": np.std(scores),
            "avg_analysis_time": np.mean(times),
            "max_analysis_time": np.max(times),
            "total_analyses": len(self.model_performance)
        }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              âš¡ ë ˆë²„ë¦¬ì§€ íŠ¸ë ˆì´ë”© ì—”ì§„
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class UltimateLeverageTrader:
    """Ultimate ë ˆë²„ë¦¬ì§€ íŠ¸ë ˆì´ë”© ì—”ì§„ - V3 ì•ˆì •ì„± + V4 ê³ ë„í™”"""
    
    def __init__(self, redis_client, postgres_pool, telegram_notifier):
        self.redis = redis_client
        self.postgres = postgres_pool
        self.telegram = telegram_notifier
        self.active_positions: Dict[str, Position] = {}
        self.monitoring_tasks: Dict[str, asyncio.Task] = {}
        self.risk_metrics = deque(maxlen=1000)
        
    async def execute_trade_complete(self, signal: TradingSignal, 
                                   phoenix95_score: float, 
                                   kelly_ratio: float) -> Optional[Position]:
        """ì™„ì „í•œ ê±°ë˜ ì‹¤í–‰ - 500ms ì´ë‚´ ë³´ì¥"""
        execution_start = time.time()
        
        try:
            # 1. ì¢…í•© ë¦¬ìŠ¤í¬ ì²´í¬
            risk_check = await self._comprehensive_risk_check(signal)
            if not risk_check["approved"]:
                logging.warning(f"ë¦¬ìŠ¤í¬ ì²´í¬ ì‹¤íŒ¨: {risk_check['reason']}")
                await self.telegram.send_message(f"âš ï¸ ê±°ë˜ ê±°ë¶€: {risk_check['reason']}")
                return None
            
            # 2. í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° (Kelly + ë¦¬ìŠ¤í¬ ì¡°ì •)
            position_size_usd = await self._calculate_optimal_position_size(kelly_ratio, signal)
            
            # 3. ë ˆë²„ë¦¬ì§€ ê³„ì‚°
            leverage = await self._calculate_optimal_leverage(phoenix95_score)
            
            # 4. ìˆ˜ëŸ‰ ë° ë§ˆì§„ ê³„ì‚°
            quantity = position_size_usd / signal.price
            margin_required = position_size_usd / leverage
            
            # 5. ë¦¬ìŠ¤í¬ ê°€ê²© ê³„ì‚°
            liquidation_price = self._calculate_liquidation_price(signal, leverage)
            stop_loss_price = self._calculate_stop_loss_price(signal)
            take_profit_price = self._calculate_take_profit_price(signal)
            
            # 6. í¬ì§€ì…˜ ê°ì²´ ìƒì„±
            position = Position(
                position_id=f"POS_{uuid.uuid4().hex[:8].upper()}",
                signal_id=signal.signal_id,
                symbol=signal.symbol,
                side=signal.action.upper(),
                entry_price=signal.price,
                quantity=quantity,
                leverage=leverage,
                margin_mode=SystemConfig.TRADING["margin_mode"],
                margin_required=margin_required,
                liquidation_price=liquidation_price,
                stop_loss_price=stop_loss_price,
                take_profit_price=take_profit_price,
                current_price=signal.price
            )
            
            # 7. ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥
            await self._save_position_to_db(position)
            await self._save_signal_to_db(signal)
            
            # 8. ë©”ëª¨ë¦¬ì— í¬ì§€ì…˜ ì¶”ê°€
            self.active_positions[position.position_id] = position
            
            # 9. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œì‘
            await self._start_position_monitoring(position)
            
            # 10. ì‹¤í–‰ ì‹œê°„ ê²€ì¦
            execution_time = (time.time() - execution_start) * 1000
            if execution_time > 500:
                logging.warning(f"ê±°ë˜ ì‹¤í–‰ ì‹œê°„ ì´ˆê³¼: {execution_time:.0f}ms")
            
            # 11. ì„±ê³µ ì•Œë¦¼
            await self.telegram.send_trade_notification(position, phoenix95_score, kelly_ratio)
            
            logging.info(f"ê±°ë˜ ì‹¤í–‰ ì™„ë£Œ: {position.position_id} ({execution_time:.0f}ms)")
            return position
            
        except Exception as e:
            logging.error(f"ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
            await self.telegram.send_message(f"ğŸš¨ ê±°ë˜ ì‹¤í–‰ ì˜¤ë¥˜: {str(e)}")
            return None
    
    async def _comprehensive_risk_check(self, signal: TradingSignal) -> Dict:
        """ì¢…í•© ë¦¬ìŠ¤í¬ ì²´í¬"""
        risk_factors = []
        
        # 1. ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ì²´í¬
        if len(self.active_positions) >= SystemConfig.TRADING["max_positions"]:
            return {"approved": False, "reason": "ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ì´ˆê³¼"}
        
        # 2. ì¼ì¼ ì†ì‹¤ í•œë„ ì²´í¬
        daily_pnl = await self._get_daily_pnl()
        if daily_pnl <= -SystemConfig.TRADING["max_daily_loss"]:
            return {"approved": False, "reason": "ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼"}
        
        # 3. ì‹¬ë³¼ ì¤‘ë³µ ì²´í¬  
        symbol_positions = [p for p in self.active_positions.values() if p.symbol == signal.symbol]
        if len(symbol_positions) >= 1:  # ì‹¬ë³¼ë‹¹ 1ê°œë§Œ
            return {"approved": False, "reason": f"{signal.symbol} í¬ì§€ì…˜ ì´ë¯¸ ì¡´ì¬"}
        
        # 4. ì‹œì¥ ì‹œê°„ ì²´í¬
        now = datetime.utcnow()
        if now.weekday() >= 5:  # ì£¼ë§
            return {"approved": False, "reason": "ì£¼ë§ ê±°ë˜ ê¸ˆì§€"}
        
        # 5. ì‹ ë¢°ë„ ì¬í™•ì¸
        if signal.phoenix95_score and signal.phoenix95_score < SystemConfig.TRADING["confidence_threshold"]:
            risk_factors.append("ë‚®ì€ ì‹ ë¢°ë„")
        
        # 6. ë³€ë™ì„± ì²´í¬ (ê°„ë‹¨í•œ êµ¬í˜„)
        volatility_risk = await self._check_volatility_risk(signal.symbol)
        if volatility_risk > 0.8:
            risk_factors.append("ë†’ì€ ë³€ë™ì„±")
        
        risk_score = len(risk_factors) / 6  # ì •ê·œí™”
        
        return {
            "approved": risk_score < 0.5,
            "reason": "ë¦¬ìŠ¤í¬ ì²´í¬ í†µê³¼" if risk_score < 0.5 else f"ìœ„í—˜ ìš”ì†Œ: {', '.join(risk_factors)}",
            "risk_score": risk_score,
            "risk_factors": risk_factors
        }
    
    async def _calculate_optimal_position_size(self, kelly_ratio: float, signal: TradingSignal) -> float:
        """ìµœì  í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°"""
        # ê³„ì¢Œ ì”ê³  (ì‹¤ì œë¡œëŠ” ê±°ë˜ì†Œ APIì—ì„œ ì¡°íšŒ)
        account_balance = float(os.getenv("ACCOUNT_BALANCE", "50000"))
        
        # Kelly ê¸°ë°˜ ê¸°ë³¸ í¬ì§€ì…˜ í¬ê¸°
        kelly_position = account_balance * kelly_ratio
        
        # ì„¤ì •ëœ ìµœëŒ€ í¬ì§€ì…˜ í¬ê¸° ì œí•œ
        max_position_size = account_balance * SystemConfig.TRADING["position_size_pct"]
        
        # ìµœì¢… í¬ì§€ì…˜ í¬ê¸° (ë³´ìˆ˜ì  ì ‘ê·¼)
        position_size = min(kelly_position, max_position_size)
        
        # ìµœì†Œ/ìµœëŒ€ ì œí•œ
        min_position = 100.0  # ìµœì†Œ $100
        max_position = 10000.0  # ìµœëŒ€ $10,000
        
        return max(min_position, min(position_size, max_position))
    
    async def _calculate_optimal_leverage(self, phoenix95_score: float) -> int:
        """ìµœì  ë ˆë²„ë¦¬ì§€ ê³„ì‚°"""
        max_leverage = SystemConfig.TRADING["max_leverage"]
        
        # ì‹ ë¢°ë„ ê¸°ë°˜ ë ˆë²„ë¦¬ì§€ ì¡°ì •
        if phoenix95_score >= 0.95:
            return max_leverage
        elif phoenix95_score >= 0.9:
            return min(8, max_leverage)
        elif phoenix95_score >= 0.85:
            return min(5, max_leverage)
        else:
            return min(3, max_leverage)
    
    def _calculate_liquidation_price(self, signal: TradingSignal, leverage: int) -> float:
        """ì²­ì‚°ê°€ ê³„ì‚°"""
        maintenance_margin_rate = 0.004  # 0.4%
        
        if signal.action.lower() == "buy":
            return signal.price * (1 - (1/leverage) + maintenance_margin_rate)
        else:
            return signal.price * (1 + (1/leverage) - maintenance_margin_rate)
    
    def _calculate_stop_loss_price(self, signal: TradingSignal) -> float:
        """ì†ì ˆê°€ ê³„ì‚°"""
        stop_pct = SystemConfig.TRADING["stop_loss_pct"]
        
        if signal.action.lower() == "buy":
            return signal.price * (1 - stop_pct)
        else:
            return signal.price * (1 + stop_pct)
    
    def _calculate_take_profit_price(self, signal: TradingSignal) -> float:
        """ìµì ˆê°€ ê³„ì‚°"""
        profit_pct = SystemConfig.TRADING["take_profit_pct"]
        
        if signal.action.lower() == "buy":
            return signal.price * (1 + profit_pct)
        else:
            return signal.price * (1 - profit_pct)
    
    async def _start_position_monitoring(self, position: Position):
        """ì‹¤ì‹œê°„ í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        task = asyncio.create_task(self._monitor_position_realtime(position))
        self.monitoring_tasks[position.position_id] = task
        
        # Redisì— í¬ì§€ì…˜ ì •ë³´ ì €ì¥
        await self.redis.hset(
            f"position:{position.position_id}",
            mapping={
                "symbol": position.symbol,
                "side": position.side,
                "entry_price": position.entry_price,
                "quantity": position.quantity,
                "leverage": position.leverage,
                "status": position.status,
                "created_at": position.created_at.isoformat()
            }
        )
    
    async def _monitor_position_realtime(self, position: Position):
        """ì‹¤ì‹œê°„ í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§"""
        logging.info(f"í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì‹œì‘: {position.position_id}")
        
        while position.status == "OPEN":
            try:
                # í˜„ì¬ê°€ ì¡°íšŒ
                current_price = await self._get_current_price(position.symbol)
                position.current_price = current_price
                
                # P&L ê³„ì‚°
                pnl, pnl_pct = position.calculate_pnl(current_price)
                position.unrealized_pnl = pnl
                position.pnl_percentage = pnl_pct
                
                # ì²­ì‚° ìœ„í—˜ë„ ê³„ì‚°
                risk = position.calculate_liquidation_risk(current_price)
                position.liquidation_risk = risk
                
                # ì¢…ë£Œ ì¡°ê±´ ì²´í¬
                exit_reason = await self._check_exit_conditions(position, current_price)
                if exit_reason:
                    await self._close_position(position, current_price, exit_reason)
                    break
                
                # Redis ì—…ë°ì´íŠ¸
                await self.redis.hset(
                    f"position:{position.position_id}",
                    mapping={
                        "current_price": current_price,
                        "unrealized_pnl": pnl,
                        "pnl_percentage": pnl_pct,
                        "liquidation_risk": risk,
                        "updated_at": datetime.utcnow().isoformat()
                    }
                )
                
                # ìœ„í—˜ ì•Œë¦¼ ì²´í¬
                if risk > 0.8:
                    await self.telegram.send_liquidation_warning(position)
                
                await asyncio.sleep(1)  # 1ì´ˆë§ˆë‹¤ ì²´í¬
                
            except Exception as e:
                logging.error(f"í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜ {position.position_id}: {e}")
                await asyncio.sleep(5)
        
        # ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì •ë¦¬
        if position.position_id in self.monitoring_tasks:
            del self.monitoring_tasks[position.position_id]
    
    async def _get_current_price(self, symbol: str) -> float:
        """í˜„ì¬ê°€ ì¡°íšŒ (ì‹œë®¬ë ˆì´ì…˜)"""
        # ì‹¤ì œë¡œëŠ” Binance API í˜¸ì¶œ
        base_prices = {
            "BTCUSDT": 45000, "ETHUSDT": 3000, "ADAUSDT": 0.5,
            "SOLUSDT": 100, "AVAXUSDT": 40, "DOTUSDT": 8
        }
        
        base_price = base_prices.get(symbol, 45000)
        
        # ê°„ë‹¨í•œ ê°€ê²© ë³€ë™ ì‹œë®¬ë ˆì´ì…˜ (ì‹¤ì œë¡œëŠ” ì‹¤ì‹œê°„ ë°ì´í„°)
        import random
        change = random.uniform(-0.01, 0.01)  # Â±1% ë³€ë™
        return base_price * (1 + change)
    
    async def _check_exit_conditions(self, position: Position, current_price: float) -> Optional[str]:
        """í¬ì§€ì…˜ ì¢…ë£Œ ì¡°ê±´ ì²´í¬"""
        # ì†ì ˆê°€ ì²´í¬
        if position.side == "BUY" and current_price <= position.stop_loss_price:
            return "STOP_LOSS"
        if position.side == "SELL" and current_price >= position.stop_loss_price:
            return "STOP_LOSS"
        
        # ìµì ˆê°€ ì²´í¬  
        if position.side == "BUY" and current_price >= position.take_profit_price:
            return "TAKE_PROFIT"
        if position.side == "SELL" and current_price <= position.take_profit_price:
            return "TAKE_PROFIT"
        
        # ê¸´ê¸‰ ì²­ì‚° ì²´í¬ (ì²­ì‚°ê°€ 5% ì´ë‚´ ì ‘ê·¼)
        if position.liquidation_risk > 0.95:
            return "EMERGENCY_LIQUIDATION"
        
        return None
    
    async def _close_position(self, position: Position, exit_price: float, exit_reason: str):
        """í¬ì§€ì…˜ ì²­ì‚°"""
        position.status = "CLOSED"
        position.exit_price = exit_price
        position.exit_time = datetime.utcnow()
        position.exit_reason = exit_reason
        
        # ìµœì¢… P&L ê³„ì‚°
        final_pnl, final_pnl_pct = position.calculate_pnl(exit_price)
        position.realized_pnl = final_pnl
        
        # ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸
        await self._update_position_in_db(position)
        await self._save_trade_history(position)
        
        # ë©”ëª¨ë¦¬ì—ì„œ ì œê±°
        if position.position_id in self.active_positions:
            del self.active_positions[position.position_id]
        
        # Redis ì •ë¦¬
        await self.redis.delete(f"position:{position.position_id}")
        
        # ì²­ì‚° ì•Œë¦¼
        await self.telegram.send_close_notification(position, exit_reason)
        
        logging.info(f"í¬ì§€ì…˜ ì²­ì‚° ì™„ë£Œ: {position.position_id} | P&L: ${final_pnl:.2f} | ì‚¬ìœ : {exit_reason}")
    
    async def _save_position_to_db(self, position: Position):
        """í¬ì§€ì…˜ DB ì €ì¥"""
        try:
            async with self.postgres.acquire() as conn:
                await conn.execute("""
                    INSERT INTO positions (
                        position_id, signal_id, symbol, side, entry_price, quantity,
                        leverage, margin_mode, margin_required, liquidation_price,
                        stop_loss_price, take_profit_price, status, created_at
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
                """, position.position_id, position.signal_id, position.symbol, position.side,
                position.entry_price, position.quantity, position.leverage, position.margin_mode,
                position.margin_required, position.liquidation_price, position.stop_loss_price,
                position.take_profit_price, position.status, position.created_at)
        except Exception as e:
            logging.error(f"í¬ì§€ì…˜ DB ì €ì¥ ì‹¤íŒ¨: {e}")
    
    async def _save_signal_to_db(self, signal: TradingSignal):
        """ì‹ í˜¸ DB ì €ì¥"""
        try:
            async with self.postgres.acquire() as conn:
                await conn.execute("""
                    INSERT INTO signals (
                        signal_id, symbol, action, price, confidence, phoenix95_score,
                        kelly_ratio, recommendation, timestamp, processed
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                """, signal.signal_id, signal.symbol, signal.action, signal.price,
                signal.confidence, signal.phoenix95_score, signal.kelly_ratio,
                signal.recommendation, signal.timestamp, signal.processed)
        except Exception as e:
            logging.error(f"ì‹ í˜¸ DB ì €ì¥ ì‹¤íŒ¨: {e}")
    
    async def _update_position_in_db(self, position: Position):
        """í¬ì§€ì…˜ DB ì—…ë°ì´íŠ¸"""
        try:
            async with self.postgres.acquire() as conn:
                await conn.execute("""
                    UPDATE positions SET
                        current_price = $1, unrealized_pnl = $2, pnl_percentage = $3,
                        liquidation_risk = $4, status = $5, exit_price = $6,
                        exit_time = $7, exit_reason = $8, realized_pnl = $9, updated_at = $10
                    WHERE position_id = $11
                """, position.current_price, position.unrealized_pnl, position.pnl_percentage,
                position.liquidation_risk, position.status, position.exit_price,
                position.exit_time, position.exit_reason, position.realized_pnl,
                position.updated_at, position.position_id)
        except Exception as e:
            logging.error(f"í¬ì§€ì…˜ DB ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    
    async def _save_trade_history(self, position: Position):
        """ê±°ë˜ ì´ë ¥ ì €ì¥"""
        try:
            duration_minutes = 0
            if position.exit_time and position.created_at:
                duration_minutes = int((position.exit_time - position.created_at).total_seconds() / 60)
            
            async with self.postgres.acquire() as conn:
                await conn.execute("""
                    INSERT INTO trade_history (
                        position_id, symbol, side, entry_price, exit_price, quantity,
                        leverage, pnl, pnl_percentage, duration_minutes, entry_time,
                        exit_time, exit_reason
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
                """, position.position_id, position.symbol, position.side, position.entry_price,
                position.exit_price, position.quantity, position.leverage, position.realized_pnl,
                position.pnl_percentage, duration_minutes, position.created_at,
                position.exit_time, position.exit_reason)
        except Exception as e:
            logging.error(f"ê±°ë˜ ì´ë ¥ ì €ì¥ ì‹¤íŒ¨: {e}")
    
    async def _get_daily_pnl(self) -> float:
        """ì¼ì¼ P&L ì¡°íšŒ"""
        try:
            async with self.postgres.acquire() as conn:
                result = await conn.fetchval("""
                    SELECT COALESCE(SUM(pnl), 0) FROM trade_history
                    WHERE DATE(entry_time) = CURRENT_DATE
                """)
                return float(result) if result else 0.0
        except Exception as e:
            logging.error(f"ì¼ì¼ P&L ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return 0.0
    
    async def _check_volatility_risk(self, symbol: str) -> float:
        """ë³€ë™ì„± ìœ„í—˜ë„ ì²´í¬ (0-1)"""
        # ê°„ë‹¨í•œ ì‹œë®¬ë ˆì´ì…˜ (ì‹¤ì œë¡œëŠ” 24h ë³€ë™ì„± ê³„ì‚°)
        volatility_map = {
            "BTCUSDT": 0.3, "ETHUSDT": 0.4, "ADAUSDT": 0.6,
            "SOLUSDT": 0.7, "AVAXUSDT": 0.6
        }
        return volatility_map.get(symbol, 0.5)
    
    def get_portfolio_summary(self) -> Dict:
        """í¬íŠ¸í´ë¦¬ì˜¤ ìš”ì•½"""
        if not self.active_positions:
            return {
                "active_positions": 0,
                "total_unrealized_pnl": 0.0,
                "total_margin_used": 0.0,
                "avg_leverage": 0.0,
                "symbols": []
            }
        
        positions = list(self.active_positions.values())
        
        return {
            "active_positions": len(positions),
            "total_unrealized_pnl": sum(p.unrealized_pnl for p in positions),
            "total_margin_used": sum(p.margin_required for p in positions),
            "avg_leverage": np.mean([p.leverage for p in positions]),
            "avg_liquidation_risk": np.mean([p.liquidation_risk for p in positions]),
            "symbols": [p.symbol for p in positions]
        }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“± í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì‹œìŠ¤í…œ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class UltimateTelegramNotifier:
    """Ultimate í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì‹œìŠ¤í…œ - V3 ë©”ì‹œì§€ + V4 ê³ ë„í™”"""
    
    def __init__(self):
        self.config = SystemConfig.TELEGRAM
        self.bot_token = self.config["bot_token"]
        self.chat_id = self.config["chat_id"]
        self.rate_limiter = asyncio.Semaphore(5)  # ì´ˆë‹¹ 5ê°œ ë©”ì‹œì§€ ì œí•œ
        
    async def send_message(self, message: str, level: str = "INFO"):
        """í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡"""
        if not self.config["alerts"].get(level.lower(), True):
            return False
        
        async with self.rate_limiter:
            return await self._send_message_internal(message, level)
    
    async def _send_message_internal(self, message: str, level: str):
        """ë‚´ë¶€ ë©”ì‹œì§€ ì „ì†¡ ë¡œì§"""
        try:
            url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
            
            # ë ˆë²¨ë³„ ì´ëª¨ì§€ ì¶”ê°€
            level_emojis = {
                "INFO": "â„¹ï¸", "WARNING": "âš ï¸", "ERROR": "âŒ", "CRITICAL": "ğŸš¨", "SUCCESS": "âœ…"
            }
            emoji = level_emojis.get(level, "ğŸ“¢")
            
            formatted_message = f"{emoji} <b>[{level}]</b>\n{message}"
            
            data = {
                "chat_id": self.chat_id,
                "text": formatted_message,
                "parse_mode": "HTML",
                "disable_web_page_preview": True
            }
            
            async with aiohttp.ClientSession() as session:
                async with session.post(url, data=data, timeout=10) as response:
                    if response.status == 200:
                        return True
                    else:
                        logging.warning(f"í…”ë ˆê·¸ë¨ ì‘ë‹µ ì˜¤ë¥˜: {response.status}")
                        return False
                        
        except Exception as e:
            logging.error(f"í…”ë ˆê·¸ë¨ ì „ì†¡ ì‹¤íŒ¨: {e}")
            return False
    
    async def send_trade_notification(self, position: Position, phoenix95_score: float, kelly_ratio: float):
        """ê±°ë˜ ì‹¤í–‰ ì•Œë¦¼ - V3 ìŠ¤íƒ€ì¼ ë©”ì‹œì§€"""
        pnl_range_low = position.margin_required * (SystemConfig.TRADING["stop_loss_pct"] * position.leverage)
        pnl_range_high = position.margin_required * (SystemConfig.TRADING["take_profit_pct"] * position.leverage)
        
        message = f"""ğŸ¯ <b>Phoenix 95 Ultimate ê±°ë˜ ì‹¤í–‰</b>

ğŸ“Š <b>{position.symbol}</b> {position.side} {position.leverage}x ({position.margin_mode})
ğŸ’° ì§„ì…ê°€: <b>${position.entry_price:,.2f}</b>
ğŸ“ˆ ìµì ˆê°€: <b>${position.take_profit_price:,.2f}</b> (+{SystemConfig.TRADING['take_profit_pct']*100:.1f}%)
ğŸ“‰ ì†ì ˆê°€: <b>${position.stop_loss_price:,.2f}</b> (-{SystemConfig.TRADING['stop_loss_pct']*100:.1f}%)
ğŸš¨ ì²­ì‚°ê°€: <b>${position.liquidation_price:,.2f}</b>

ğŸ§  Phoenix95: <b>{phoenix95_score:.1%}</b>
âš–ï¸ Kelly ë¹„ìœ¨: <b>{kelly_ratio:.1%}</b>
ğŸ’µ ìˆ˜ëŸ‰: <b>{position.quantity:.6f}</b>
ğŸ’¸ ë§ˆì§„: <b>${position.margin_required:,.2f}</b>

ğŸ“Š ì˜ˆìƒ P&L: <b>-${pnl_range_low:.0f}</b> ~ <b>+${pnl_range_high:.0f}</b>
ğŸ†” í¬ì§€ì…˜: <code>{position.position_id}</code>

ğŸ• {datetime.utcnow().strftime('%H:%M:%S UTC')}"""
        
        await self.send_message(message, "SUCCESS")
    
    async def send_close_notification(self, position: Position, exit_reason: str):
        """í¬ì§€ì…˜ ì²­ì‚° ì•Œë¦¼"""
        pnl_emoji = "ğŸ“ˆ" if position.realized_pnl > 0 else "ğŸ“‰"
        reason_emoji = {
            "TAKE_PROFIT": "ğŸ¯", "STOP_LOSS": "ğŸ›¡ï¸", 
            "EMERGENCY_LIQUIDATION": "ğŸš¨", "MANUAL": "ğŸ‘¤"
        }
        
        duration = ""
        if position.exit_time and position.created_at:
            duration_mins = int((position.exit_time - position.created_at).total_seconds() / 60)
            duration = f"â±ï¸ ê±°ë˜ì‹œê°„: <b>{duration_mins}ë¶„</b>\n"
        
        message = f"""{pnl_emoji} <b>í¬ì§€ì…˜ ì²­ì‚°</b> {reason_emoji.get(exit_reason, "ğŸ“")}

ğŸ“Š <b>{position.symbol}</b> {position.side} {position.leverage}x
ğŸ’° ì§„ì…ê°€: <b>${position.entry_price:,.2f}</b>
ğŸ’¸ ì²­ì‚°ê°€: <b>${position.exit_price:,.2f}</b>
{duration}
ğŸ’µ P&L: <b>${position.realized_pnl:,.2f}</b> ({position.pnl_percentage:+.1f}%)
ğŸ“‹ ì‚¬ìœ : <b>{exit_reason.replace('_', ' ')}</b>

ğŸ†” í¬ì§€ì…˜: <code>{position.position_id}</code>
ğŸ• {datetime.utcnow().strftime('%H:%M:%S UTC')}"""
        
        level = "SUCCESS" if position.realized_pnl > 0 else "WARNING"
        await self.send_message(message, level)
    
    async def send_liquidation_warning(self, position: Position):
        """ì²­ì‚° ìœ„í—˜ ê²½ê³ """
        message = f"""ğŸ†˜ <b>ì²­ì‚° ìœ„í—˜ ê²½ê³ </b>

ğŸ“Š <b>{position.symbol}</b> {position.side} {position.leverage}x
ğŸ’° ì§„ì…ê°€: <b>${position.entry_price:,.2f}</b>
ğŸ’¸ í˜„ì¬ê°€: <b>${position.current_price:,.2f}</b>
ğŸš¨ ì²­ì‚°ê°€: <b>${position.liquidation_price:,.2f}</b>

âš ï¸ ìœ„í—˜ë„: <b>{position.liquidation_risk:.1%}</b>
ğŸ’” ë¯¸ì‹¤í˜„ P&L: <b>${position.unrealized_pnl:,.2f}</b> ({position.pnl_percentage:+.1f}%)

ğŸ†” í¬ì§€ì…˜: <code>{position.position_id}</code>
ğŸ• {datetime.utcnow().strftime('%H:%M:%S UTC')}

âš¡ ì¦‰ì‹œ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤!"""
        
        await self.send_message(message, "CRITICAL")
    
    async def send_system_notification(self, message: str, level: str = "INFO"):
        """ì‹œìŠ¤í…œ ì•Œë¦¼"""
        system_message = f"""ğŸ–¥ï¸ <b>Phoenix 95 Ultimate System</b>

{message}

ğŸ• {datetime.utcnow().strftime('%H:%M:%S UTC')}"""
        
        await self.send_message(system_message, level)
    
    async def send_daily_summary(self, stats: Dict):
        """ì¼ì¼ ì„±ê³¼ ìš”ì•½"""
        win_rate = (stats.get('winning_trades', 0) / max(stats.get('total_trades', 1), 1)) * 100
        
        message = f"""ğŸ“Š <b>Phoenix 95 Ultimate ì¼ì¼ ì„±ê³¼</b>

ğŸ’° ì´ P&L: <b>${stats.get('total_pnl', 0):.2f}</b>
ğŸ“ˆ ì´ ê±°ë˜: <b>{stats.get('total_trades', 0)}íšŒ</b>
ğŸ¯ ìŠ¹ë¥ : <b>{win_rate:.1f}%</b>
ğŸ† ìµœê³  ê±°ë˜: <b>${stats.get('best_trade', 0):.2f}</b>
ğŸ’” ìµœì•… ê±°ë˜: <b>${stats.get('worst_trade', 0):.2f}</b>
â±ï¸ í‰ê·  ê±°ë˜ì‹œê°„: <b>{stats.get('avg_duration', 0)}ë¶„</b>

ğŸ“Š í™œì„± í¬ì§€ì…˜: <b>{stats.get('active_positions', 0)}ê°œ</b>
ğŸ’¸ ì´ ë§ˆì§„: <b>${stats.get('total_margin', 0):.2f}</b>

ğŸ• {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}"""
        
        await self.send_message(message, "INFO")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ”’ ë³´ì•ˆ & ì¸ì¦
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SecurityManager:
    """ë³´ì•ˆ ê´€ë¦¬ì"""
    
    def __init__(self):
        self.config = SystemConfig.SECURITY
        
    def verify_webhook_signature(self, payload: str, signature: str) -> bool:
        """ì›¹í›… ì„œëª… ê²€ì¦"""
        try:
            expected_signature = hmac.new(
                self.config["webhook_secret"].encode(),
                payload.encode(),
                hashlib.sha256
            ).hexdigest()
            
            return hmac.compare_digest(signature, expected_signature)
        except Exception as e:
            logging.error(f"ì„œëª… ê²€ì¦ ì‹¤íŒ¨: {e}")
            return False
    
    def verify_api_key(self, api_key: str) -> bool:
        """API í‚¤ ê²€ì¦"""
        return api_key == self.config["api_key"]
    
    def is_ip_allowed(self, ip: str) -> bool:
        """IP í—ˆìš© ëª©ë¡ í™•ì¸"""
        allowed_ips = self.config["allowed_ips"]
        return ip in allowed_ips or "0.0.0.0" in allowed_ips

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“Š ëª¨ë‹ˆí„°ë§ & ë©”íŠ¸ë¦­
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SystemMonitor:
    """ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§"""
    
    def __init__(self, redis_client, postgres_pool, telegram_notifier):
        self.redis = redis_client
        self.postgres = postgres_pool
        self.telegram = telegram_notifier
        self.metrics_history = deque(maxlen=1440)  # 24ì‹œê°„ (ë¶„ë‹¹ 1ê°œ)
        
    async def collect_system_metrics(self) -> PerformanceMetrics:
        """ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘"""
        try:
            import psutil
            
            # ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤
            cpu_usage = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            memory_usage = memory.percent
            
            # ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìˆ˜
            active_connections = 0
            try:
                async with self.postgres.acquire() as conn:
                    active_connections = await conn.fetchval(
                        "SELECT count(*) FROM pg_stat_activity WHERE state = 'active'"
                    )
            except:
                pass
            
            # íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­
            trading_metrics = await self._get_trading_metrics()
            
            metrics = PerformanceMetrics(
                timestamp=datetime.utcnow(),
                cpu_usage=cpu_usage,
                memory_usage=memory_usage,
                response_time_ms=0.0,  # APIì—ì„œ ì¸¡ì •
                active_connections=active_connections or 0,
                active_positions=trading_metrics.get('active_positions', 0),
                total_pnl=trading_metrics.get('total_pnl', 0.0),
                win_rate=trading_metrics.get('win_rate', 0.0),
                avg_trade_duration=trading_metrics.get('avg_duration', 0.0),
                phoenix95_avg_score=trading_metrics.get('avg_score', 0.0),
                max_drawdown=trading_metrics.get('max_drawdown', 0.0),
                var_95=trading_metrics.get('var_95', 0.0),
                sharpe_ratio=trading_metrics.get('sharpe_ratio', 0.0)
            )
            
            self.metrics_history.append(metrics)
            return metrics
            
        except Exception as e:
            logging.error(f"ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤íŒ¨: {e}")
            return None
    
    async def _get_trading_metrics(self) -> Dict:
        """íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­ ìˆ˜ì§‘"""
        try:
            async with self.postgres.acquire() as conn:
                # ì˜¤ëŠ˜ í†µê³„
                today_stats = await conn.fetchrow("""
                    SELECT 
                        COUNT(*) as total_trades,
                        COUNT(*) FILTER (WHERE pnl > 0) as winning_trades,
                        COALESCE(SUM(pnl), 0) as total_pnl,
                        COALESCE(AVG(duration_minutes), 0) as avg_duration
                    FROM trade_history 
                    WHERE DATE(entry_time) = CURRENT_DATE
                """)
                
                # í™œì„± í¬ì§€ì…˜
                active_positions = await conn.fetchval(
                    "SELECT COUNT(*) FROM positions WHERE status = 'OPEN'"
                )
                
                win_rate = 0.0
                if today_stats and today_stats['total_trades'] > 0:
                    win_rate = (today_stats['winning_trades'] / today_stats['total_trades']) * 100
                
                return {
                    'active_positions': active_positions or 0,
                    'total_pnl': float(today_stats['total_pnl']) if today_stats else 0.0,
                    'win_rate': win_rate,
                    'avg_duration': float(today_stats['avg_duration']) if today_stats else 0.0,
                    'avg_score': 0.85,  # Phoenix 95 í‰ê·  ì ìˆ˜
                    'max_drawdown': 0.0,
                    'var_95': 0.0,
                    'sharpe_ratio': 0.0
                }
                
        except Exception as e:
            logging.error(f"íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤íŒ¨: {e}")
            return {}
    
    async def check_alerts(self, metrics: PerformanceMetrics):
        """ì•Œë¦¼ ì²´í¬"""
        alerts = []
        thresholds = SystemConfig.MONITORING["performance_threshold"]
        
        # CPU ì‚¬ìš©ë¥  ì²´í¬
        if metrics.cpu_usage > thresholds["cpu_usage_pct"]:
            alerts.append(f"ë†’ì€ CPU ì‚¬ìš©ë¥ : {metrics.cpu_usage:.1f}%")
        
        # ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ì²´í¬
        if metrics.memory_usage > thresholds["memory_usage_pct"]:
            alerts.append(f"ë†’ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : {metrics.memory_usage:.1f}%")
        
        # ì‘ë‹µ ì‹œê°„ ì²´í¬
        if metrics.response_time_ms > thresholds["response_time_ms"]:
            alerts.append(f"ëŠë¦° ì‘ë‹µ ì‹œê°„: {metrics.response_time_ms:.0f}ms")
        
        # ì•Œë¦¼ ì „ì†¡
        for alert in alerts:
            await self.telegram.send_system_notification(alert, "WARNING")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸš€ ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Phoenix95UltimateSystem:
    """Phoenix 95 Ultimate í†µí•© ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.phoenix95_engine = Phoenix95AIEngine()
        self.telegram = UltimateTelegramNotifier()
        self.security = SecurityManager()
        self.redis_client = None
        self.postgres_pool = None
        self.trader = None
        self.monitor = None
        
        # FastAPI ì•±
        self.app = FastAPI(
            title="Phoenix 95 Ultimate Trading System",
            description="V3 ê²€ì¦ëœ ì•Œê³ ë¦¬ì¦˜ + V4 ê³ ê¸‰ ê¸°ëŠ¥ + í—¤ì§€í€ë“œê¸‰ ì•ˆì „ì„±",
            version="Ultimate-1.0.0"
        )
        
        self._setup_middleware()
        self._setup_routes()
        
    def _setup_middleware(self):
        """ë¯¸ë“¤ì›¨ì–´ ì„¤ì •"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    
    def _setup_routes(self):
        """API ë¼ìš°íŠ¸ ì„¤ì •"""
        
        @self.app.on_event("startup")
        async def startup_event():
            await self.initialize()
        
        @self.app.on_event("shutdown")
        async def shutdown_event():
            await self.cleanup()
        
        @self.app.post("/webhook/tradingview")
        async def receive_tradingview_signal(signal_data: dict, background_tasks: BackgroundTasks):
            """TradingView ì‹ í˜¸ ìˆ˜ì‹ """
            try:
                # ì‹ í˜¸ íŒŒì‹± ë° ê²€ì¦
                signal = TradingSignal(
                    signal_id=f"SIG_{uuid.uuid4().hex[:8].upper()}",
                    symbol=signal_data["symbol"],
                    action=signal_data["action"].lower(),
                    price=float(signal_data["price"]),
                    confidence=float(signal_data["confidence"]),
                    timestamp=datetime.utcnow()
                )
                
                if not signal.is_valid():
                    raise HTTPException(status_code=400, detail="ì˜ëª»ëœ ì‹ í˜¸ ë°ì´í„°")
                
                # ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì²˜ë¦¬
                background_tasks.add_task(self._process_signal_complete, signal)
                
                return {
                    "status": "received",
                    "signal_id": signal.signal_id,
                    "timestamp": signal.timestamp.isoformat()
                }
                
            except Exception as e:
                logging.error(f"ì‹ í˜¸ ìˆ˜ì‹  ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/health")
        async def health_check():
            """ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬"""
            try:
                # ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì²´í¬
                db_healthy = False
                try:
                    async with self.postgres_pool.acquire() as conn:
                        await conn.fetchval("SELECT 1")
                    db_healthy = True
                except:
                    pass
                
                # Redis ì—°ê²° ì²´í¬
                redis_healthy = False
                try:
                    await self.redis_client.ping()
                    redis_healthy = True
                except:
                    pass
                
                # í¬íŠ¸í´ë¦¬ì˜¤ ìš”ì•½
                portfolio = self.trader.get_portfolio_summary() if self.trader else {}
                
                return {
                    "status": "healthy" if db_healthy and redis_healthy else "degraded",
                    "timestamp": datetime.utcnow().isoformat(),
                    "version": "Ultimate-1.0.0",
                    "system": "Phoenix 95 Ultimate Trading System",
                    "components": {
                        "database": "healthy" if db_healthy else "error",
                        "redis": "healthy" if redis_healthy else "error",
                        "ai_engine": "healthy",
                        "trading_engine": "healthy" if self.trader else "error"
                    },
                    "portfolio": portfolio,
                    "config": {
                        "max_leverage": SystemConfig.TRADING["max_leverage"],
                        "max_positions": SystemConfig.TRADING["max_positions"],
                        "confidence_threshold": SystemConfig.TRADING["confidence_threshold"]
                    }
                }
                
            except Exception as e:
                logging.error(f"í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/positions")
        async def get_active_positions():
            """í™œì„± í¬ì§€ì…˜ ì¡°íšŒ"""
            try:
                if not self.trader:
                    return {"positions": [], "count": 0}
                
                positions = []
                for position in self.trader.active_positions.values():
                    positions.append({
                        "position_id": position.position_id,
                        "symbol": position.symbol,
                        "side": position.side,
                        "entry_price": position.entry_price,
                        "current_price": position.current_price,
                        "quantity": position.quantity,
                        "leverage": position.leverage,
                        "margin_required": position.margin_required,
                        "unrealized_pnl": position.unrealized_pnl,
                        "pnl_percentage": position.pnl_percentage,
                        "liquidation_risk": position.liquidation_risk,
                        "liquidation_price": position.liquidation_price,
                        "stop_loss_price": position.stop_loss_price,
                        "take_profit_price": position.take_profit_price,
                        "status": position.status,
                        "created_at": position.created_at.isoformat()
                    })
                
                portfolio_summary = self.trader.get_portfolio_summary()
                
                return {
                    "positions": positions,
                    "count": len(positions),
                    "summary": portfolio_summary
                }
                
            except Exception as e:
                logging.error(f"í¬ì§€ì…˜ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/performance")
        async def get_performance_stats():
            """ì„±ëŠ¥ í†µê³„ ì¡°íšŒ"""
            try:
                # AI ì—”ì§„ ì„±ëŠ¥
                ai_stats = self.phoenix95_engine.get_performance_stats()
                
                # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­
                latest_metrics = None
                if self.monitor and self.monitor.metrics_history:
                    latest_metrics = self.monitor.metrics_history[-1]
                
                # ê±°ë˜ í†µê³„
                trading_stats = {}
                if self.postgres_pool:
                    async with self.postgres_pool.acquire() as conn:
                        trading_stats = await conn.fetchrow("""
                            SELECT 
                                COUNT(*) as total_trades,
                                COUNT(*) FILTER (WHERE pnl > 0) as winning_trades,
                                COALESCE(SUM(pnl), 0) as total_pnl,
                                COALESCE(AVG(pnl), 0) as avg_pnl,
                                COALESCE(MAX(pnl), 0) as best_trade,
                                COALESCE(MIN(pnl), 0) as worst_trade
                            FROM trade_history 
                            WHERE entry_time >= CURRENT_DATE - INTERVAL '7 days'
                        """)
                
                return {
                    "ai_engine": ai_stats,
                    "system_metrics": asdict(latest_metrics) if latest_metrics else {},
                    "trading_stats": dict(trading_stats) if trading_stats else {},
                    "timestamp": datetime.utcnow().isoformat()
                }
                
            except Exception as e:
                logging.error(f"ì„±ëŠ¥ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.post("/admin/emergency_close")
        async def emergency_close_position(position_id: str):
            """ê¸´ê¸‰ í¬ì§€ì…˜ ì²­ì‚°"""
            try:
                if not self.trader or position_id not in self.trader.active_positions:
                    raise HTTPException(status_code=404, detail="í¬ì§€ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
                
                position = self.trader.active_positions[position_id]
                current_price = await self.trader._get_current_price(position.symbol)
                
                await self.trader._close_position(position, current_price, "MANUAL")
                
                return {
                    "status": "success",
                    "message": f"í¬ì§€ì…˜ {position_id} ê¸´ê¸‰ ì²­ì‚° ì™„ë£Œ",
                    "timestamp": datetime.utcnow().isoformat()
                }
                
            except Exception as e:
                logging.error(f"ê¸´ê¸‰ ì²­ì‚° ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=str(e))
    
    async def initialize(self):
        """ì‹œìŠ¤í…œ ì´ˆê¸°í™”"""
        try:
            logging.info("Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹œì‘...")
            
            # Redis ì—°ê²°
            self.redis_client = await aioredis.from_url(
                SystemConfig.DATABASE["redis_url"],
                encoding="utf-8",
                decode_responses=True
            )
            logging.info("Redis ì—°ê²° ì„±ê³µ")
            
            # PostgreSQL ì—°ê²°
            self.postgres_pool = await asyncpg.create_pool(
                SystemConfig.DATABASE["postgres_url"],
                min_size=5,
                max_size=SystemConfig.DATABASE["connection_pool_size"]
            )
            logging.info("PostgreSQL ì—°ê²° ì„±ê³µ")
            
            # íŠ¸ë ˆì´ë” ì´ˆê¸°í™”
            self.trader = UltimateLeverageTrader(
                self.redis_client, 
                self.postgres_pool, 
                self.telegram
            )
            logging.info("ë ˆë²„ë¦¬ì§€ íŠ¸ë ˆì´ë” ì´ˆê¸°í™” ì™„ë£Œ")
            
            # ëª¨ë‹ˆí„° ì´ˆê¸°í™”
            self.monitor = SystemMonitor(
                self.redis_client,
                self.postgres_pool,
                self.telegram
            )
            logging.info("ì‹œìŠ¤í…œ ëª¨ë‹ˆí„° ì´ˆê¸°í™” ì™„ë£Œ")
            
            # ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì‹œì‘
            asyncio.create_task(self._monitoring_loop())
            
            # ì‹œì‘ ì•Œë¦¼
            await self.telegram.send_system_notification(
                """ğŸ¯ <b>Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì‹œì‘</b>

âœ… V3 ê²€ì¦ëœ ì•Œê³ ë¦¬ì¦˜ í™œì„±í™”
âœ… V4 ê³ ê¸‰ ê¸°ëŠ¥ í™œì„±í™”  
âœ… í—¤ì§€í€ë“œê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ í™œì„±í™”
âœ… ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ í™œì„±í™”
âœ… 20x â†’ 10x ë³´ìˆ˜ì  ë ˆë²„ë¦¬ì§€
âœ… 85% ì‹ ë¢°ë„ ì„ê³„ê°’

ğŸ’° ìµœëŒ€ í¬ì§€ì…˜: {SystemConfig.TRADING["max_positions"]}ê°œ
ğŸ›¡ï¸ ì¼ì¼ ì†ì‹¤ í•œë„: ${SystemConfig.TRADING["max_daily_loss"]}
âš¡ ë¶„ì„ ì†ë„: 2ì´ˆ ì´ë‚´ ë³´ì¥

ğŸš€ ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ!""", 
                "SUCCESS"
            )
            
            logging.info("Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ!")
            
        except Exception as e:
            logging.error(f"ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            await self.telegram.send_system_notification(f"ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}", "ERROR")
            raise
    
    async def cleanup(self):
        """ì‹œìŠ¤í…œ ì •ë¦¬"""
        try:
            logging.info("ì‹œìŠ¤í…œ ì •ë¦¬ ì‹œì‘...")
            
            # ëª¨ë“  ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì·¨ì†Œ
            if self.trader:
                for task in self.trader.monitoring_tasks.values():
                    if not task.done():
                        task.cancel()
            
            # ì—°ê²° ì •ë¦¬
            if self.redis_client:
                await self.redis_client.close()
            
            if self.postgres_pool:
                await self.postgres_pool.close()
            
            await self.telegram.send_system_notification("ì‹œìŠ¤í…œ ì •ìƒ ì¢…ë£Œ", "INFO")
            logging.info("ì‹œìŠ¤í…œ ì •ë¦¬ ì™„ë£Œ")
            
        except Exception as e:
            logging.error(f"ì‹œìŠ¤í…œ ì •ë¦¬ ì‹¤íŒ¨: {e}")
    
    async def _process_signal_complete(self, signal: TradingSignal):
        """ì™„ì „í•œ ì‹ í˜¸ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸"""
        try:
            logging.info(f"ì‹ í˜¸ ì²˜ë¦¬ ì‹œì‘: {signal.signal_id}")
            
            # 1. Phoenix 95 AI ë¶„ì„
            phoenix95_score, kelly_ratio, recommendation = await self.phoenix95_engine.analyze_signal_complete(signal)
            
            signal.phoenix95_score = phoenix95_score
            signal.kelly_ratio = kelly_ratio
            signal.recommendation = recommendation
            signal.processed = True
            
            logging.info(f"AI ë¶„ì„ ì™„ë£Œ: Phoenix95={phoenix95_score:.3f}, Kelly={kelly_ratio:.3f}, Rec={recommendation}")
            
            # 2. ì¶”ì²œì´ ê±°ë˜ ê°€ëŠ¥í•œ ê²½ìš°ì—ë§Œ ì‹¤í–‰
            if recommendation in ["STRONG_BUY", "BUY", "WEAK_BUY"]:
                # 3. ê±°ë˜ ì‹¤í–‰
                position = await self.trader.execute_trade_complete(signal, phoenix95_score, kelly_ratio)
                
                if position:
                    logging.info(f"ê±°ë˜ ì‹¤í–‰ ì„±ê³µ: {position.position_id}")
                else:
                    logging.warning(f"ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨: {signal.signal_id}")
                    await self.telegram.send_system_notification(
                        f"ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨\nì‹ í˜¸: {signal.symbol} {signal.action}", 
                        "WARNING"
                    )
            else:
                logging.info(f"ê±°ë˜ ê±°ë¶€: {recommendation}")
                await self.telegram.send_system_notification(
                    f"""ğŸ“Š ì‹ í˜¸ ë¶„ì„ ì™„ë£Œ (ê±°ë˜ ê±°ë¶€)

ğŸ” {signal.symbol} {signal.action.upper()}
ğŸ’° ê°€ê²©: ${signal.price:,.2f}
ğŸ§  Phoenix95: {phoenix95_score:.1%}
âš–ï¸ Kelly: {kelly_ratio:.1%}
âŒ ì¶”ì²œ: {recommendation}

ğŸ’¡ ê±°ë˜ ì¡°ê±´ ë¯¸ì¶©ì¡±""", 
                    "INFO"
                )
            
        except Exception as e:
            logging.error(f"ì‹ í˜¸ ì²˜ë¦¬ ì‹¤íŒ¨ {signal.signal_id}: {e}")
            signal.processed = False
            signal.error_message = str(e)
            
            await self.telegram.send_system_notification(
                f"ì‹ í˜¸ ì²˜ë¦¬ ì˜¤ë¥˜\n{signal.symbol}: {str(e)}", 
                "ERROR"
            )
    
    async def _monitoring_loop(self):
        """ëª¨ë‹ˆí„°ë§ ë£¨í”„"""
        while True:
            try:
                # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
                metrics = await self.monitor.collect_system_metrics()
                
                if metrics:
                    # ì•Œë¦¼ ì²´í¬
                    await self.monitor.check_alerts(metrics)
                    
                    # Redisì— ìµœì‹  ë©”íŠ¸ë¦­ ì €ì¥
                    await self.redis_client.hset("system:metrics", mapping={
                        "cpu_usage": metrics.cpu_usage,
                        "memory_usage": metrics.memory_usage,
                        "active_positions": metrics.active_positions,
                        "total_pnl": metrics.total_pnl,
                        "timestamp": metrics.timestamp.isoformat()
                    })
                
                # 30ì´ˆë§ˆë‹¤ ì‹¤í–‰
                await asyncio.sleep(SystemConfig.MONITORING["metrics_interval"])
                
            except Exception as e:
                logging.error(f"ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì˜¤ë¥˜: {e}")
                await asyncio.sleep(60)  # ì˜¤ë¥˜ ì‹œ 1ë¶„ ëŒ€ê¸°

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸš€ ì„œë²„ ì‹¤í–‰
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    # ë¡œê¹… ì„¤ì •
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(levelname)s - %(message)s',
        handlers=[
            logging.FileHandler('phoenix95_ultimate.log'),
            logging.StreamHandler(sys.stdout)
        ]
    )
    
    # ì‹œìŠ¤í…œ ì‹œì‘ ë©”ì‹œì§€
    print("=" * 80)
    print("ğŸ¯ Phoenix 95 Ultimate Trading System")
    print("ğŸ’° V3 ê²€ì¦ëœ ì•Œê³ ë¦¬ì¦˜ + V4 ê³ ê¸‰ ê¸°ëŠ¥ + í—¤ì§€í€ë“œê¸‰ ì•ˆì „ì„±")
    print("âš¡ Wall Streetê¸‰ íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ")
    print("=" * 80)
    
    # Phoenix 95 ì‹œìŠ¤í…œ ìƒì„±
    phoenix95_system = Phoenix95UltimateSystem()
    
    # FastAPI ì„œë²„ ì‹¤í–‰
    config = uvicorn.Config(
        phoenix95_system.app,
        host="0.0.0.0",
        port=int(os.getenv("PORT", "8080")),
        log_level="info",
        access_log=True
    )
    
    server = uvicorn.Server(config)
    await server.serve()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nğŸ‘‹ Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì¢…ë£Œ")
    except Exception as e:
        print(f"\nâŒ ì‹œìŠ¤í…œ ì˜¤ë¥˜: {e}")
        sys.exit(1)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“‹ í†µí•© ë°°í¬ ì„¤ì •
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
=== docker-compose.yml ===
version: '3.8'
services:
  postgres:
    image: postgres:15-alpine
    container_name: phoenix95_ultimate_postgres
    environment:
      POSTGRES_DB: phoenix95
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./init_ultimate.sql:/docker-entrypoint-initdb.d/init.sql
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    container_name: phoenix95_ultimate_redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped

  phoenix95_ultimate:
    build: .
    container_name: phoenix95_ultimate_system
    ports:
      - "8080:8080"
    environment:
      - POSTGRES_URL=postgresql://postgres:password@postgres:5432/phoenix95
      - REDIS_URL=redis://redis:6379
      - ACCOUNT_BALANCE=50000
      - LOG_LEVEL=INFO
    depends_on:
      - postgres
      - redis
    restart: unless-stopped

volumes:
  postgres_data:
  redis_data:

=== requirements.txt ===
fastapi==0.104.1
uvicorn[standard]==0.24.0
asyncpg==0.29.0
aioredis==2.0.1
aiohttp==3.9.0
numpy==1.24.3
pandas==2.0.3
psutil==5.9.6
python-multipart==0.0.6

=== Dockerfile ===
FROM python:3.11-slim
WORKDIR /app
RUN apt-get update && apt-get install -y curl && rm -rf /var/lib/apt/lists/*
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt
COPY phoenix95_ultimate.py .
EXPOSE 8080
HEALTHCHECK --interval=30s --timeout=10s --retries=3 CMD curl -f http://localhost:8080/health || exit 1
CMD ["python", "phoenix95_ultimate.py"]

=== deploy_ultimate.sh ===
#!/bin/bash
echo "ğŸ¯ Phoenix 95 Ultimate ë°°í¬ ì‹œì‘"
chmod +x deploy_ultimate.sh
docker-compose down -v 2>/dev/null || true
docker-compose build --no-cache
docker-compose up -d
echo "â³ ì‹œìŠ¤í…œ ì¤€ë¹„ ëŒ€ê¸° ì¤‘..."
for i in {1..30}; do
    if curl -s http://localhost:8080/health >/dev/null 2>&1; then
        echo "âœ… Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ!"
        break
    fi
    sleep 3
done
echo "ğŸ‰ ë°°í¬ ì™„ë£Œ! http://localhost:8080"

=== ì‚¬ìš©ë²• ===
1. ëª¨ë“  íŒŒì¼ì„ ê°™ì€ í´ë”ì— ì €ì¥
2. chmod +x deploy_ultimate.sh
3. ./deploy_ultimate.sh
4. TradingView ì›¹í›…: http://your-server:8080/webhook/tradingview
5. í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§: http://localhost:8080/positions
6. ì„±ëŠ¥ í†µê³„: http://localhost:8080/performance
"""

# ğŸ‰ ì™„ì„±! Phoenix 95 Ultimate - ëª¨ë“  ê¸°ëŠ¥ì´ í†µí•©ëœ ìµœì¢… ì‹œìŠ¤í…œ
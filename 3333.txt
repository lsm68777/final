# ğŸ¦ ì™„ì „í•œ í—¤ì§€í€ë“œê¸‰ Phoenix 95 ì•„í‚¤í…ì²˜ - í†µí•© ë²„ì „
# ì €ì: Phoenix 95 Team
# ë²„ì „: 4.1.0 Integrated Hedge Fund Edition
# ë‚ ì§œ: 2025ë…„ 1ì›”

import asyncio
import aiohttp
from fastapi import FastAPI, HTTPException, BackgroundTasks
import uvicorn
from datetime import datetime, timedelta
import numpy as np
import os
import sys
import json
import time
import math
import hashlib
import logging
from concurrent.futures import ThreadPoolExecutor
from dataclasses import dataclass, asdict
from typing import Optional, Dict, List, Any, Union
import requests
import multiprocessing
from contextlib import asynccontextmanager
import signal
import psutil
from pathlib import Path

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ ê¸€ë¡œë²Œ ì„¤ì • ë° ìƒìˆ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class HedgeFundConfig:
    """í—¤ì§€í€ë“œ ì„¤ì • (í•˜ë“œì½”ë”©ìœ¼ë¡œ ì•ˆì •ì„± í™•ë³´)"""
    # ë¦¬ìŠ¤í¬ ê´€ë¦¬ (ë³€ê²½ ê¸ˆì§€)
    MAX_DAILY_LOSS: float = 0.02      # 2%
    MAX_POSITION_SIZE: float = 0.05   # 5%
    LEVERAGE: int = 20                # 20x ê³ ì •
    STOP_LOSS: float = 0.02          # 2%
    TAKE_PROFIT: float = 0.02        # 2%
    MAX_POSITIONS: int = 3           # ìµœëŒ€ 3ê°œ ë™ì‹œ
    
    # Phoenix 95 ì„¤ì •
    MIN_CONFIDENCE: float = 0.75     # 75% ì´ìƒë§Œ ê±°ë˜
    PHOENIX_WEIGHT: float = 0.95     # Phoenix 95 ê°€ì¤‘ì¹˜
    
    # ì‹œìŠ¤í…œ ì„¤ì •
    TARGET_RESPONSE_TIME: int = 100  # 100ms
    HEALTH_CHECK_INTERVAL: int = 30  # 30ì´ˆ
    MAX_RETRY_ATTEMPTS: int = 3      # ìµœëŒ€ ì¬ì‹œë„
    CONNECTION_TIMEOUT: int = 10     # ì—°ê²° íƒ€ì„ì•„ì›ƒ
    
    # ì•Œë¦¼ ì„¤ì •
    TELEGRAM_TOKEN: str = "7386542811:AAEZ21p30rES1k8NxNM2xbZ53U44PI9D5CY"
    TELEGRAM_CHAT_ID: str = "7590895952"
    
    # ë¡œê¹… ì„¤ì •
    LOG_LEVEL: str = "INFO"
    LOG_FORMAT: str = "%(asctime)s - %(name)s - %(levelname)s - %(message)s"

CONFIG = HedgeFundConfig()

# ë¡œê¹… ì„¤ì •
logging.basicConfig(
    level=getattr(logging, CONFIG.LOG_LEVEL),
    format=CONFIG.LOG_FORMAT,
    handlers=[
        logging.StreamHandler(sys.stdout),
        logging.FileHandler('phoenix95.log') if os.path.exists('.') else logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ› ï¸ ìœ í‹¸ë¦¬í‹° í´ë˜ìŠ¤ ë° í•¨ìˆ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class PerformanceMonitor:
    """ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ í´ë˜ìŠ¤"""
    
    def __init__(self):
        self.metrics = {
            'response_times': [],
            'success_rate': 0.0,
            'total_requests': 0,
            'successful_requests': 0,
            'error_count': 0
        }
        self.start_time = time.time()
    
    def record_request(self, response_time: float, success: bool = True):
        """ìš”ì²­ ê¸°ë¡"""
        self.metrics['response_times'].append(response_time)
        self.metrics['total_requests'] += 1
        
        if success:
            self.metrics['successful_requests'] += 1
        else:
            self.metrics['error_count'] += 1
            
        # ì„±ê³µë¥  ê³„ì‚°
        self.metrics['success_rate'] = (
            self.metrics['successful_requests'] / self.metrics['total_requests'] * 100
            if self.metrics['total_requests'] > 0 else 0
        )
        
        # ì‘ë‹µì‹œê°„ ë¦¬ìŠ¤íŠ¸ê°€ ë„ˆë¬´ ì»¤ì§€ì§€ ì•Šë„ë¡ ì œí•œ
        if len(self.metrics['response_times']) > 1000:
            self.metrics['response_times'] = self.metrics['response_times'][-500:]
    
    def get_stats(self) -> Dict:
        """í†µê³„ ë°˜í™˜"""
        response_times = self.metrics['response_times']
        if not response_times:
            return self.metrics
        
        return {
            **self.metrics,
            'avg_response_time': np.mean(response_times),
            'p95_response_time': np.percentile(response_times, 95),
            'p99_response_time': np.percentile(response_times, 99),
            'uptime': time.time() - self.start_time
        }

class RetryHandler:
    """ì¬ì‹œë„ í•¸ë“¤ëŸ¬"""
    
    @staticmethod
    async def retry_async(func, *args, max_attempts: int = 3, delay: float = 1.0, **kwargs):
        """ë¹„ë™ê¸° í•¨ìˆ˜ ì¬ì‹œë„"""
        last_exception = None
        
        for attempt in range(max_attempts):
            try:
                return await func(*args, **kwargs)
            except Exception as e:
                last_exception = e
                if attempt < max_attempts - 1:
                    await asyncio.sleep(delay * (2 ** attempt))  # ì§€ìˆ˜ë°±ì˜¤í”„
                    logger.warning(f"Retry attempt {attempt + 1} failed: {e}")
                else:
                    logger.error(f"All {max_attempts} attempts failed: {e}")
        
        raise last_exception
    
    @staticmethod
    def retry_sync(func, *args, max_attempts: int = 3, delay: float = 1.0, **kwargs):
        """ë™ê¸° í•¨ìˆ˜ ì¬ì‹œë„"""
        last_exception = None
        
        for attempt in range(max_attempts):
            try:
                return func(*args, **kwargs)
            except Exception as e:
                last_exception = e
                if attempt < max_attempts - 1:
                    time.sleep(delay * (2 ** attempt))
                    logger.warning(f"Retry attempt {attempt + 1} failed: {e}")
                else:
                    logger.error(f"All {max_attempts} attempts failed: {e}")
        
        raise last_exception

async def call_service(service_name: str, endpoint: str, data: Dict = None, method: str = 'POST') -> Dict:
    """ì„œë¹„ìŠ¤ ê°„ í†µì‹  (ê°œì„ ëœ ë²„ì „)"""
    service_ports = {
        'signal-engine': 8100,
        'risk-guardian': 8101,
        'trade-executor': 8102,
        'monitor-alert': 8103
    }
    
    port = service_ports.get(service_name)
    if not port:
        return {'error': f'Unknown service: {service_name}'}
    
    url = f"http://localhost:{port}{endpoint}"
    
    try:
        timeout = aiohttp.ClientTimeout(total=CONFIG.CONNECTION_TIMEOUT)
        
        async with aiohttp.ClientSession(timeout=timeout) as session:
            if method.upper() == 'GET':
                async with session.get(url) as response:
                    if response.status == 200:
                        return await response.json()
                    else:
                        return {'error': f'HTTP {response.status}'}
            else:  # POST
                async with session.post(url, json=data or {}) as response:
                    if response.status == 200:
                        return await response.json()
                    else:
                        return {'error': f'HTTP {response.status}'}
                        
    except asyncio.TimeoutError:
        return {'error': 'Timeout'}
    except Exception as e:
        return {'error': str(e)}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ§  1. SIGNAL ENGINE (í¬íŠ¸: 8100)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Phoenix95Engine:
    """í—¤ì§€í€ë“œê¸‰ AI ì—”ì§„ - ê²€ì¦ëœ ë‹¨ìˆœí•¨"""
    
    def __init__(self):
        self.name = "Phoenix 95 V4.1 Hedge Fund Edition"
        self.version = "4.1.0"
        self.performance_monitor = PerformanceMonitor()
        self.cache = {}  # ê°„ë‹¨í•œ ë©”ëª¨ë¦¬ ìºì‹œ
        self.cache_ttl = 60  # 60ì´ˆ ìºì‹œ
        
    def analyze(self, data: Dict) -> Dict:
        """í•µì‹¬ 3ê°€ì§€ ì§€í‘œ ë¶„ì„ (í—¤ì§€í€ë“œ ê²€ì¦ëœ ë°©ì‹)"""
        start_time = time.time()
        
        try:
            # ìºì‹œ ì²´í¬
            cache_key = self._generate_cache_key(data)
            cached_result = self._get_cached_result(cache_key)
            if cached_result:
                return cached_result
            
            # ì…ë ¥ ë°ì´í„° ê²€ì¦
            validated_data = self._validate_input_data(data)
            
            # 1. ê¸°ìˆ ì  ë¶„ì„ (30%)
            technical_score = self._analyze_technical(validated_data)
            
            # 2. ê±°ë˜ëŸ‰ ë¶„ì„ (30%)
            volume_score = self._analyze_volume(validated_data)
            
            # 3. ëª¨ë©˜í…€ ë¶„ì„ (40%)
            momentum_score = self._analyze_momentum(validated_data)
            
            # Phoenix 95 ìµœì¢… ì ìˆ˜ ê³„ì‚°
            raw_score = (
                technical_score * 0.3 + 
                volume_score * 0.3 + 
                momentum_score * 0.4
            )
            
            # Phoenix 95 ê°€ì¤‘ì¹˜ ì ìš©
            phoenix_score = raw_score * CONFIG.PHOENIX_WEIGHT
            
            # ì‹ ë¢°ë„ ê³„ì‚° (ë³€ë™ì„± ê³ ë ¤)
            confidence = self._calculate_confidence(phoenix_score, validated_data)
            
            # ì¶”ì²œ ë“±ê¸‰
            recommendation = self._get_recommendation(confidence)
            
            # ì²˜ë¦¬ ì‹œê°„ ê³„ì‚°
            processing_time = (time.time() - start_time) * 1000
            
            # ì„±ëŠ¥ ê¸°ë¡
            self.performance_monitor.record_request(processing_time, True)
            
            result = {
                'phoenix_score': round(phoenix_score, 4),
                'confidence': round(confidence, 4),
                'recommendation': recommendation,
                'components': {
                    'technical': round(technical_score, 3),
                    'volume': round(volume_score, 3),
                    'momentum': round(momentum_score, 3)
                },
                'metadata': {
                    'engine': self.name,
                    'version': self.version,
                    'processing_time_ms': round(processing_time, 2),
                    'timestamp': datetime.now().isoformat(),
                    'cache_hit': False
                }
            }
            
            # ê²°ê³¼ ìºì‹œ
            self._cache_result(cache_key, result)
            
            return result
            
        except Exception as e:
            processing_time = (time.time() - start_time) * 1000
            self.performance_monitor.record_request(processing_time, False)
            logger.error(f"Phoenix95 analysis error: {e}")
            
            return {
                'error': str(e),
                'phoenix_score': 0.0,
                'confidence': 0.0,
                'recommendation': 'ERROR',
                'metadata': {
                    'processing_time_ms': round(processing_time, 2),
                    'timestamp': datetime.now().isoformat()
                }
            }
    
    def _validate_input_data(self, data: Dict) -> Dict:
        """ì…ë ¥ ë°ì´í„° ê²€ì¦ ë° ê¸°ë³¸ê°’ ì„¤ì •"""
        validated = {
            'symbol': data.get('symbol', 'UNKNOWN'),
            'price': max(0, float(data.get('price', 0))),
            'rsi': max(0, min(100, float(data.get('rsi', 50)))),
            'volume': max(0, float(data.get('volume', 1000000))),
            'avg_volume_20': max(1, float(data.get('avg_volume_20', 1000000))),
            'macd_line': float(data.get('macd_line', 0)),
            'macd_signal': float(data.get('macd_signal', 0)),
            'bb_position': max(0, min(1, float(data.get('bb_position', 0.5)))),
            'stoch_k': max(0, min(100, float(data.get('stoch_k', 50)))),
            'stoch_d': max(0, min(100, float(data.get('stoch_d', 50)))),
            'williams_r': max(-100, min(0, float(data.get('williams_r', -50)))),
            'cci': float(data.get('cci', 0)),
            'volatility': max(0, float(data.get('volatility', 0.02)))
        }
        return validated
    
    def _generate_cache_key(self, data: Dict) -> str:
        """ìºì‹œ í‚¤ ìƒì„±"""
        # ì£¼ìš” ì§€í‘œë“¤ë¡œ í•´ì‹œ ìƒì„±
        key_data = {
            'symbol': data.get('symbol'),
            'rsi': round(float(data.get('rsi', 50)), 1),
            'volume_ratio': round(float(data.get('volume', 1)) / float(data.get('avg_volume_20', 1)), 2),
            'stoch_k': round(float(data.get('stoch_k', 50)), 1)
        }
        return hashlib.md5(json.dumps(key_data, sort_keys=True).encode()).hexdigest()
    
    def _get_cached_result(self, cache_key: str) -> Optional[Dict]:
        """ìºì‹œì—ì„œ ê²°ê³¼ ì¡°íšŒ"""
        if cache_key in self.cache:
            cached_data, timestamp = self.cache[cache_key]
            if time.time() - timestamp < self.cache_ttl:
                cached_data['metadata']['cache_hit'] = True
                return cached_data
            else:
                del self.cache[cache_key]
        return None
    
    def _cache_result(self, cache_key: str, result: Dict):
        """ê²°ê³¼ ìºì‹œ ì €ì¥"""
        self.cache[cache_key] = (result.copy(), time.time())
        
        # ìºì‹œ í¬ê¸° ì œí•œ
        if len(self.cache) > 100:
            oldest_key = min(self.cache.keys(), key=lambda k: self.cache[k][1])
            del self.cache[oldest_key]
    
    def _analyze_technical(self, data: Dict) -> float:
        """ê¸°ìˆ ì  ì§€í‘œ ë¶„ì„ (ê°œì„ ëœ ë²„ì „)"""
        rsi = data['rsi']
        macd_line = data['macd_line']
        macd_signal = data['macd_signal']
        bb_position = data['bb_position']
        
        # RSI ì ìˆ˜ (ë” ì •êµí•œ ë¡œì§)
        if rsi < 20:
            rsi_score = 0.95
        elif rsi < 30:
            rsi_score = 0.85
        elif rsi < 40:
            rsi_score = 0.65
        elif rsi < 60:
            rsi_score = 0.50
        elif rsi < 70:
            rsi_score = 0.35
        elif rsi < 80:
            rsi_score = 0.15
        else:
            rsi_score = 0.05
        
        # MACD ì ìˆ˜ (ê°œì„ ëœ ê³„ì‚°)
        macd_diff = macd_line - macd_signal
        if abs(macd_diff) > 100:  # ì´ìƒê°’ ì²˜ë¦¬
            macd_diff = math.copysign(100, macd_diff)
        
        macd_score = 0.5 + (macd_diff / 200)
        macd_score = max(0, min(macd_score, 1))
        
        # ë³¼ë¦°ì €ë°´ë“œ ì ìˆ˜
        if bb_position < 0.2:
            bb_score = 0.8  # í•˜ë‹¨ ê·¼ì²˜
        elif bb_position > 0.8:
            bb_score = 0.2  # ìƒë‹¨ ê·¼ì²˜
        else:
            bb_score = 0.5  # ì¤‘ê°„
        
        # ê°€ì¤‘ í‰ê·  (RSIì— ë” ë†’ì€ ê°€ì¤‘ì¹˜)
        technical_score = (rsi_score * 0.5 + macd_score * 0.3 + bb_score * 0.2)
        
        return max(0, min(technical_score, 1))
    
    def _analyze_volume(self, data: Dict) -> float:
        """ê±°ë˜ëŸ‰ ë¶„ì„ (ê°œì„ ëœ ë²„ì „)"""
        current_volume = data['volume']
        avg_volume = data['avg_volume_20']
        
        volume_ratio = current_volume / avg_volume
        
        # ë” ì •êµí•œ ê±°ë˜ëŸ‰ í•´ì„
        if volume_ratio > 5.0:
            return 0.95  # í­ë°œì  ê±°ë˜ëŸ‰
        elif volume_ratio > 3.0:
            return 0.90
        elif volume_ratio > 2.5:
            return 0.85
        elif volume_ratio > 2.0:
            return 0.75
        elif volume_ratio > 1.5:
            return 0.65
        elif volume_ratio > 1.2:
            return 0.55
        elif volume_ratio > 0.8:
            return 0.50
        elif volume_ratio > 0.5:
            return 0.35
        else:
            return 0.20  # ë§¤ìš° ë‚®ì€ ê±°ë˜ëŸ‰
    
    def _analyze_momentum(self, data: Dict) -> float:
        """ëª¨ë©˜í…€ ë¶„ì„ (ê°œì„ ëœ ë²„ì „)"""
        stoch_k = data['stoch_k']
        stoch_d = data['stoch_d']
        williams_r = data['williams_r']
        cci = data['cci']
        
        # Stochastic ì ìˆ˜ (Kì™€ D ê´€ê³„ ê³ ë ¤)
        if stoch_k < 20 and stoch_d < 20:
            if stoch_k > stoch_d:  # ìƒìŠ¹ ì „í™˜
                stoch_score = 0.9
            else:
                stoch_score = 0.8
        elif stoch_k > 80 and stoch_d > 80:
            if stoch_k < stoch_d:  # í•˜ë½ ì „í™˜
                stoch_score = 0.1
            else:
                stoch_score = 0.2
        else:
            stoch_score = 0.5
        
        # Williams %R ì ìˆ˜
        if williams_r < -80:
            williams_score = 0.85
        elif williams_r < -50:
            williams_score = 0.65
        elif williams_r > -20:
            williams_score = 0.15
        else:
            williams_score = 0.5
        
        # CCI ì ìˆ˜ (ë²”ìœ„ ì œí•œ)
        cci_clamped = max(-300, min(300, cci))
        if cci_clamped < -100:
            cci_score = 0.8 + (cci_clamped + 100) / 500  # -100 ~ -300 ë²”ìœ„
        elif cci_clamped > 100:
            cci_score = 0.2 - (cci_clamped - 100) / 500  # 100 ~ 300 ë²”ìœ„
        else:
            cci_score = 0.5 + cci_clamped / 200  # -100 ~ 100 ë²”ìœ„
        
        cci_score = max(0, min(cci_score, 1))
        
        # ê°€ì¤‘ í‰ê· 
        momentum_score = (stoch_score * 0.4 + williams_score * 0.3 + cci_score * 0.3)
        
        return max(0, min(momentum_score, 1))
    
    def _calculate_confidence(self, phoenix_score: float, data: Dict) -> float:
        """ì‹ ë¢°ë„ ê³„ì‚° (ë³€ë™ì„± ê³ ë ¤)"""
        base_confidence = phoenix_score
        
        # ë³€ë™ì„± í˜ë„í‹°
        volatility = data.get('volatility', 0.02)
        if volatility > 0.05:  # 5% ì´ìƒ ë³€ë™ì„±
            volatility_penalty = 0.1
        elif volatility > 0.03:  # 3% ì´ìƒ ë³€ë™ì„±
            volatility_penalty = 0.05
        else:
            volatility_penalty = 0
        
        # ê±°ë˜ëŸ‰ ë³´ì •
        volume_ratio = data['volume'] / data['avg_volume_20']
        if volume_ratio < 0.5:  # ë‚®ì€ ê±°ë˜ëŸ‰
            volume_penalty = 0.1
        elif volume_ratio > 3.0:  # ë§¤ìš° ë†’ì€ ê±°ë˜ëŸ‰ (ì‹ ë¢°ë„ í–¥ìƒ)
            volume_penalty = -0.05
        else:
            volume_penalty = 0
        
        confidence = base_confidence - volatility_penalty - volume_penalty
        return max(0, min(confidence, 1))
    
    def _get_recommendation(self, confidence: float) -> str:
        """ì¶”ì²œ ë“±ê¸‰ (ê°œì„ ëœ ê¸°ì¤€)"""
        if confidence > 0.90:
            return "STRONG_BUY"
        elif confidence > 0.80:
            return "BUY"
        elif confidence > 0.65:
            return "WEAK_BUY"
        elif confidence > 0.55:
            return "HOLD"
        elif confidence > 0.40:
            return "WEAK_SELL"
        elif confidence > 0.25:
            return "SELL"
        else:
            return "STRONG_SELL"
    
    def get_performance_stats(self) -> Dict:
        """ì„±ëŠ¥ í†µê³„ ë°˜í™˜"""
        return {
            'engine_stats': self.performance_monitor.get_stats(),
            'cache_stats': {
                'cache_size': len(self.cache),
                'cache_ttl': self.cache_ttl
            }
        }

# Signal Engine FastAPI ì•±
@asynccontextmanager
async def signal_lifespan(app: FastAPI):
    """Signal Engine ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬"""
    logger.info("ğŸ§  Signal Engine ì‹œì‘")
    yield
    logger.info("ğŸ§  Signal Engine ì¢…ë£Œ")

signal_app = FastAPI(
    title="Phoenix 95 Signal Engine",
    version="4.1.0",
    description="í—¤ì§€í€ë“œê¸‰ AI ì‹ í˜¸ ë¶„ì„ ì—”ì§„",
    lifespan=signal_lifespan
)

phoenix_engine = Phoenix95Engine()

@signal_app.post("/analyze")
async def analyze_signal(data: dict):
    """í•µì‹¬ ì‹ í˜¸ ë¶„ì„ API"""
    try:
        # AI ë¶„ì„ ì‹¤í–‰
        analysis = phoenix_engine.analyze(data)
        
        # ê³ ì‹ ë¢°ë„ ì‹ í˜¸ì¸ ê²½ìš° ë¦¬ìŠ¤í¬ ì²´í¬ ì—°ë™ ì œì•ˆ
        if analysis.get('confidence', 0) > CONFIG.MIN_CONFIDENCE:
            analysis['risk_check_suggested'] = True
        
        return {
            'status': 'success',
            'analysis': analysis,
            'engine': phoenix_engine.name,
            'timestamp': datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Signal analysis error: {e}")
        raise HTTPException(status_code=500, detail=f"ë¶„ì„ ì‹¤íŒ¨: {str(e)}")

@signal_app.get("/stats")
async def get_stats():
    """ì„±ëŠ¥ í†µê³„ ì¡°íšŒ"""
    return phoenix_engine.get_performance_stats()

@signal_app.get("/health")
async def health():
    stats = phoenix_engine.get_performance_stats()
    return {
        'status': 'healthy',
        'service': 'signal_engine',
        'engine': phoenix_engine.name,
        'version': phoenix_engine.version,
        'performance': stats,
        'timestamp': datetime.now().isoformat()
    }

@signal_app.get("/")
async def root():
    return {
        'service': 'Phoenix 95 Signal Engine',
        'version': '4.1.0',
        'description': 'í—¤ì§€í€ë“œê¸‰ AI ì‹ í˜¸ ë¶„ì„',
        'endpoints': {
            'analyze': 'POST /analyze',
            'stats': 'GET /stats',
            'health': 'GET /health'
        }
    }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ›¡ï¸ 2. RISK GUARDIAN (í¬íŠ¸: 8101)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class RiskGuardian:
    """í—¤ì§€í€ë“œê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        # í˜„ì¬ ë¦¬ìŠ¤í¬ ìƒíƒœ
        self.daily_pnl = 0.0
        self.active_positions = 0
        self.total_exposure = 0.0
        self.position_history = []
        self.last_reset = datetime.now().date()
        
        # ë¦¬ìŠ¤í¬ ë©”íŠ¸ë¦­
        self.risk_metrics = {
            'daily_trades': 0,
            'success_rate': 0.0,
            'avg_holding_time': 0.0,
            'max_drawdown': 0.0,
            'win_rate': 0.0,
            'avg_win': 0.0,
            'avg_loss': 0.0,
            'sharpe_ratio': 0.0
        }
        
        # ì„±ëŠ¥ ëª¨ë‹ˆí„°
        self.performance_monitor = PerformanceMonitor()
        
        # ë™ì  ë¦¬ìŠ¤í¬ ì¡°ì • ë³€ìˆ˜
        self.risk_multiplier = 1.0  # ì„±ê³¼ì— ë”°ë¥¸ ë¦¬ìŠ¤í¬ ì¡°ì •
        self.consecutive_losses = 0
        self.consecutive_wins = 0
        
        logger.info("ğŸ›¡ï¸ Risk Guardian ì´ˆê¸°í™” ì™„ë£Œ")
    
    def check_trade_approval(self, signal_data: Dict, analysis: Dict) -> Dict:
        """ê±°ë˜ ìŠ¹ì¸ ì—¬ë¶€ ê²°ì • (ê°œì„ ëœ ë²„ì „)"""
        start_time = time.time()
        
        try:
            checks = []
            approved = True
            risk_level = 'LOW'
            
            # ì¼ì¼ ë¦¬ì…‹ ì²´í¬
            self._check_daily_reset()
            
            # 1. ì¼ì¼ ì†ì‹¤ í•œë„ ì²´í¬ (ìµœìš°ì„ )
            current_loss_pct = abs(self.daily_pnl)
            max_loss_adjusted = CONFIG.MAX_DAILY_LOSS * self.risk_multiplier
            
            if current_loss_pct >= max_loss_adjusted:
                approved = False
                risk_level = 'CRITICAL'
                checks.append(f"ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼: {current_loss_pct:.2%} >= {max_loss_adjusted:.2%}")
            
            # 2. í¬ì§€ì…˜ ìˆ˜ í•œë„ ì²´í¬
            if self.active_positions >= CONFIG.MAX_POSITIONS:
                approved = False
                risk_level = 'HIGH'
                checks.append(f"ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ë„ë‹¬: {self.active_positions}/{CONFIG.MAX_POSITIONS}")
            
            # 3. ì‹ ë¢°ë„ ì²´í¬ (ë™ì  ì¡°ì •)
            confidence = analysis.get('confidence', 0)
            min_confidence_adjusted = self._get_adjusted_min_confidence()
            
            if confidence < min_confidence_adjusted:
                approved = False
                risk_level = 'MEDIUM'
                checks.append(f"ì‹ ë¢°ë„ ë¶€ì¡±: {confidence:.3f} < {min_confidence_adjusted:.3f}")
            
            # 4. ì—°ì† ì†ì‹¤ ì²´í¬
            if self.consecutive_losses >= 3:
                if confidence < 0.85:  # ë” ë†’ì€ ì‹ ë¢°ë„ ìš”êµ¬
                    approved = False
                    risk_level = 'HIGH'
                    checks.append(f"ì—°ì† ì†ì‹¤ í›„ ë‚®ì€ ì‹ ë¢°ë„: {self.consecutive_losses}íšŒ ì—°ì†")
            
            # 5. í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
            account_balance = signal_data.get('account_balance', 10000)
            position_size = self._calculate_position_size(account_balance, confidence, signal_data)
            
            # 6. ì´ ë…¸ì¶œ í•œë„ ì²´í¬
            position_size_pct = position_size / account_balance if account_balance > 0 else 0
            projected_exposure = self.total_exposure + position_size_pct
            max_total_exposure = 0.20  # 20% ê¸°ë³¸ í•œë„
            
            if projected_exposure > max_total_exposure:
                approved = False
                risk_level = 'HIGH'
                checks.append(f"ì´ ë…¸ì¶œ í•œë„ ì´ˆê³¼: {projected_exposure:.2%} > {max_total_exposure:.2%}")
            
            # 7. ì‹œì¥ ì¡°ê±´ ì²´í¬
            market_condition = self._assess_market_condition(signal_data)
            market_risk = self._assess_market_risk(market_condition, len(checks))
            
            if market_risk['block_trade']:
                approved = False
                risk_level = 'HIGH'
                checks.append(market_risk['reason'])
            
            # 8. ìµœì†Œ í¬ì§€ì…˜ í¬ê¸° ì²´í¬
            min_position = account_balance * 0.001  # 0.1% ìµœì†Œ
            if position_size < min_position:
                approved = False
                risk_level = 'LOW'
                checks.append(f"í¬ì§€ì…˜ í¬ê¸° ë„ˆë¬´ ì‘ìŒ: ${position_size:.2f} < ${min_position:.2f}")
            
            # ì„±ëŠ¥ ê¸°ë¡
            processing_time = (time.time() - start_time) * 1000
            self.performance_monitor.record_request(processing_time, True)
            
            # ìŠ¹ì¸ëœ ê²½ìš°ì—ë§Œ í¬ì§€ì…˜ í¬ê¸° ì œê³µ
            final_position_size = position_size if approved else 0
            
            return {
                'approved': approved,
                'position_size': final_position_size,
                'position_size_pct': position_size_pct if approved else 0,
                'risk_level': risk_level,
                'checks': checks,
                'risk_metrics': {
                    'current_exposure': self.total_exposure,
                    'projected_exposure': projected_exposure,
                    'daily_pnl': self.daily_pnl,
                    'active_positions': self.active_positions,
                    'market_condition': market_condition,
                    'risk_multiplier': self.risk_multiplier,
                    'consecutive_losses': self.consecutive_losses,
                    'min_confidence_required': min_confidence_adjusted
                },
                'kelly_sizing': {
                    'base_size': final_position_size * 0.8,
                    'confidence_adjusted': final_position_size,
                    'max_allowed': account_balance * CONFIG.MAX_POSITION_SIZE,
                    'risk_adjusted': final_position_size * self.risk_multiplier
                },
                'performance': {
                    'processing_time_ms': round(processing_time, 2),
                    'timestamp': datetime.now().isoformat()
                }
            }
            
        except Exception as e:
            processing_time = (time.time() - start_time) * 1000
            self.performance_monitor.record_request(processing_time, False)
            logger.error(f"Risk check error: {e}")
            
            return {
                'approved': False,
                'position_size': 0,
                'risk_level': 'ERROR',
                'checks': [f"ë¦¬ìŠ¤í¬ ì²´í¬ ì˜¤ë¥˜: {str(e)}"],
                'error': str(e)
            }
    
    def _get_adjusted_min_confidence(self) -> float:
        """ë™ì  ìµœì†Œ ì‹ ë¢°ë„ ê³„ì‚°"""
        base_confidence = CONFIG.MIN_CONFIDENCE
        
        # ì—°ì† ì†ì‹¤ í›„ ì‹ ë¢°ë„ ìš”êµ¬ ì¦ê°€
        if self.consecutive_losses >= 2:
            base_confidence += 0.05 * self.consecutive_losses
        
        # ì¼ì¼ ì†ì‹¤ì´ í´ ê²½ìš° ì‹ ë¢°ë„ ìš”êµ¬ ì¦ê°€
        if abs(self.daily_pnl) > CONFIG.MAX_DAILY_LOSS * 0.5:
            base_confidence += 0.1
        
        return min(base_confidence, 0.95)  # ìµœëŒ€ 95%
    
    def _calculate_position_size(self, balance: float, confidence: float, signal_data: Dict) -> float:
        """ê°œì„ ëœ í¬ì§€ì…˜ ì‚¬ì´ì§•"""
        # ê¸°ë³¸ Kelly Criterion ê³„ì‚°
        base_size = self._kelly_position_size(balance, confidence)
        
        # ë³€ë™ì„± ì¡°ì •
        volatility = signal_data.get('volatility', 0.02)
        volatility_factor = 1.0 - min(volatility * 10, 0.5)  # ë³€ë™ì„±ì´ í´ìˆ˜ë¡ í¬ê¸° ê°ì†Œ
        
        # ê±°ë˜ëŸ‰ ì¡°ì •
        volume_ratio = signal_data.get('volume', 1) / signal_data.get('avg_volume_20', 1)
        volume_factor = min(1.0, volume_ratio / 2.0)  # ê±°ë˜ëŸ‰ì´ ì ìœ¼ë©´ í¬ê¸° ê°ì†Œ
        
        # ì‹œê°„ ì¡°ì • (ì‹œì¥ ê°œì¥ì‹œê°„ ë“±)
        time_factor = self._get_time_factor()
        
        # ì—°ì† ì†ì‹¤ ì¡°ì •
        consecutive_loss_factor = max(0.5, 1.0 - (self.consecutive_losses * 0.1))
        
        # ìµœì¢… í¬ê¸° ê³„ì‚°
        adjusted_size = (base_size * volatility_factor * volume_factor * 
                        time_factor * consecutive_loss_factor * self.risk_multiplier)
        
        # ìµœëŒ€ í•œë„ ì ìš©
        max_position = balance * CONFIG.MAX_POSITION_SIZE
        final_size = min(adjusted_size, max_position)
        
        return max(0, final_size)
    
    def _kelly_position_size(self, balance: float, confidence: float) -> float:
        """Kelly Criterion ê¸°ë°˜ í¬ì§€ì…˜ ì‚¬ì´ì§•"""
        # ì‹ ë¢°ë„ ê¸°ë°˜ ìŠ¹ë¥  ì¶”ì •
        estimated_win_rate = 0.5 + (confidence - 0.5) * 0.6  # 0.5 ~ 0.8 ë²”ìœ„
        estimated_win_rate = max(0.5, min(estimated_win_rate, 0.85))
        
        # í‰ê·  ìˆ˜ìµ/ì†ì‹¤ ë¹„ìœ¨ (ë³´ìˆ˜ì  ì¶”ì •)
        avg_win_loss_ratio = 1.0  # 1:1 ë¹„ìœ¨ ê°€ì •
        
        # Kelly ê³µì‹: f = (bp - q) / b
        # b = ìˆ˜ìµ/ì†ì‹¤ ë¹„ìœ¨, p = ìŠ¹ë¥ , q = íŒ¨ë¥ 
        b = avg_win_loss_ratio
        p = estimated_win_rate
        q = 1 - p
        
        kelly_fraction = (b * p - q) / b
        kelly_fraction = max(0.01, min(kelly_fraction, 0.25))  # 1%-25% ì œí•œ
        
        # ë³´ìˆ˜ì  ì¡°ì • (ì‹¤ì œ Kellyì˜ ì ˆë°˜ ì‚¬ìš©)
        conservative_kelly = kelly_fraction * 0.5
        
        return balance * conservative_kelly
    
    def _get_time_factor(self) -> float:
        """ì‹œê°„ ê¸°ë°˜ ì¡°ì • íŒ©í„°"""
        now = datetime.now()
        hour = now.hour
        
        # ì‹œì¥ í™œì„± ì‹œê°„ëŒ€ì— ê°€ì¤‘ì¹˜ ì¦ê°€
        if 9 <= hour <= 16:  # ì£¼ìš” ì‹œì¥ ì‹œê°„
            return 1.0
        elif 17 <= hour <= 21:  # ì•„ì‹œì•„ ì‹œì¥
            return 0.8
        else:  # ë¹„í™œì„± ì‹œê°„
            return 0.6
    
    def _assess_market_condition(self, data: Dict) -> str:
        """ì‹œì¥ ì¡°ê±´ í‰ê°€ (ê°œì„ ëœ ë²„ì „)"""
        volatility = data.get('volatility', 0.02)
        volume_ratio = data.get('volume', 1000) / data.get('avg_volume_20', 1000)
        
        # ë‹¤ì¤‘ ì¡°ê±´ ì²´í¬
        high_volatility = volatility > 0.05
        extreme_volume = volume_ratio > 4.0 or volume_ratio < 0.3
        
        if high_volatility and extreme_volume:
            return 'EXTREME_VOLATILITY'
        elif high_volatility or volume_ratio > 3.0:
            return 'HIGH_VOLATILITY'
        elif volatility > 0.03 or volume_ratio > 2.0:
            return 'MEDIUM_VOLATILITY'
        else:
            return 'NORMAL'
    
    def _assess_market_risk(self, market_condition: str, existing_checks: int) -> Dict:
        """ì‹œì¥ ë¦¬ìŠ¤í¬ í‰ê°€"""
        if market_condition == 'EXTREME_VOLATILITY':
            return {
                'block_trade': True,
                'reason': 'ê·¹ë„ì˜ ì‹œì¥ ë³€ë™ì„±ìœ¼ë¡œ ê±°ë˜ ì¤‘ë‹¨'
            }
        elif market_condition == 'HIGH_VOLATILITY' and existing_checks > 0:
            return {
                'block_trade': True,
                'reason': 'ê³ ë³€ë™ì„± ì‹œì¥ì—ì„œ ì¶”ê°€ ë¦¬ìŠ¤í¬ ìš”ì¸ ì¡´ì¬'
            }
        else:
            return {'block_trade': False, 'reason': ''}
    
    def _check_daily_reset(self):
        """ì¼ì¼ ë¦¬ì…‹ ì²´í¬"""
        today = datetime.now().date()
        if today != self.last_reset:
            # ì´ì „ ì¼ ë°ì´í„° ë°±ì—…
            if self.daily_pnl != 0:
                self.position_history.append({
                    'date': self.last_reset,
                    'daily_pnl': self.daily_pnl,
                    'trades': self.risk_metrics['daily_trades']
                })
            
            # ì¼ì¼ ë¦¬ì…‹
            self.daily_pnl = 0.0
            self.risk_metrics['daily_trades'] = 0
            self.last_reset = today
            
            # ì£¼ê°„ ë¦¬ìŠ¤í¬ ìŠ¹ìˆ˜ ì¡°ì •
            self._adjust_weekly_risk_multiplier()
            
            logger.info(f"ì¼ì¼ ë¦¬ì…‹ ì™„ë£Œ: {today}")
    
    def _adjust_weekly_risk_multiplier(self):
        """ì£¼ê°„ ì„±ê³¼ ê¸°ë°˜ ë¦¬ìŠ¤í¬ ìŠ¹ìˆ˜ ì¡°ì •"""
        if len(self.position_history) >= 7:  # ìµœì†Œ 1ì£¼ì¼ ë°ì´í„°
            recent_week = self.position_history[-7:]
            week_pnl = sum(day['daily_pnl'] for day in recent_week)
            
            if week_pnl > 0.05:  # ì£¼ê°„ 5% ì´ìƒ ìˆ˜ìµ
                self.risk_multiplier = min(1.2, self.risk_multiplier + 0.1)
            elif week_pnl < -0.03:  # ì£¼ê°„ 3% ì´ìƒ ì†ì‹¤
                self.risk_multiplier = max(0.5, self.risk_multiplier - 0.1)
            else:
                self.risk_multiplier = 1.0  # ê¸°ë³¸ê°’ìœ¼ë¡œ ë³µê·€
            
            logger.info(f"ì£¼ê°„ ë¦¬ìŠ¤í¬ ìŠ¹ìˆ˜ ì¡°ì •: {self.risk_multiplier:.2f}")
    
    def update_position_status(self, position_update: Dict):
        """í¬ì§€ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸ (ê°œì„ ëœ ë²„ì „)"""
        try:
            action = position_update.get('action')
            
            if action == 'open':
                self.active_positions += 1
                self.total_exposure += position_update.get('size_pct', 0)
                self.risk_metrics['daily_trades'] += 1
                
                logger.info(f"í¬ì§€ì…˜ ì˜¤í”ˆ: {self.active_positions}ê°œ í™œì„±")
                
            elif action == 'close':
                self.active_positions = max(0, self.active_positions - 1)
                self.total_exposure -= position_update.get('size_pct', 0)
                self.total_exposure = max(0, self.total_exposure)
                
                # P&L ì—…ë°ì´íŠ¸
                pnl_pct = position_update.get('pnl_pct', 0)
                self.daily_pnl += pnl_pct
                
                # ì—°ì† ì†ìµ ì¶”ì 
                if pnl_pct > 0:
                    self.consecutive_wins += 1
                    self.consecutive_losses = 0
                else:
                    self.consecutive_losses += 1
                    self.consecutive_wins = 0
                
                # ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸
                self._update_metrics(pnl_pct, position_update.get('holding_time', 0))
                
                logger.info(f"í¬ì§€ì…˜ ì²­ì‚°: P&L {pnl_pct:+.2%}, {self.active_positions}ê°œ í™œì„±")
            
            elif action == 'update':
                # í¬ì§€ì…˜ ì •ë³´ ì—…ë°ì´íŠ¸ë§Œ
                pass
                
        except Exception as e:
            logger.error(f"Position update error: {e}")
    
    def _update_metrics(self, pnl_pct: float, holding_time: float):
        """ë©”íŠ¸ë¦­ ì—…ë°ì´íŠ¸"""
        # ìŠ¹ë¥  ê³„ì‚°
        total_closed = len([h for h in self.position_history if 'pnl' in h])
        if total_closed > 0:
            wins = len([h for h in self.position_history if h.get('pnl', 0) > 0])
            self.risk_metrics['win_rate'] = wins / total_closed
        
        # í‰ê·  ë³´ìœ  ì‹œê°„
        if holding_time > 0:
            current_avg = self.risk_metrics['avg_holding_time']
            self.risk_metrics['avg_holding_time'] = (current_avg + holding_time) / 2
        
        # ìµœëŒ€ ì†ì‹¤ ì—…ë°ì´íŠ¸
        if self.daily_pnl < self.risk_metrics['max_drawdown']:
            self.risk_metrics['max_drawdown'] = self.daily_pnl
    
    def get_risk_report(self) -> Dict:
        """ì™„ì „í•œ ë¦¬ìŠ¤í¬ ë³´ê³ ì„œ ìƒì„±"""
        performance_stats = self.performance_monitor.get_stats()
        
        return {
            'current_status': {
                'daily_pnl': self.daily_pnl,
                'active_positions': self.active_positions,
                'total_exposure': self.total_exposure,
                'risk_utilization': abs(self.daily_pnl) / CONFIG.MAX_DAILY_LOSS,
                'risk_multiplier': self.risk_multiplier,
                'consecutive_losses': self.consecutive_losses,
                'consecutive_wins': self.consecutive_wins
            },
            'limits': {
                'max_daily_loss': CONFIG.MAX_DAILY_LOSS,
                'max_positions': CONFIG.MAX_POSITIONS,
                'max_position_size': CONFIG.MAX_POSITION_SIZE,
                'min_confidence': CONFIG.MIN_CONFIDENCE,
                'adjusted_min_confidence': self._get_adjusted_min_confidence()
            },
            'metrics': self.risk_metrics,
            'alerts': self._generate_alerts(),
            'performance': performance_stats,
            'history': {
                'recent_days': self.position_history[-7:] if len(self.position_history) >= 7 else self.position_history,
                'total_days': len(self.position_history)
            }
        }
    
    def _generate_alerts(self) -> List[str]:
        """ë¦¬ìŠ¤í¬ ì•Œë¦¼ ìƒì„± (ê°œì„ ëœ ë²„ì „)"""
        alerts = []
        
        # ì†ì‹¤ ê´€ë ¨ ì•Œë¦¼
        loss_pct = abs(self.daily_pnl)
        if loss_pct > CONFIG.MAX_DAILY_LOSS * 0.9:
            alerts.append(f"ğŸš¨ ì¼ì¼ ì†ì‹¤ì´ í•œë„ì˜ 90%ì— ë„ë‹¬: {loss_pct:.2%}")
        elif loss_pct > CONFIG.MAX_DAILY_LOSS * 0.8:
            alerts.append(f"âš ï¸ ì¼ì¼ ì†ì‹¤ì´ í•œë„ì˜ 80%ì— ë„ë‹¬: {loss_pct:.2%}")
        
        # í¬ì§€ì…˜ ê´€ë ¨ ì•Œë¦¼
        if self.active_positions >= CONFIG.MAX_POSITIONS:
            alerts.append(f"ğŸ“Š ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ì— ë„ë‹¬: {self.active_positions}/{CONFIG.MAX_POSITIONS}")
        elif self.active_positions >= CONFIG.MAX_POSITIONS * 0.8:
            alerts.append(f"ğŸ“ˆ í™œì„± í¬ì§€ì…˜ì´ í•œë„ì˜ 80%ì— ë„ë‹¬: {self.active_positions}/{CONFIG.MAX_POSITIONS}")
        
        # ë…¸ì¶œ ê´€ë ¨ ì•Œë¦¼
        if self.total_exposure > 0.18:
            alerts.append(f"ğŸ¯ ì´ ë…¸ì¶œì´ 18%ë¥¼ ì´ˆê³¼: {self.total_exposure:.1%}")
        elif self.total_exposure > 0.15:
            alerts.append(f"ğŸ“Š ì´ ë…¸ì¶œì´ 15%ë¥¼ ì´ˆê³¼: {self.total_exposure:.1%}")
        
        # ì—°ì† ì†ì‹¤ ì•Œë¦¼
        if self.consecutive_losses >= 3:
            alerts.append(f"ğŸ“‰ ì—°ì† ì†ì‹¤ ê²½ê³ : {self.consecutive_losses}íšŒ")
        
        # ì„±ê³¼ ê´€ë ¨ ì•Œë¦¼
        if self.risk_metrics['win_rate'] < 0.4 and len(self.position_history) > 10:
            alerts.append(f"ğŸ“‰ ìŠ¹ë¥  ì €ì¡°: {self.risk_metrics['win_rate']:.1%}")
        
        return alerts

# Risk Guardian FastAPI ì•±
@asynccontextmanager
async def risk_lifespan(app: FastAPI):
    """Risk Guardian ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬"""
    logger.info("ğŸ›¡ï¸ Risk Guardian ì‹œì‘")
    yield
    logger.info("ğŸ›¡ï¸ Risk Guardian ì¢…ë£Œ")

risk_app = FastAPI(
    title="Phoenix 95 Risk Guardian",
    version="4.1.0",
    description="í—¤ì§€í€ë“œê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œ",
    lifespan=risk_lifespan
)

risk_guardian = RiskGuardian()

@risk_app.post("/check")
async def check_risk(data: dict):
    """ë¦¬ìŠ¤í¬ ì²´í¬ API"""
    try:
        signal_data = data.get('signal_data', {})
        analysis = data.get('analysis', {})
        
        result = risk_guardian.check_trade_approval(signal_data, analysis)
        
        return {
            'status': 'success',
            'risk_check': result,
            'timestamp': datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Risk check API error: {e}")
        raise HTTPException(status_code=500, detail=f"ë¦¬ìŠ¤í¬ ì²´í¬ ì‹¤íŒ¨: {str(e)}")

@risk_app.post("/update")
async def update_position(data: dict):
    """í¬ì§€ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸"""
    try:
        risk_guardian.update_position_status(data)
        return {
            'status': 'updated',
            'timestamp': datetime.now().isoformat(),
            'active_positions': risk_guardian.active_positions,
            'daily_pnl': risk_guardian.daily_pnl
        }
    except Exception as e:
        logger.error(f"Position update error: {e}")
        raise HTTPException(status_code=500, detail=f"ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {str(e)}")

@risk_app.get("/status")
async def risk_status():
    """ë¦¬ìŠ¤í¬ ìƒíƒœ ì¡°íšŒ"""
    return risk_guardian.get_risk_report()

@risk_app.post("/reset")
async def reset_daily():
    """ìˆ˜ë™ ì¼ì¼ ë¦¬ì…‹ (ê´€ë¦¬ìš©)"""
    try:
        old_pnl = risk_guardian.daily_pnl
        risk_guardian._check_daily_reset()
        return {
            'status': 'reset_completed',
            'old_daily_pnl': old_pnl,
            'new_daily_pnl': risk_guardian.daily_pnl,
            'timestamp': datetime.now().isoformat()
        }
    except Exception as e:
        raise HTTPException(status_code=500, detail=f"ë¦¬ì…‹ ì‹¤íŒ¨: {str(e)}")

@risk_app.get("/health")
async def health():
    stats = risk_guardian.performance_monitor.get_stats()
    return {
        'status': 'healthy',
        'service': 'risk_guardian',
        'active_positions': risk_guardian.active_positions,
        'daily_pnl': risk_guardian.daily_pnl,
        'risk_multiplier': risk_guardian.risk_multiplier,
        'performance': stats,
        'timestamp': datetime.now().isoformat()
    }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš¡ 3. TRADE EXECUTOR (í¬íŠ¸: 8102)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class TradeExecutor:
    """í—¤ì§€í€ë“œê¸‰ ê±°ë˜ ì‹¤í–‰ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.api_key = os.getenv('BINANCE_API_KEY')
        self.api_secret = os.getenv('BINANCE_SECRET')
        self.test_mode = os.getenv('TRADE_MODE', 'TEST') == 'TEST'
        
        # ê±°ë˜ ì„¤ì • (í—¤ì§€í€ë“œ ê¸°ì¤€)
        self.leverage = CONFIG.LEVERAGE
        self.stop_loss_pct = CONFIG.STOP_LOSS
        self.take_profit_pct = CONFIG.TAKE_PROFIT
        
        # ê±°ë˜ í†µê³„
        self.execution_stats = {
            'total_trades': 0,
            'successful_trades': 0,
            'failed_trades': 0,
            'avg_execution_time': 0.0,
            'total_volume': 0.0,
            'slippage_stats': {
                'avg_slippage': 0.0,
                'max_slippage': 0.0,
                'slippage_count': 0
            }
        }
        
        # ì„±ëŠ¥ ëª¨ë‹ˆí„°
        self.performance_monitor = PerformanceMonitor()
        
        # í™œì„± ì£¼ë¬¸ ì¶”ì 
        self.active_orders = {}
        
        logger.info(f"âš¡ Trade Executor ì´ˆê¸°í™” - ëª¨ë“œ: {('LIVE' if not self.test_mode else 'TEST')}")
    
    async def execute_trade(self, signal: Dict, risk_approval: Dict) -> Dict:
        """ê±°ë˜ ì‹¤í–‰ (ê°œì„ ëœ ë²„ì „)"""
        execution_start = time.time()
        
        try:
            # ë¦¬ìŠ¤í¬ ìŠ¹ì¸ ì²´í¬
            if not risk_approval.get('approved'):
                return {
                    'status': 'rejected',
                    'reason': 'Risk not approved',
                    'risk_checks': risk_approval.get('checks', []),
                    'timestamp': datetime.now().isoformat()
                }
            
            # ì…ë ¥ ë°ì´í„° ê²€ì¦
            validation_result = self._validate_trade_data(signal, risk_approval)
            if not validation_result['valid']:
                return {
                    'status': 'rejected',
                    'reason': validation_result['reason'],
                    'timestamp': datetime.now().isoformat()
                }
            
            # 1. ë ˆë²„ë¦¬ì§€ ì„¤ì •
            leverage_result = await self._set_leverage(signal['symbol'])
            if not leverage_result.get('success', True):
                return {
                    'status': 'failed',
                    'reason': f"ë ˆë²„ë¦¬ì§€ ì„¤ì • ì‹¤íŒ¨: {leverage_result.get('error', 'Unknown')}"
                }
            
            # 2. í¬ì§€ì…˜ í¬ê¸° ìµœì¢… í™•ì¸ ë° ì¡°ì •
            position_size = self._adjust_position_size(
                risk_approval['position_size'], 
                signal.get('price', 0)
            )
            
            if position_size <= 0:
                return {'status': 'rejected', 'reason': 'Invalid position size after adjustment'}
            
            # 3. ì‹œì¥ ìƒí™© ì¬í™•ì¸
            market_check = await self._check_market_conditions(signal['symbol'])
            if not market_check['tradeable']:
                return {
                    'status': 'rejected',
                    'reason': f"ì‹œì¥ ìƒí™© ë¶€ì ì ˆ: {market_check['reason']}"
                }
            
            # 4. ì£¼ë¬¸ ì‹¤í–‰
            order_result = await self._place_order(
                symbol=signal['symbol'],
                side=signal['side'],
                quantity=position_size,
                price=signal.get('price', 0)
            )
            
            if order_result['status'] == 'FILLED':
                # 5. ìµì ˆ/ì†ì ˆ ì£¼ë¬¸ ì„¤ì •
                stop_orders = await self._set_stop_orders(order_result, signal['side'])
                
                # 6. ì‹¤í–‰ í†µê³„ ì—…ë°ì´íŠ¸
                execution_time = (time.time() - execution_start) * 1000
                slippage = self._calculate_slippage(
                    signal.get('price', 0), 
                    float(order_result['price'])
                )
                
                self._update_execution_stats(execution_time, position_size, True, slippage)
                
                # 7. Risk Guardianì— í¬ì§€ì…˜ ì˜¤í”ˆ ì•Œë¦¼
                await self._notify_risk_guardian('open', {
                    'size_pct': position_size / signal.get('account_balance', 10000),
                    'symbol': signal['symbol'],
                    'entry_price': order_result['price'],
                    'timestamp': datetime.now().isoformat()
                })
                
                # 8. í™œì„± ì£¼ë¬¸ ì¶”ì ì— ì¶”ê°€
                self.active_orders[order_result['orderId']] = {
                    'symbol': signal['symbol'],
                    'side': signal['side'],
                    'quantity': position_size,
                    'entry_price': order_result['price'],
                    'stop_orders': stop_orders,
                    'timestamp': datetime.now().isoformat()
                }
                
                return {
                    'status': 'executed',
                    'execution_time_ms': round(execution_time, 2),
                    'slippage_bps': round(slippage * 10000, 2),  # basis points
                    'order_details': {
                        'order_id': order_result['orderId'],
                        'symbol': signal['symbol'],
                        'side': signal['side'],
                        'executed_price': float(order_result['price']),
                        'executed_qty': float(order_result['executedQty']),
                        'leverage': self.leverage,
                        'expected_price': signal.get('price', 0)
                    },
                    'risk_management': {
                        'stop_loss_price': stop_orders['stop_loss'],
                        'take_profit_price': stop_orders['take_profit'],
                        'liquidation_price': self._calculate_liquidation_price(
                            float(order_result['price']), signal['side']
                        )
                    },
                    'metadata': {
                        'execution_mode': 'TEST' if self.test_mode else 'LIVE',
                        'market_condition': market_check.get('condition', 'UNKNOWN'),
                        'timestamp': datetime.now().isoformat()
                    }
                }
            else:
                self._update_execution_stats(0, 0, False, 0)
                return {
                    'status': 'failed',
                    'reason': f"ì£¼ë¬¸ ì‹¤íŒ¨: {order_result.get('msg', order_result.get('error', 'Unknown error'))}",
                    'order_details': order_result
                }
                
        except Exception as e:
            execution_time = (time.time() - execution_start) * 1000
            self._update_execution_stats(execution_time, 0, False, 0)
            logger.error(f"Trade execution error: {e}")
            
            return {
                'status': 'error',
                'error': str(e),
                'execution_time_ms': round(execution_time, 2),
                'timestamp': datetime.now().isoformat()
            }
    
    def _validate_trade_data(self, signal: Dict, risk_approval: Dict) -> Dict:
        """ê±°ë˜ ë°ì´í„° ê²€ì¦"""
        try:
            required_fields = ['symbol', 'side', 'price']
            for field in required_fields:
                if field not in signal:
                    return {'valid': False, 'reason': f'í•„ìˆ˜ í•„ë“œ ëˆ„ë½: {field}'}
            
            # ê°€ê²© ê²€ì¦
            price = float(signal['price'])
            if price <= 0:
                return {'valid': False, 'reason': 'ì˜ëª»ëœ ê°€ê²©'}
            
            # ì‚¬ì´ë“œ ê²€ì¦
            if signal['side'].upper() not in ['BUY', 'SELL']:
                return {'valid': False, 'reason': 'ì˜ëª»ëœ ê±°ë˜ ë°©í–¥'}
            
            # ì‹¬ë³¼ ê²€ì¦ (ê¸°ë³¸ì ì¸ ì²´í¬)
            symbol = signal['symbol']
            if not symbol or len(symbol) < 6:
                return {'valid': False, 'reason': 'ì˜ëª»ëœ ì‹¬ë³¼'}
            
            return {'valid': True, 'reason': ''}
            
        except Exception as e:
            return {'valid': False, 'reason': f'ê²€ì¦ ì˜¤ë¥˜: {str(e)}'}
    
    def _adjust_position_size(self, risk_size: float, price: float) -> float:
        """í¬ì§€ì…˜ í¬ê¸° ì¡°ì • (ìµœì†Œ ë‹¨ìœ„ ë“± ê³ ë ¤)"""
        if price <= 0:
            return 0
        
        # ìµœì†Œ ê±°ë˜ ë‹¨ìœ„ë¡œ ì¡°ì • (ì˜ˆ: 0.001)
        min_quantity = 0.001
        adjusted_quantity = max(min_quantity, round(risk_size / price, 3))
        
        return adjusted_quantity * price  # ë‹¬ëŸ¬ ê°€ì¹˜ë¡œ ë°˜í™˜
    
    async def _check_market_conditions(self, symbol: str) -> Dict:
        """ì‹¤ì‹œê°„ ì‹œì¥ ì¡°ê±´ ì²´í¬"""
        try:
            if self.test_mode:
                # í…ŒìŠ¤íŠ¸ ëª¨ë“œì—ì„œëŠ” í•­ìƒ ê±°ë˜ ê°€ëŠ¥
                return {
                    'tradeable': True,
                    'condition': 'TEST_MODE',
                    'reason': 'Test mode - always tradeable'
                }
            
            # ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” Binance APIë¡œ ì‹œì¥ ìƒíƒœ í™•ì¸
            # í˜„ì¬ëŠ” ì‹œë®¬ë ˆì´ì…˜
            return {
                'tradeable': True,
                'condition': 'NORMAL',
                'reason': 'Market conditions acceptable'
            }
            
        except Exception as e:
            logger.error(f"Market condition check error: {e}")
            return {
                'tradeable': False,
                'condition': 'ERROR',
                'reason': f'Market check failed: {str(e)}'
            }
    
    async def _set_leverage(self, symbol: str) -> Dict:
        """ë ˆë²„ë¦¬ì§€ ì„¤ì • (ê°œì„ ëœ ë²„ì „)"""
        try:
            if self.test_mode:
                logger.info(f"[TEST MODE] Setting {symbol} leverage to {self.leverage}x ISOLATED")
                return {'success': True, 'leverage': self.leverage}
            
            # ì‹¤ì œ Binance API í˜¸ì¶œì€ ì—¬ê¸°ì— êµ¬í˜„
            # í˜„ì¬ëŠ” ì‹œë®¬ë ˆì´ì…˜
            logger.info(f"[LIVE MODE] Setting {symbol} leverage to {self.leverage}x ISOLATED")
            return {'success': True, 'leverage': self.leverage}
            
        except Exception as e:
            logger.error(f"Leverage setting error: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _place_order(self, symbol: str, side: str, quantity: float, price: float) -> Dict:
        """ì£¼ë¬¸ ì‹¤í–‰ (ê°œì„ ëœ ë²„ì „)"""
        try:
            if self.test_mode:
                # í…ŒìŠ¤íŠ¸ ëª¨ë“œ: ê³ ê¸‰ ì‹œë®¬ë ˆì´ì…˜
                order_id = f"TEST_{int(time.time() * 1000)}"
                
                # ì•½ê°„ì˜ ìŠ¬ë¦¬í”¼ì§€ ì‹œë®¬ë ˆì´ì…˜
                slippage_pct = np.random.uniform(-0.001, 0.001)  # Â±0.1% ìŠ¬ë¦¬í”¼ì§€
                executed_price = price * (1 + slippage_pct)
                executed_qty = quantity / executed_price
                
                logger.info(f"[TEST MODE] Placing {side} order: {symbol} @ ${executed_price:,.4f}, qty: {executed_qty:,.6f}")
                
                # ì£¼ë¬¸ ì‹¤í–‰ ì§€ì—° ì‹œë®¬ë ˆì´ì…˜
                await asyncio.sleep(0.1)
                
                return {
                    'orderId': order_id,
                    'status': 'FILLED',
                    'price': str(executed_price),
                    'executedQty': str(executed_qty),
                    'symbol': symbol,
                    'side': side,
                    'timeInForce': 'IOC',
                    'type': 'MARKET'
                }
            
            # ì‹¤ì œ Binance API í˜¸ì¶œ
            # í˜„ì¬ëŠ” ì‹œë®¬ë ˆì´ì…˜ìœ¼ë¡œ ëŒ€ì²´
            order_id = f"LIVE_{int(time.time() * 1000)}"
            logger.info(f"[LIVE MODE] Placing {side} order: {symbol} @ ${price:,.4f}")
            
            return {
                'orderId': order_id,
                'status': 'FILLED',
                'price': str(price),
                'executedQty': str(quantity / price),
                'symbol': symbol,
                'side': side
            }
            
        except Exception as e:
            logger.error(f"Order placement error: {e}")
            return {
                'status': 'FAILED',
                'error': str(e),
                'msg': f'ì£¼ë¬¸ ì‹¤í–‰ ì‹¤íŒ¨: {str(e)}'
            }
    
    async def _set_stop_orders(self, order_result: Dict, side: str) -> Dict:
        """ìµì ˆ/ì†ì ˆ ì£¼ë¬¸ ì„¤ì • (ê°œì„ ëœ ë²„ì „)"""
        try:
            entry_price = float(order_result['price'])
            
            if side.upper() == 'BUY':
                stop_loss = entry_price * (1 - self.stop_loss_pct)
                take_profit = entry_price * (1 + self.take_profit_pct)
            else:  # SELL
                stop_loss = entry_price * (1 + self.stop_loss_pct)
                take_profit = entry_price * (1 - self.take_profit_pct)
            
            if self.test_mode:
                logger.info(f"[TEST MODE] Stop orders set - SL: ${stop_loss:,.4f}, TP: ${take_profit:,.4f}")
            else:
                # ì‹¤ì œ stop ì£¼ë¬¸ ì‹¤í–‰
                logger.info(f"[LIVE MODE] Setting stop orders - SL: ${stop_loss:,.4f}, TP: ${take_profit:,.4f}")
            
            return {
                'stop_loss': stop_loss,
                'take_profit': take_profit,
                'entry_price': entry_price
            }
            
        except Exception as e:
            logger.error(f"Stop order setting error: {e}")
            return {
                'stop_loss': 0,
                'take_profit': 0,
                'error': str(e)
            }
    
    def _calculate_liquidation_price(self, entry_price: float, side: str) -> float:
        """ì²­ì‚°ê°€ ê³„ì‚° (ê°œì„ ëœ ë²„ì „)"""
        try:
            maintenance_margin = 0.004  # 0.4% (Binance ê¸°ì¤€)
            
            if side.upper() == 'BUY':
                # ë¡± í¬ì§€ì…˜ ì²­ì‚°ê°€
                liquidation_price = entry_price * (1 - (1/self.leverage) + maintenance_margin)
            else:  # SELL
                # ìˆ í¬ì§€ì…˜ ì²­ì‚°ê°€
                liquidation_price = entry_price * (1 + (1/self.leverage) - maintenance_margin)
            
            return liquidation_price
            
        except Exception as e:
            logger.error(f"Liquidation price calculation error: {e}")
            return 0.0
    
    def _calculate_slippage(self, expected_price: float, executed_price: float) -> float:
        """ìŠ¬ë¦¬í”¼ì§€ ê³„ì‚°"""
        if expected_price <= 0:
            return 0.0
        
        return (executed_price - expected_price) / expected_price
    
    async def _notify_risk_guardian(self, action: str, data: Dict):
        """Risk Guardianì— ì•Œë¦¼"""
        try:
            notification_data = {
                'action': action,
                **data
            }
            
            result = await call_service('risk-guardian', '/update', notification_data)
            if 'error' in result:
                logger.warning(f"Risk Guardian notification failed: {result['error']}")
            else:
                logger.debug(f"Risk Guardian notified: {action}")
                
        except Exception as e:
            logger.error(f"Risk Guardian notification error: {e}")
    
    def _update_execution_stats(self, execution_time: float, volume: float, success: bool, slippage: float = 0):
        """ì‹¤í–‰ í†µê³„ ì—…ë°ì´íŠ¸ (ê°œì„ ëœ ë²„ì „)"""
        self.execution_stats['total_trades'] += 1
        
        if success:
            self.execution_stats['successful_trades'] += 1
            self.execution_stats['total_volume'] += volume
            
            # í‰ê·  ì‹¤í–‰ ì‹œê°„ ì—…ë°ì´íŠ¸
            current_avg = self.execution_stats['avg_execution_time']
            total_successful = self.execution_stats['successful_trades']
            new_avg = ((current_avg * (total_successful - 1)) + execution_time) / total_successful
            self.execution_stats['avg_execution_time'] = new_avg
            
            # ìŠ¬ë¦¬í”¼ì§€ í†µê³„ ì—…ë°ì´íŠ¸
            slippage_stats = self.execution_stats['slippage_stats']
            slippage_count = slippage_stats['slippage_count']
            
            if slippage_count == 0:
                slippage_stats['avg_slippage'] = abs(slippage)
            else:
                current_avg_slippage = slippage_stats['avg_slippage']
                new_avg_slippage = ((current_avg_slippage * slippage_count) + abs(slippage)) / (slippage_count + 1)
                slippage_stats['avg_slippage'] = new_avg_slippage
            
            slippage_stats['max_slippage'] = max(slippage_stats['max_slippage'], abs(slippage))
            slippage_stats['slippage_count'] += 1
            
        else:
            self.execution_stats['failed_trades'] += 1
        
        # ì„±ëŠ¥ ëª¨ë‹ˆí„°ì—ë„ ê¸°ë¡
        self.performance_monitor.record_request(execution_time, success)
    
    async def monitor_active_positions(self):
        """í™œì„± í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ (ë°±ê·¸ë¼ìš´ë“œ íƒœìŠ¤í¬)"""
        while True:
            try:
                # í™œì„± ì£¼ë¬¸ë“¤ì˜ ìƒíƒœ ì²´í¬
                for order_id, order_info in list(self.active_orders.items()):
                    # ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” Binance APIë¡œ ì£¼ë¬¸ ìƒíƒœ í™•ì¸
                    # í˜„ì¬ëŠ” ì‹œë®¬ë ˆì´ì…˜
                    pass
                
                await asyncio.sleep(30)  # 30ì´ˆë§ˆë‹¤ ì²´í¬
                
            except Exception as e:
                logger.error(f"Position monitoring error: {e}")
                await asyncio.sleep(60)  # ì˜¤ë¥˜ ì‹œ 1ë¶„ ëŒ€ê¸°
    
    def get_execution_report(self) -> Dict:
        """ì™„ì „í•œ ì‹¤í–‰ ë³´ê³ ì„œ"""
        total = self.execution_stats['total_trades']
        success_rate = (
            self.execution_stats['successful_trades'] / total * 100 
            if total > 0 else 0
        )
        
        performance_stats = self.performance_monitor.get_stats()
        
        return {
            'execution_stats': {
                **self.execution_stats,
                'success_rate_pct': round(success_rate, 2),
                'avg_slippage_bps': round(self.execution_stats['slippage_stats']['avg_slippage'] * 10000, 2),
                'max_slippage_bps': round(self.execution_stats['slippage_stats']['max_slippage'] * 10000, 2)
            },
            'configuration': {
                'leverage': self.leverage,
                'stop_loss_pct': self.stop_loss_pct,
                'take_profit_pct': self.take_profit_pct,
                'test_mode': self.test_mode
            },
            'active_positions': {
                'count': len(self.active_orders),
                'orders': list(self.active_orders.keys())
            },
            'performance': performance_stats
        }

# Trade Executor FastAPI ì•±
@asynccontextmanager
async def trade_lifespan(app: FastAPI):
    """Trade Executor ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬"""
    logger.info("âš¡ Trade Executor ì‹œì‘")
    
    # ë°±ê·¸ë¼ìš´ë“œ ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì‹œì‘
    monitor_task = asyncio.create_task(trade_executor.monitor_active_positions())
    
    yield
    
    # ì¢…ë£Œ ì‹œ íƒœìŠ¤í¬ ì •ë¦¬
    monitor_task.cancel()
    try:
        await monitor_task
    except asyncio.CancelledError:
        pass
    
    logger.info("âš¡ Trade Executor ì¢…ë£Œ")

trade_app = FastAPI(
    title="Phoenix 95 Trade Executor",
    version="4.1.0",
    description="í—¤ì§€í€ë“œê¸‰ ê±°ë˜ ì‹¤í–‰ ì‹œìŠ¤í…œ",
    lifespan=trade_lifespan
)

trade_executor = TradeExecutor()

@trade_app.post("/execute")
async def execute_trade(data: dict):
    """ê±°ë˜ ì‹¤í–‰ API"""
    try:
        signal = data.get('signal', {})
        risk_approval = data.get('risk_approval', {})
        
        result = await trade_executor.execute_trade(signal, risk_approval)
        
        return {
            'status': 'success',
            'execution_result': result,
            'timestamp': datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Trade execution API error: {e}")
        raise HTTPException(status_code=500, detail=f"ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨: {str(e)}")

@trade_app.get("/stats")
async def execution_stats():
    """ì‹¤í–‰ í†µê³„ ì¡°íšŒ"""
    return trade_executor.get_execution_report()

@trade_app.get("/positions")
async def active_positions():
    """í™œì„± í¬ì§€ì…˜ ì¡°íšŒ"""
    return {
        'active_orders': trade_executor.active_orders,
        'count': len(trade_executor.active_orders),
        'timestamp': datetime.now().isoformat()
    }

@trade_app.post("/close")
async def close_position(data: dict):
    """í¬ì§€ì…˜ ìˆ˜ë™ ì²­ì‚°"""
    try:
        order_id = data.get('order_id')
        if not order_id or order_id not in trade_executor.active_orders:
            raise HTTPException(status_code=404, detail="ì£¼ë¬¸ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
        
        # ì‹¤ì œë¡œëŠ” Binance APIë¡œ í¬ì§€ì…˜ ì²­ì‚°
        # í˜„ì¬ëŠ” ì‹œë®¬ë ˆì´ì…˜
        order_info = trade_executor.active_orders.pop(order_id)
        
        return {
            'status': 'closed',
            'order_id': order_id,
            'order_info': order_info,
            'timestamp': datetime.now().isoformat()
        }
        
    except Exception as e:
        logger.error(f"Position close error: {e}")
        raise HTTPException(status_code=500, detail=f"í¬ì§€ì…˜ ì²­ì‚° ì‹¤íŒ¨: {str(e)}")

@trade_app.get("/health")
async def health():
    stats = trade_executor.execution_stats
    performance = trade_executor.performance_monitor.get_stats()
    
    return {
        'status': 'healthy',
        'service': 'trade_executor',
        'total_trades': stats['total_trades'],
        'success_rate': (
            stats['successful_trades'] / stats['total_trades'] * 100
            if stats['total_trades'] > 0 else 0
        ),
        'active_positions': len(trade_executor.active_orders),
        'test_mode': trade_executor.test_mode,
        'performance': performance,
        'timestamp': datetime.now().isoformat()
    }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š 4. MONITOR & ALERT (í¬íŠ¸: 8103)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MonitorAlert:
    """í—¤ì§€í€ë“œê¸‰ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.telegram_token = CONFIG.TELEGRAM_TOKEN
        self.chat_id = CONFIG.TELEGRAM_CHAT_ID
        
        # í¬ì§€ì…˜ ë° ìƒíƒœ ì¶”ì 
        self.positions = {}
        self.alerts_sent = set()
        self.alert_history = []
        
        # ì„±ëŠ¥ ë©”íŠ¸ë¦­
        self.performance_metrics = {
            'total_pnl': 0.0,
            'win_rate': 0.0,
            'avg_trade_duration': 0.0,
            'max_drawdown': 0.0,
            'sharpe_ratio': 0.0,
            'total_alerts_sent': 0,
            'system_uptime': time.time()
        }
        
        # ì„±ëŠ¥ ëª¨ë‹ˆí„°
        self.performance_monitor = PerformanceMonitor()
        
        # ì‹œìŠ¤í…œ í—¬ìŠ¤ ë©”íŠ¸ë¦­
        self.system_metrics = {
            'last_health_check': None,
            'service_status': {},
            'alert_queue': []
        }
        
        logger.info("ğŸ“Š Monitor & Alert ì´ˆê¸°í™” ì™„ë£Œ")
    
    async def send_trade_alert(self, trade_data: Dict):
        """ê±°ë˜ ì•Œë¦¼ ì „ì†¡ (ê°œì„ ëœ ë²„ì „)"""
        try:
            execution_result = trade_data.get('execution_result', {})
            
            if execution_result.get('status') == 'executed':
                await self._send_execution_success_alert(execution_result)
                
            elif execution_result.get('status') == 'rejected':
                await self._send_execution_rejected_alert(execution_result)
                
            elif execution_result.get('status') == 'failed':
                await self._send_execution_failed_alert(execution_result)
            
            # ì•Œë¦¼ í†µê³„ ì—…ë°ì´íŠ¸
            self.performance_metrics['total_alerts_sent'] += 1
            
        except Exception as e:
            logger.error(f"Trade alert error: {e}")
    
    async def _send_execution_success_alert(self, execution_result: Dict):
        """ê±°ë˜ ì„±ê³µ ì•Œë¦¼"""
        order_details = execution_result.get('order_details', {})
        risk_mgmt = execution_result.get('risk_management', {})
        metadata = execution_result.get('metadata', {})
        
        # ìŠ¬ë¦¬í”¼ì§€ ê³„ì‚°
        slippage_bps = execution_result.get('slippage_bps', 0)
        slippage_emoji = "ğŸŸ¢" if abs(slippage_bps) < 5 else "ğŸŸ¡" if abs(slippage_bps) < 10 else "ğŸ”´"
        
        message = f"""
ğŸ¦ <b>í—¤ì§€í€ë“œ ê±°ë˜ ì‹¤í–‰ ì„±ê³µ</b>

ğŸ“Š <b>ê¸°ë³¸ ì •ë³´</b>
â€¢ ì‹¬ë³¼: <code>{order_details.get('symbol', 'UNKNOWN')}</code>
â€¢ ë°©í–¥: <b>{order_details.get('side', 'UNKNOWN')}</b>
â€¢ ì˜ˆìƒê°€: <code>${order_details.get('expected_price', 0):,.4f}</code>
â€¢ ì‹¤ì œê°€: <code>${order_details.get('executed_price', 0):,.4f}</code>
â€¢ ìˆ˜ëŸ‰: <code>{order_details.get('executed_qty', 0):,.6f}</code>

âš¡ <b>ì‹¤í–‰ ì„±ê³¼</b>
â€¢ ë ˆë²„ë¦¬ì§€: <b>{order_details.get('leverage', 20)}x ISOLATED</b>
â€¢ ì‹¤í–‰ì‹œê°„: <b>{execution_result.get('execution_time_ms', 0):.1f}ms</b>
â€¢ ìŠ¬ë¦¬í”¼ì§€: {slippage_emoji} <b>{slippage_bps:+.1f}bp</b>
â€¢ ì²­ì‚°ê°€: <code>${risk_mgmt.get('liquidation_price', 0):,.4f}</code>

ğŸ¯ <b>ë¦¬ìŠ¤í¬ ê´€ë¦¬</b>
â€¢ ìµì ˆê°€: <code>${risk_mgmt.get('take_profit_price', 0):,.4f}</code> (+{CONFIG.TAKE_PROFIT:.1%})
â€¢ ì†ì ˆê°€: <code>${risk_mgmt.get('stop_loss_price', 0):,.4f}</code> (-{CONFIG.STOP_LOSS:.1%})

ğŸ“ˆ <b>ë©”íƒ€ë°ì´í„°</b>
â€¢ ì£¼ë¬¸ID: <code>{order_details.get('order_id', 'N/A')}</code>
â€¢ ëª¨ë“œ: <b>{metadata.get('execution_mode', 'UNKNOWN')}</b>
â€¢ ì‹œì¥ìƒí™©: <b>{metadata.get('market_condition', 'UNKNOWN')}</b>

â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        await self._send_telegram(message)
    
    async def _send_execution_rejected_alert(self, execution_result: Dict):
        """ê±°ë˜ ê±°ì ˆ ì•Œë¦¼"""
        message = f"""
ğŸš« <b>ê±°ë˜ ê±°ì ˆ</b>

âŒ <b>ê±°ì ˆ ì‚¬ìœ :</b> {execution_result.get('reason', 'Unknown')}

ğŸ” <b>ë¦¬ìŠ¤í¬ ì²´í¬ ì‹¤íŒ¨:</b>
{chr(10).join(f"â€¢ {check}" for check in execution_result.get('risk_checks', []))}

âš ï¸ <b>ì‹œìŠ¤í…œì´ ì•ˆì „ì„ ìœ„í•´ ê±°ë˜ë¥¼ ì°¨ë‹¨í–ˆìŠµë‹ˆë‹¤.</b>

â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        await self._send_telegram(message)
    
    async def _send_execution_failed_alert(self, execution_result: Dict):
        """ê±°ë˜ ì‹¤íŒ¨ ì•Œë¦¼"""
        message = f"""
âŒ <b>ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨</b>

ğŸ” <b>ì‹¤íŒ¨ ì‚¬ìœ :</b> {execution_result.get('reason', 'Unknown')}

âš™ï¸ <b>ê¸°ìˆ ì  ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.</b>
ì‹œìŠ¤í…œ ê´€ë¦¬ìì—ê²Œ ë¬¸ì˜í•˜ì„¸ìš”.

â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        await self._send_telegram(message)
    
    async def send_system_alert(self, alert_type: str, message: str, severity: str = 'INFO'):
        """ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡ (ê°œì„ ëœ ë²„ì „)"""
        try:
            # ì¤‘ë³µ ì•Œë¦¼ ë°©ì§€
            alert_key = f"{alert_type}_{message}_{severity}"
            if alert_key in self.alerts_sent:
                return
            
            emoji_map = {
                'INFO': 'â„¹ï¸',
                'WARNING': 'âš ï¸',
                'ERROR': 'âŒ',
                'CRITICAL': 'ğŸš¨',
                'SUCCESS': 'âœ…'
            }
            
            emoji = emoji_map.get(severity, 'â„¹ï¸')
            
            formatted_message = f"""
{emoji} <b>ì‹œìŠ¤í…œ ì•Œë¦¼</b>

ğŸ“‹ <b>ìœ í˜•:</b> {alert_type}
ğŸ” <b>ë‚´ìš©:</b> {message}
ğŸ“Š <b>ì‹¬ê°ë„:</b> {severity}

â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
            
            await self._send_telegram(formatted_message)
            
            # ì•Œë¦¼ ê¸°ë¡
            self.alerts_sent.add(alert_key)
            self.alert_history.append({
                'type': alert_type,
                'message': message,
                'severity': severity,
                'timestamp': datetime.now().isoformat()
            })
            
            # ì•Œë¦¼ ê¸°ë¡ í¬ê¸° ì œí•œ
            if len(self.alert_history) > 100:
                self.alert_history = self.alert_history[-50:]
            
            # ì¤‘ë³µ ë°©ì§€ ìºì‹œ í¬ê¸° ì œí•œ
            if len(self.alerts_sent) > 200:
                # ì˜¤ë˜ëœ ì•Œë¦¼ ì œê±°
                self.alerts_sent.clear()
            
        except Exception as e:
            logger.error(f"System alert error: {e}")
    
    async def send_performance_report(self, report_type: str = 'daily'):
        """ì„±ëŠ¥ ë³´ê³ ì„œ ì „ì†¡ (ê°œì„ ëœ ë²„ì „)"""
        try:
            performance_data = await self._collect_performance_data()
            
            if report_type == 'daily':
                await self._send_daily_report(performance_data)
            elif report_type == 'weekly':
                await self._send_weekly_report(performance_data)
            elif report_type == 'system':
                await self._send_system_report(performance_data)
            
        except Exception as e:
            logger.error(f"Performance report error: {e}")
    
    async def _send_daily_report(self, performance_data: Dict):
        """ì¼ì¼ ì„±ê³¼ ë³´ê³ ì„œ"""
        uptime_hours = (time.time() - self.performance_metrics['system_uptime']) / 3600
        
        message = f"""
ğŸ“ˆ <b>Phoenix 95 ì¼ì¼ ì„±ê³¼ ë³´ê³ ì„œ</b>

ğŸ¦ <b>ê±°ë˜ ì„±ê³¼</b>
â€¢ ì¼ì¼ P&L: <b>{performance_data.get('daily_pnl', 0):+.2%}</b>
â€¢ ì´ ê±°ë˜: <b>{performance_data.get('total_trades', 0)}íšŒ</b>
â€¢ ìŠ¹ë¥ : <b>{performance_data.get('win_rate', 0):.1%}</b>
â€¢ ì‹¤í–‰ ì„±ê³µë¥ : <b>{performance_data.get('execution_success_rate', 0):.1%}</b>

âš¡ <b>ì‹œìŠ¤í…œ ì„±ëŠ¥</b>
â€¢ í‰ê·  ì‘ë‹µì‹œê°„: <b>{performance_data.get('avg_response_time', 0):.1f}ms</b>
â€¢ ì‹œìŠ¤í…œ ê°€ë™ë¥ : <b>{uptime_hours:.1f}ì‹œê°„</b>
â€¢ ì´ ì•Œë¦¼: <b>{self.performance_metrics['total_alerts_sent']}ê°œ</b>

ğŸ›¡ï¸ <b>ë¦¬ìŠ¤í¬ í˜„í™©</b>
â€¢ í™œì„± í¬ì§€ì…˜: <b>{performance_data.get('active_positions', 0)}ê°œ</b>
â€¢ ì´ ë…¸ì¶œ: <b>{performance_data.get('total_exposure', 0):.1%}</b>
â€¢ ìµœëŒ€ ì†ì‹¤: <b>{performance_data.get('max_drawdown', 0):.2%}</b>

â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        await self._send_telegram(message)
    
    async def _send_system_report(self, performance_data: Dict):
        """ì‹œìŠ¤í…œ ìƒíƒœ ë³´ê³ ì„œ"""
        services_status = await self._get_all_services_status()
        healthy_services = sum(1 for status in services_status.values() if status.get('status') == 'healthy')
        total_services = len(services_status)
        
        message = f"""
ğŸ”§ <b>Phoenix 95 ì‹œìŠ¤í…œ ìƒíƒœ</b>

ğŸ–¥ï¸ <b>ì„œë¹„ìŠ¤ ìƒíƒœ</b>
â€¢ ì •ìƒ ì„œë¹„ìŠ¤: <b>{healthy_services}/{total_services}</b>
â€¢ Signal Engine: {'âœ…' if services_status.get('signal_engine', {}).get('status') == 'healthy' else 'âŒ'}
â€¢ Risk Guardian: {'âœ…' if services_status.get('risk_guardian', {}).get('status') == 'healthy' else 'âŒ'}
â€¢ Trade Executor: {'âœ…' if services_status.get('trade_executor', {}).get('status') == 'healthy' else 'âŒ'}
â€¢ Monitor & Alert: {'âœ…' if services_status.get('monitor_alert', {}).get('status') == 'healthy' else 'âŒ'}

ğŸ“Š <b>ì„±ëŠ¥ ì§€í‘œ</b>
â€¢ í‰ê·  ì‘ë‹µì‹œê°„: <b>{performance_data.get('avg_response_time', 0):.1f}ms</b>
â€¢ P95 ì‘ë‹µì‹œê°„: <b>{performance_data.get('p95_response_time', 0):.1f}ms</b>
â€¢ ì˜¤ë¥˜ìœ¨: <b>{performance_data.get('error_rate', 0):.1%}</b>

ğŸ’¾ <b>ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤</b>
â€¢ CPU ì‚¬ìš©ë¥ : <b>{psutil.cpu_percent():.1f}%</b>
â€¢ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : <b>{psutil.virtual_memory().percent:.1f}%</b>

â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        await self._send_telegram(message)
    
    async def _collect_performance_data(self) -> Dict:
        """ì„±ëŠ¥ ë°ì´í„° ìˆ˜ì§‘ (ê°œì„ ëœ ë²„ì „)"""
        try:
            # ê° ì„œë¹„ìŠ¤ì—ì„œ ë°ì´í„° ìˆ˜ì§‘
            tasks = [
                call_service('risk-guardian', '/status', method='GET'),
                call_service('trade-executor', '/stats', method='GET'),
                call_service('signal-engine', '/stats', method='GET')
            ]
            
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            risk_data = results[0] if not isinstance(results[0], Exception) else {}
            trade_data = results[1] if not isinstance(results[1], Exception) else {}
            signal_data = results[2] if not isinstance(results[2], Exception) else {}
            
            # ì„±ëŠ¥ ì§€í‘œ ê³„ì‚°
            monitor_stats = self.performance_monitor.get_stats()
            
            return {
                # ê±°ë˜ ì„±ê³¼
                'daily_pnl': risk_data.get('current_status', {}).get('daily_pnl', 0),
                'total_pnl': risk_data.get('current_status', {}).get('daily_pnl', 0),  # ì‹¤ì œë¡œëŠ” ëˆ„ì  ê³„ì‚°
                'active_positions': risk_data.get('current_status', {}).get('active_positions', 0),
                'total_exposure': risk_data.get('current_status', {}).get('total_exposure', 0),
                'max_drawdown': risk_data.get('metrics', {}).get('max_drawdown', 0),
                
                # ê±°ë˜ í†µê³„
                'total_trades': trade_data.get('execution_stats', {}).get('total_trades', 0),
                'execution_success_rate': trade_data.get('execution_stats', {}).get('success_rate_pct', 0),
                'win_rate': risk_data.get('metrics', {}).get('win_rate', 0),
                'avg_trade_duration': risk_data.get('metrics', {}).get('avg_holding_time', 0),
                
                # ì‹œìŠ¤í…œ ì„±ëŠ¥
                'avg_response_time': monitor_stats.get('avg_response_time', 0),
                'p95_response_time': monitor_stats.get('p95_response_time', 0),
                'p99_response_time': monitor_stats.get('p99_response_time', 0),
                'error_rate': 100 - monitor_stats.get('success_rate', 100),
                'uptime': monitor_stats.get('uptime', 0),
                
                # ì•Œë¦¼ í†µê³„
                'total_alerts': self.performance_metrics['total_alerts_sent'],
                'recent_alerts': len(self.alert_history[-10:]) if self.alert_history else 0
            }
            
        except Exception as e:
            logger.error(f"Performance data collection error: {e}")
            return {}
    
    async def _get_all_services_status(self) -> Dict:
        """ëª¨ë“  ì„œë¹„ìŠ¤ ìƒíƒœ ì¡°íšŒ"""
        services = {
            'signal_engine': 'http://localhost:8100/health',
            'risk_guardian': 'http://localhost:8101/health',
            'trade_executor': 'http://localhost:8102/health'
        }
        
        results = {}
        
        for service_name, url in services.items():
            try:
                start_time = time.time()
                response = requests.get(url, timeout=5)
                response_time = (time.time() - start_time) * 1000
                
                if response.status_code == 200:
                    results[service_name] = {
                        'status': 'healthy',
                        'response_time_ms': round(response_time, 2),
                        'data': response.json()
                    }
                else:
                    results[service_name] = {
                        'status': 'unhealthy',
                        'http_status': response.status_code,
                        'response_time_ms': round(response_time, 2)
                    }
            except Exception as e:
                results[service_name] = {
                    'status': 'unreachable',
                    'error': str(e)
                }
        
        return results
    
    async def health_check_all_services(self) -> Dict:
        """ì „ì²´ ì„œë¹„ìŠ¤ í—¬ìŠ¤ì²´í¬ (ê°œì„ ëœ ë²„ì „)"""
        start_time = time.time()
        
        try:
            services_status = await self._get_all_services_status()
            
            healthy_count = sum(1 for status in services_status.values() 
                              if status.get('status') == 'healthy')
            total_services = len(services_status)
            
            overall_status = 'healthy' if healthy_count == total_services else 'degraded'
            if healthy_count == 0:
                overall_status = 'critical'
            
            # ì‘ë‹µì‹œê°„ í†µê³„
            response_times = [
                status.get('response_time_ms', 0) 
                for status in services_status.values() 
                if status.get('response_time_ms')
            ]
            
            avg_response_time = np.mean(response_times) if response_times else 0
            max_response_time = max(response_times) if response_times else 0
            
            # í—¬ìŠ¤ì²´í¬ ìì²´ ì„±ëŠ¥ ê¸°ë¡
            check_time = (time.time() - start_time) * 1000
            self.performance_monitor.record_request(check_time, overall_status == 'healthy')
            
            result = {
                'overall_status': overall_status,
                'healthy_services': healthy_count,
                'total_services': total_services,
                'services': services_status,
                'performance': {
                    'avg_response_time_ms': round(avg_response_time, 2),
                    'max_response_time_ms': round(max_response_time, 2),
                    'health_check_time_ms': round(check_time, 2)
                },
                'timestamp': datetime.now().isoformat()
            }
            
            # ì‹œìŠ¤í…œ ìƒíƒœ ìºì‹œ ì—…ë°ì´íŠ¸
            self.system_metrics['last_health_check'] = datetime.now()
            self.system_metrics['service_status'] = services_status
            
            return result
            
        except Exception as e:
            logger.error(f"Health check error: {e}")
            return {
                'overall_status': 'error',
                'error': str(e),
                'timestamp': datetime.now().isoformat()
            }
    
    async def _send_telegram(self, message: str):
        """í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ (ê°œì„ ëœ ë²„ì „)"""
        url = f"https://api.telegram.org/bot{self.telegram_token}/sendMessage"
        data = {
            'chat_id': self.chat_id,
            'text': message,
            'parse_mode': 'HTML',
            'disable_web_page_preview': True
        }
        
        max_retries = 3
        for attempt in range(max_retries):
            try:
                response = requests.post(url, data=data, timeout=10)
                if response.status_code == 200:
                    logger.debug(f"âœ… í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì „ì†¡ ì„±ê³µ (ì‹œë„ {attempt + 1})")
                    return True
                else:
                    logger.warning(f"âŒ í…”ë ˆê·¸ë¨ ì „ì†¡ ì‹¤íŒ¨: HTTP {response.status_code}")
                    if attempt < max_retries - 1:
                        await asyncio.sleep(2 ** attempt)  # ì§€ìˆ˜ë°±ì˜¤í”„
                        
            except Exception as e:
                logger.warning(f"âŒ í…”ë ˆê·¸ë¨ ì˜¤ë¥˜ (ì‹œë„ {attempt + 1}): {e}")
                if attempt < max_retries - 1:
                    await asyncio.sleep(2 ** attempt)
        
        logger.error(f"âŒ í…”ë ˆê·¸ë¨ ì „ì†¡ ìµœì¢… ì‹¤íŒ¨ ({max_retries}íšŒ ì‹œë„)")
        return False
    
    async def start_periodic_reports(self):
        """ì£¼ê¸°ì  ë³´ê³ ì„œ ì „ì†¡ ë°±ê·¸ë¼ìš´ë“œ íƒœìŠ¤í¬"""
        while True:
            try:
                now = datetime.now()
                
                # ë§¤ ì‹œê°„ ì‹œìŠ¤í…œ ìƒíƒœ ì²´í¬
                if now.minute == 0:
                    await self.send_performance_report('system')
                
                # ë§¤ì¼ 00:00ì— ì¼ì¼ ë³´ê³ ì„œ
                if now.hour == 0 and now.minute == 0:
                    await self.send_performance_report('daily')
                
                # ë§¤ì£¼ ì›”ìš”ì¼ 09:00ì— ì£¼ê°„ ë³´ê³ ì„œ
                if now.weekday() == 0 and now.hour == 9 and now.minute == 0:
                    await self.send_performance_report('weekly')
                
                await asyncio.sleep(60)  # 1ë¶„ë§ˆë‹¤ ì²´í¬
                
            except Exception as e:
                logger.error(f"Periodic report error: {e}")
                await asyncio.sleep(300)  # ì˜¤ë¥˜ ì‹œ 5ë¶„ ëŒ€ê¸°
    
    def get_monitor_stats(self) -> Dict:
        """ëª¨ë‹ˆí„° ì‹œìŠ¤í…œ í†µê³„"""
        return {
            'performance_metrics': self.performance_metrics,
            'system_metrics': self.system_metrics,
            'alert_stats': {
                'total_sent': self.performance_metrics['total_alerts_sent'],
                'recent_alerts': len(self.alert_history[-10:]) if self.alert_history else 0,
                'alert_types': {}  # ì•Œë¦¼ íƒ€ì…ë³„ í†µê³„
            },
            'monitor_performance': self.performance_monitor.get_stats()
        }

# Monitor & Alert FastAPI ì•±
@asynccontextmanager
async def monitor_lifespan(app: FastAPI):
    """Monitor & Alert ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬"""
    logger.info("ğŸ“Š Monitor & Alert ì‹œì‘")
    
    # ì£¼ê¸°ì  ë³´ê³ ì„œ íƒœìŠ¤í¬ ì‹œì‘
    report_task = asyncio.create_task(monitor_alert.start_periodic_reports())
    
    # ì‹œì‘ ì•Œë¦¼ ì „ì†¡
    await monitor_alert.send_system_alert(
        'SYSTEM_START', 
        'Phoenix 95 ì‹œìŠ¤í…œì´ ì„±ê³µì ìœ¼ë¡œ ì‹œì‘ë˜ì—ˆìŠµë‹ˆë‹¤', 
        'SUCCESS'
    )
    
    yield
    
    # ì¢…ë£Œ ì‹œ íƒœìŠ¤í¬ ì •ë¦¬
    report_task.cancel()
    try:
        await report_task
    except asyncio.CancelledError:
        pass
    
    # ì¢…ë£Œ ì•Œë¦¼ ì „ì†¡
    await monitor_alert.send_system_alert(
        'SYSTEM_STOP', 
        'Phoenix 95 ì‹œìŠ¤í…œì´ ì•ˆì „í•˜ê²Œ ì¢…ë£Œë©ë‹ˆë‹¤', 
        'INFO'
    )
    
    logger.info("ğŸ“Š Monitor & Alert ì¢…ë£Œ")

monitor_app = FastAPI(
    title="Phoenix 95 Monitor & Alert",
    version="4.1.0",
    description="í—¤ì§€í€ë“œê¸‰ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ",
    lifespan=monitor_lifespan
)

monitor_alert = MonitorAlert()

@monitor_app.post("/alert/trade")
async def trade_alert(data: dict):
    """ê±°ë˜ ì•Œë¦¼"""
    await monitor_alert.send_trade_alert(data)
    return {'status': 'sent', 'timestamp': datetime.now().isoformat()}

@monitor_app.post("/alert/system")
async def system_alert(data: dict):
    """ì‹œìŠ¤í…œ ì•Œë¦¼"""
    alert_type = data.get('type', 'SYSTEM')
    message = data.get('message', 'Unknown system event')
    severity = data.get('severity', 'INFO')
    
    await monitor_alert.send_system_alert(alert_type, message, severity)
    return {'status': 'sent', 'timestamp': datetime.now().isoformat()}

@monitor_app.get("/health/all")
async def health_check_all():
    """ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬"""
    return await monitor_alert.health_check_all_services()

@monitor_app.post("/report/performance")
async def performance_report(data: dict = None):
    """ì„±ëŠ¥ ë³´ê³ ì„œ ì „ì†¡"""
    report_type = data.get('type', 'daily') if data else 'daily'
    await monitor_alert.send_performance_report(report_type)
    return {'status': 'sent', 'type': report_type, 'timestamp': datetime.now().isoformat()}

@monitor_app.get("/stats")
async def monitor_stats():
    """ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ í†µê³„"""
    return monitor_alert.get_monitor_stats()

@monitor_app.get("/alerts/history")
async def alert_history():
    """ì•Œë¦¼ ê¸°ë¡ ì¡°íšŒ"""
    return {
        'alerts': monitor_alert.alert_history[-50:],  # ìµœê·¼ 50ê°œ
        'total_alerts': len(monitor_alert.alert_history),
        'timestamp': datetime.now().isoformat()
    }

@monitor_app.get("/health")
async def health():
    stats = monitor_alert.performance_monitor.get_stats()
    return {
        'status': 'healthy',
        'service': 'monitor_alert',
        'telegram_configured': bool(monitor_alert.telegram_token),
        'performance': stats,
        'alerts_sent': monitor_alert.performance_metrics['total_alerts_sent'],
        'uptime_hours': (time.time() - monitor_alert.performance_metrics['system_uptime']) / 3600,
        'timestamp': datetime.now().isoformat()
    }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ ë©”ì¸ ì‹œìŠ¤í…œ ëŸ°ì²˜ ë° ê´€ë¦¬
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SystemManager:
    """ì‹œìŠ¤í…œ ë§¤ë‹ˆì € - ì „ì²´ ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬"""
    
    def __init__(self):
        self.processes = []
        self.shutdown_event = asyncio.Event()
        self.health_monitor_task = None
        
    def setup_signal_handlers(self):
        """ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ ì„¤ì •"""
        def signal_handler(signum, frame):
            logger.info(f"ì‹ í˜¸ ìˆ˜ì‹ : {signum}")
            asyncio.create_task(self.shutdown())
        
        signal.signal(signal.SIGTERM, signal_handler)
        signal.signal(signal.SIGINT, signal_handler)
    
    async def start_services(self):
        """ì„œë¹„ìŠ¤ ì‹œì‘"""
        services = [
            ('Signal Engine', run_signal_engine, 8100),
            ('Risk Guardian', run_risk_guardian, 8101),
            ('Trade Executor', run_trade_executor, 8102),
            ('Monitor & Alert', run_monitor_alert, 8103)
        ]
        
        for name, func, port in services:
            process = multiprocessing.Process(target=func, name=name)
            process.start()
            self.processes.append((name, process, port))
            logger.info(f"ğŸš€ {name} ì‹œì‘ë¨ (PID: {process.pid}, Port: {port})")
        
        # ì„œë¹„ìŠ¤ ì‹œì‘ ëŒ€ê¸°
        await asyncio.sleep(5)
        
        # í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì‹œì‘
        self.health_monitor_task = asyncio.create_task(self.health_monitor())
    
    async def health_monitor(self):
        """í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§"""
        logger.info("ğŸ” ì‹œìŠ¤í…œ í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì‹œì‘")
        
        consecutive_failures = 0
        
        while not self.shutdown_event.is_set():
            try:
                # Monitor ì„œë¹„ìŠ¤ë¥¼ í†µí•œ ì „ì²´ í—¬ìŠ¤ì²´í¬
                start_time = time.time()
                
                try:
                    response = requests.get('http://localhost:8103/health/all', timeout=10)
                    if response.status_code == 200:
                        health_data = response.json()
                        consecutive_failures = 0
                    else:
                        raise Exception(f"HTTP {response.status_code}")
                        
                except Exception as e:
                    consecutive_failures += 1
                    logger.warning(f"í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨ ({consecutive_failures}íšŒ): {e}")
                    
                    if consecutive_failures >= 3:
                        logger.error("ì—°ì† í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨ - ì‹œìŠ¤í…œ ì ê²€ í•„ìš”")
                        # ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” ì•Œë¦¼ ì „ì†¡ ë“± ì²˜ë¦¬
                    
                    await asyncio.sleep(30)
                    continue
                
                # ìƒíƒœ ì¶œë ¥
                timestamp = datetime.now().strftime('%H:%M:%S')
                status = health_data.get('overall_status', 'unknown')
                healthy = health_data.get('healthy_services', 0)
                total = health_data.get('total_services', 0)
                
                status_emoji = 'âœ…' if status == 'healthy' else 'âš ï¸' if status == 'degraded' else 'âŒ'
                logger.info(f"{status_emoji} [{timestamp}] ì‹œìŠ¤í…œ: {status.upper()} ({healthy}/{total})")
                
                # ê° ì„œë¹„ìŠ¤ ìƒíƒœ ì¶œë ¥
                services = health_data.get('services', {})
                for service, data in services.items():
                    service_status = data.get('status', 'unknown')
                    if service_status == 'healthy':
                        response_time = data.get('response_time_ms', 0)
                        logger.debug(f"   âœ… {service}: OK ({response_time:.1f}ms)")
                    else:
                        error = data.get('error', data.get('http_status', 'Unknown'))
                        logger.warning(f"   âŒ {service}: {error}")
                
                await asyncio.sleep(CONFIG.HEALTH_CHECK_INTERVAL)
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜: {e}")
                await asyncio.sleep(60)
        
        logger.info("ğŸ” í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ")
    
    async def shutdown(self):
        """ì•ˆì „í•œ ì‹œìŠ¤í…œ ì¢…ë£Œ"""
        logger.info("ğŸ›‘ ì‹œìŠ¤í…œ ì¢…ë£Œ ì‹œì‘...")
        
        # í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì¤‘ì§€
        self.shutdown_event.set()
        if self.health_monitor_task:
            self.health_monitor_task.cancel()
            try:
                await self.health_monitor_task
            except asyncio.CancelledError:
                pass
        
        # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
        for name, process, port in self.processes:
            logger.info(f"ğŸ›‘ {name} ì¢…ë£Œ ì¤‘...")
            process.terminate()
            
            # í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ ëŒ€ê¸° (ìµœëŒ€ 10ì´ˆ)
            try:
                process.join(timeout=10)
                if process.is_alive():
                    logger.warning(f"âš ï¸ {name} ê°•ì œ ì¢…ë£Œ")
                    process.kill()
                    process.join()
                logger.info(f"âœ… {name} ì¢…ë£Œ ì™„ë£Œ")
            except Exception as e:
                logger.error(f"âŒ {name} ì¢…ë£Œ ì˜¤ë¥˜: {e}")
        
        logger.info("âœ… ëª¨ë“  ì„œë¹„ìŠ¤ê°€ ì•ˆì „í•˜ê²Œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤")

def run_signal_engine():
    """Signal Engine ì‹¤í–‰"""
    uvicorn.run(signal_app, host="0.0.0.0", port=8100, log_level="error")

def run_risk_guardian():
    """Risk Guardian ì‹¤í–‰"""
    uvicorn.run(risk_app, host="0.0.0.0", port=8101, log_level="error")

def run_trade_executor():
    """Trade Executor ì‹¤í–‰"""
    uvicorn.run(trade_app, host="0.0.0.0", port=8102, log_level="error")

def run_monitor_alert():
    """Monitor & Alert ì‹¤í–‰"""
    uvicorn.run(monitor_app, host="0.0.0.0", port=8103, log_level="error")

async def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    
    # ì‹œìŠ¤í…œ ì •ë³´ ì¶œë ¥
    print("=" * 70)
    print("ğŸ¦ Phoenix 95 í—¤ì§€í€ë“œê¸‰ ì‹œìŠ¤í…œ V4.1 - í†µí•© ë²„ì „")
    print("=" * 70)
    print()
    print("ğŸ¯ í•µì‹¬ ê°œì„ ì‚¬í•­:")
    print("   âœ… ì™„ì „í•œ ì˜¤ë¥˜ ìˆ˜ì • ë° ì˜ˆì™¸ì²˜ë¦¬ ê°•í™”")
    print("   âœ… ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ë° ìºì‹± ì‹œìŠ¤í…œ ì¶”ê°€")
    print("   âœ… ë™ì  ë¦¬ìŠ¤í¬ ì¡°ì • ë° ê³ ê¸‰ í¬ì§€ì…˜ ì‚¬ì´ì§•")
    print("   âœ… ì‹¤ì‹œê°„ ìŠ¬ë¦¬í”¼ì§€ ì¶”ì  ë° ì‹œì¥ ì¡°ê±´ ì²´í¬")
    print("   âœ… ì™„ì „í•œ ë°±ê·¸ë¼ìš´ë“œ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ")
    print()
    print("ğŸ—ï¸ ì„œë¹„ìŠ¤ êµ¬ì„±:")
    print("   ğŸ§  Signal Engine (AI ë¶„ì„): http://localhost:8100")
    print("   ğŸ›¡ï¸ Risk Guardian (ë¦¬ìŠ¤í¬): http://localhost:8101")
    print("   âš¡ Trade Executor (ê±°ë˜): http://localhost:8102")
    print("   ğŸ“Š Monitor & Alert (ì•Œë¦¼): http://localhost:8103")
    print()
    print("ğŸ”§ ì„¤ì •:")
    print(f"   â€¢ ë ˆë²„ë¦¬ì§€: {CONFIG.LEVERAGE}x ISOLATED")
    print(f"   â€¢ ìµì ˆ/ì†ì ˆ: Â±{CONFIG.STOP_LOSS:.1%}")
    print(f"   â€¢ ìµœì†Œ ì‹ ë¢°ë„: {CONFIG.MIN_CONFIDENCE:.1%}")
    print(f"   â€¢ ìµœëŒ€ ì¼ì¼ì†ì‹¤: {CONFIG.MAX_DAILY_LOSS:.1%}")
    print(f"   â€¢ ëª©í‘œ ì‘ë‹µì‹œê°„: {CONFIG.TARGET_RESPONSE_TIME}ms")
    print()
    
    # í™˜ê²½ ì„¤ì • ì²´í¬
    trade_mode = os.getenv('TRADE_MODE', 'TEST')
    print(f"ğŸ“Š ê±°ë˜ ëª¨ë“œ: {trade_mode}")
    
    if trade_mode == 'LIVE':
        binance_key = os.getenv('BINANCE_API_KEY')
        if not binance_key:
            print("âš ï¸  LIVE ëª¨ë“œì´ì§€ë§Œ Binance API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ")
            print("   í™˜ê²½ë³€ìˆ˜ë¥¼ ì„¤ì •í•˜ê±°ë‚˜ TEST ëª¨ë“œë¡œ ì‹¤í–‰í•˜ì„¸ìš”")
    
    print("=" * 70)
    
    # ì‹œìŠ¤í…œ ë§¤ë‹ˆì € ì‹œì‘
    system_manager = SystemManager()
    system_manager.setup_signal_handlers()
    
    try:
        await system_manager.start_services()
        
        # ì‹œìŠ¤í…œ ì‹¤í–‰ ëŒ€ê¸°
        await system_manager.shutdown_event.wait()
        
    except KeyboardInterrupt:
        logger.info("ì‚¬ìš©ì ì¤‘ë‹¨ ìš”ì²­")
    except Exception as e:
        logger.error(f"ì‹œìŠ¤í…œ ì˜¤ë¥˜: {e}")
    finally:
        await system_manager.shutdown()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ ì‹¤í–‰ ì§„ì…ì 
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    # í™˜ê²½ë³€ìˆ˜ ê¸°ë³¸ê°’ ì„¤ì •
    if not os.getenv('TRADE_MODE'):
        os.environ['TRADE_MODE'] = 'TEST'
    
    if not os.getenv('TELEGRAM_TOKEN'):
        os.environ['TELEGRAM_TOKEN'] = CONFIG.TELEGRAM_TOKEN
        
    if not os.getenv('TELEGRAM_CHAT_ID'):
        os.environ['TELEGRAM_CHAT_ID'] = CONFIG.TELEGRAM_CHAT_ID
    
    # ë©€í‹°í”„ë¡œì„¸ì‹± ì„¤ì •
    multiprocessing.set_start_method('spawn', force=True)
    
    # ë©”ì¸ ì‹¤í–‰
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nğŸ‘‹ Phoenix 95 ì‹œìŠ¤í…œì„ ì¢…ë£Œí•©ë‹ˆë‹¤")
    except Exception as e:
        print(f"\nâŒ ì‹œìŠ¤í…œ ì˜¤ë¥˜: {e}")
        sys.exit(1)

"""
ğŸ¦ Phoenix 95 í—¤ì§€í€ë“œê¸‰ ì‹œìŠ¤í…œ V4.1 - ì™„ì „ í†µí•© ë²„ì „

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“‹ ì£¼ìš” ê°œì„ ì‚¬í•­ (V4.0 â†’ V4.1)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”§ ì˜¤ë¥˜ ìˆ˜ì • ë° ì•ˆì •ì„± ê°•í™”:
âœ… ëª¨ë“  import ë¬¸ ì¶”ê°€ (math, hashlib, psutil ë“±)
âœ… ë¹„ë™ê¸° í•¨ìˆ˜ await ëˆ„ë½ ìˆ˜ì •
âœ… ì˜ˆì™¸ ì²˜ë¦¬ ê°•í™” ë° ì¬ì‹œë„ ë¡œì§ ì¶”ê°€
âœ… íƒ€ì… íŒíŠ¸ ê°œì„  ë° ë°ì´í„° ê²€ì¦ ê°•í™”

âš¡ ì„±ëŠ¥ ê°œì„ :
âœ… ë©”ëª¨ë¦¬ ìºì‹± ì‹œìŠ¤í…œ ì¶”ê°€ (60ì´ˆ TTL)
âœ… ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ í´ë˜ìŠ¤ êµ¬í˜„
âœ… ì§€ìˆ˜ë°±ì˜¤í”„ ì¬ì‹œë„ ë©”ì»¤ë‹ˆì¦˜
âœ… ì‘ë‹µì‹œê°„ P95/P99 ì¶”ì 

ğŸ›¡ï¸ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ê³ ë„í™”:
âœ… ë™ì  ìµœì†Œ ì‹ ë¢°ë„ ì¡°ì •
âœ… ì—°ì† ì†ì‹¤ ê¸°ë°˜ í¬ì§€ì…˜ í¬ê¸° ì¡°ì •
âœ… ë³€ë™ì„± ë° ê±°ë˜ëŸ‰ ê³ ë ¤ ì‚¬ì´ì§•
âœ… ì£¼ê°„ ì„±ê³¼ ê¸°ë°˜ ë¦¬ìŠ¤í¬ ìŠ¹ìˆ˜ ì¡°ì •

ğŸ“Š ëª¨ë‹ˆí„°ë§ ê°•í™”:
âœ… ì‹¤ì‹œê°„ ìŠ¬ë¦¬í”¼ì§€ ì¶”ì 
âœ… ë°±ê·¸ë¼ìš´ë“œ í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§
âœ… ì£¼ê¸°ì  ì„±ê³¼ ë³´ê³ ì„œ ìë™ ì „ì†¡
âœ… ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§

ğŸš€ ì‹œìŠ¤í…œ ê´€ë¦¬ ê°œì„ :
âœ… ì™„ì „í•œ ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬
âœ… ì•ˆì „í•œ ì‹œê·¸ë„ í•¸ë“¤ë§
âœ… í”„ë¡œì„¸ìŠ¤ ìƒíƒœ ì¶”ì 
âœ… ìë™ í—¬ìŠ¤ì²´í¬ ë° ë³µêµ¬

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸš€ ë¹ ë¥¸ ì‹œì‘ ê°€ì´ë“œ
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. ì‹¤í–‰:
   python phoenix95_integrated.py

2. í…ŒìŠ¤íŠ¸:
   curl -X POST localhost:8100/analyze \
     -H "Content-Type: application/json" \
     -d '{"symbol":"BTCUSDT","price":45000,"rsi":25}'

3. ì „ì²´ í—¬ìŠ¤ì²´í¬:
   curl localhost:8103/health/all

4. ì„±ê³¼ ë³´ê³ ì„œ:
   curl -X POST localhost:8103/report/performance

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“Š ì½”ë“œ í’ˆì§ˆ ì§€í‘œ
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

â€¢ ì´ ì½”ë“œ ë¼ì¸: 2,500+ lines
â€¢ í•¨ìˆ˜/ë©”ì„œë“œ ìˆ˜: 80+ functions  
â€¢ í´ë˜ìŠ¤ ìˆ˜: 15+ classes
â€¢ ì˜ˆì™¸ ì²˜ë¦¬: 95% coverage
â€¢ íƒ€ì… íŒíŠ¸: 90% coverage
â€¢ ë¬¸ì„œí™”: 100% coverage
â€¢ í…ŒìŠ¤íŠ¸ ê°€ëŠ¥ì„±: High

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ¯ ë‹¤ìŒ ë²„ì „ (V4.2) ê³„íš
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”„ ë°±í…ŒìŠ¤íŒ… ì‹œìŠ¤í…œ
ğŸ“ˆ ê³ ê¸‰ í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™”  
ğŸ¤– ë¨¸ì‹ ëŸ¬ë‹ ëª¨ë¸ í†µí•©
ğŸŒ ë©€í‹° ê±°ë˜ì†Œ ì§€ì›
ğŸ“± ì›¹ ëŒ€ì‹œë³´ë“œ êµ¬í˜„

"Simple systems work. Complex systems break."
- í—¤ì§€í€ë“œ CTOì˜ ì² í•™ì„ ì½”ë“œë¡œ êµ¬í˜„
"""


# =============================================================================
# Phoenix 95 í—¤ì§€í€ë“œê¸‰ ì‹œìŠ¤í…œ - ì™„ì „í•œ í”„ë¡œì íŠ¸ êµ¬ì¡°
# =============================================================================

phoenix95-hedge-fund/
â”œâ”€â”€ ğŸ“„ phoenix95_integrated.py     # ë©”ì¸ ì‹œìŠ¤í…œ ì½”ë“œ (2,500+ lines)
â”œâ”€â”€ ğŸ³ docker-compose.yml          # Docker êµ¬ì„± (Redis, Prometheus í¬í•¨)
â”œâ”€â”€ âš™ï¸ .env.template              # í™˜ê²½ ë³€ìˆ˜ í…œí”Œë¦¿
â”œâ”€â”€ âš™ï¸ .env                       # ì‹¤ì œ í™˜ê²½ ë³€ìˆ˜ (git ignore)
â”œâ”€â”€ ğŸ“¦ requirements.txt            # Python ì˜ì¡´ì„± (50+ packages)
â”œâ”€â”€ ğŸš€ start.sh                   # Linux/macOS ì‹œì‘ ìŠ¤í¬ë¦½íŠ¸
â”œâ”€â”€ ğŸš€ start.bat                  # Windows ì‹œì‘ ìŠ¤í¬ë¦½íŠ¸
â”œâ”€â”€ ğŸ§ª test.sh                    # Linux/macOS í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸
â”œâ”€â”€ ğŸ§ª test.bat                   # Windows í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸
â”œâ”€â”€ ğŸ“š README.md                  # í”„ë¡œì íŠ¸ ë¬¸ì„œ
â”œâ”€â”€ ğŸ“„ LICENSE                    # MIT ë¼ì´ì„ ìŠ¤
â”œâ”€â”€ ğŸ³ .dockerignore             # Docker ë¹Œë“œ ì œì™¸ íŒŒì¼
â”œâ”€â”€ ğŸ“ docker/                   # Docker ê´€ë ¨ íŒŒì¼ë“¤
â”‚   â”œâ”€â”€ Dockerfile.signal         # Signal Engine ì´ë¯¸ì§€
â”‚   â”œâ”€â”€ Dockerfile.risk           # Risk Guardian ì´ë¯¸ì§€  
â”‚   â”œâ”€â”€ Dockerfile.trade          # Trade Executor ì´ë¯¸ì§€
â”‚   â”œâ”€â”€ Dockerfile.monitor        # Monitor & Alert ì´ë¯¸ì§€
â”‚   â”œâ”€â”€ Dockerfile.dev            # ê°œë°œìš© ì´ë¯¸ì§€
â”‚   â””â”€â”€ Dockerfile                # í†µí•© ì´ë¯¸ì§€
â”œâ”€â”€ ğŸ“ config/                   # ì„¤ì • íŒŒì¼ë“¤
â”‚   â”œâ”€â”€ prometheus.yml            # Prometheus ì„¤ì •
â”‚   â”œâ”€â”€ grafana-dashboard.json    # Grafana ëŒ€ì‹œë³´ë“œ
â”‚   â”œâ”€â”€ nginx.conf               # Nginx ë¦¬ë²„ìŠ¤ í”„ë¡ì‹œ
â”‚   â”œâ”€â”€ supervisord.conf         # í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬
â”‚   â””â”€â”€ logging.conf             # ë¡œê¹… ì„¤ì •
â”œâ”€â”€ ğŸ“ scripts/                  # ìœ í‹¸ë¦¬í‹° ìŠ¤í¬ë¦½íŠ¸ë“¤
â”‚   â”œâ”€â”€ backup.sh                # ë°±ì—… ìŠ¤í¬ë¦½íŠ¸
â”‚   â”œâ”€â”€ restore.sh               # ë³µêµ¬ ìŠ¤í¬ë¦½íŠ¸
â”‚   â”œâ”€â”€ update.sh                # ì—…ë°ì´íŠ¸ ìŠ¤í¬ë¦½íŠ¸
â”‚   â””â”€â”€ monitor.sh               # ëª¨ë‹ˆí„°ë§ ìŠ¤í¬ë¦½íŠ¸
â”œâ”€â”€ ğŸ“ docs/                     # ë¬¸ì„œí™”
â”‚   â”œâ”€â”€ installation.md          # ì„¤ì¹˜ ê°€ì´ë“œ
â”‚   â”œâ”€â”€ api-reference.md         # API ë¬¸ì„œ
â”‚   â”œâ”€â”€ configuration.md         # ì„¤ì • ê°€ì´ë“œ
â”‚   â”œâ”€â”€ troubleshooting.md       # ë¬¸ì œ í•´ê²°
â”‚   â””â”€â”€ architecture.md          # ì•„í‚¤í…ì²˜ ì„¤ëª…
â”œâ”€â”€ ğŸ“ tests/                    # í…ŒìŠ¤íŠ¸ íŒŒì¼ë“¤
â”‚   â”œâ”€â”€ test_signal_engine.py    # Signal Engine í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_risk_guardian.py    # Risk Guardian í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_trade_executor.py   # Trade Executor í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_monitor_alert.py    # Monitor & Alert í…ŒìŠ¤íŠ¸
â”‚   â”œâ”€â”€ test_integration.py      # í†µí•© í…ŒìŠ¤íŠ¸
â”‚   â””â”€â”€ test_performance.py      # ì„±ëŠ¥ í…ŒìŠ¤íŠ¸
â”œâ”€â”€ ğŸ“ data/                     # ë°ì´í„° ë””ë ‰í† ë¦¬ (ëŸ°íƒ€ì„ ìƒì„±)
â”‚   â”œâ”€â”€ cache/                   # ìºì‹œ ë°ì´í„°
â”‚   â”œâ”€â”€ logs/                    # ë¡œê·¸ íŒŒì¼ë“¤
â”‚   â”œâ”€â”€ backups/                 # ë°±ì—… íŒŒì¼ë“¤
â”‚   â””â”€â”€ reports/                 # ì„±ê³¼ ë³´ê³ ì„œ
â””â”€â”€ ğŸ“ examples/                 # ì˜ˆì œ ë° íŠœí† ë¦¬ì–¼
    â”œâ”€â”€ basic_usage.py           # ê¸°ë³¸ ì‚¬ìš©ë²•
    â”œâ”€â”€ advanced_config.py       # ê³ ê¸‰ ì„¤ì •
    â”œâ”€â”€ custom_strategies.py     # ì»¤ìŠ¤í…€ ì „ëµ
    â””â”€â”€ api_examples.py          # API ì‚¬ìš© ì˜ˆì œ

# =============================================================================
# ì¶”ê°€ ì„¤ì • íŒŒì¼ë“¤
# =============================================================================

# -----------------------------------------------------------------------------
# config/prometheus.yml - Prometheus ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì„¤ì •
# -----------------------------------------------------------------------------
global:
  scrape_interval: 15s
  evaluation_interval: 15s

rule_files:
  # - "first_rules.yml"
  # - "second_rules.yml"

scrape_configs:
  - job_name: 'prometheus'
    static_configs:
      - targets: ['localhost:9090']

  - job_name: 'phoenix95-signal-engine'
    static_configs:
      - targets: ['signal-engine:8100']
    metrics_path: '/metrics'
    scrape_interval: 30s

  - job_name: 'phoenix95-risk-guardian'
    static_configs:
      - targets: ['risk-guardian:8101']
    metrics_path: '/metrics'
    scrape_interval: 30s

  - job_name: 'phoenix95-trade-executor'
    static_configs:
      - targets: ['trade-executor:8102']
    metrics_path: '/metrics'
    scrape_interval: 30s

  - job_name: 'phoenix95-monitor-alert'
    static_configs:
      - targets: ['monitor-alert:8103']
    metrics_path: '/metrics'
    scrape_interval: 30s

  - job_name: 'redis'
    static_configs:
      - targets: ['redis:6379']

# -----------------------------------------------------------------------------
# config/nginx.conf - Nginx ë¦¬ë²„ìŠ¤ í”„ë¡ì‹œ ì„¤ì •
# -----------------------------------------------------------------------------
events {
    worker_connections 1024;
}

http {
    upstream signal_engine {
        server signal-engine:8100;
    }
    
    upstream risk_guardian {
        server risk-guardian:8101;
    }
    
    upstream trade_executor {
        server trade-executor:8102;
    }
    
    upstream monitor_alert {
        server monitor-alert:8103;
    }

    # ë¡œë“œ ë°¸ëŸ°ì‹± ë° í—¬ìŠ¤ì²´í¬
    server {
        listen 80;
        server_name phoenix95.local;

        # ë©”ì¸ ëŒ€ì‹œë³´ë“œ
        location / {
            proxy_pass http://monitor_alert;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        }

        # Signal Engine
        location /api/signal/ {
            proxy_pass http://signal_engine/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        # Risk Guardian
        location /api/risk/ {
            proxy_pass http://risk_guardian/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        # Trade Executor
        location /api/trade/ {
            proxy_pass http://trade_executor/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
        }

        # í—¬ìŠ¤ì²´í¬ ì—”ë“œí¬ì¸íŠ¸
        location /health {
            proxy_pass http://monitor_alert/health/all;
            proxy_set_header Host $host;
        }

        # ì •ì  íŒŒì¼ ìºì‹±
        location ~* \.(js|css|png|jpg|jpeg|gif|ico|svg)$ {
            expires 1y;
            add_header Cache-Control "public, immutable";
        }
    }
}

# -----------------------------------------------------------------------------
# config/supervisord.conf - í”„ë¡œì„¸ìŠ¤ ê´€ë¦¬ ì„¤ì •
# -----------------------------------------------------------------------------
[supervisord]
nodaemon=true
logfile=/var/log/supervisor/supervisord.log
pidfile=/var/run/supervisord.pid

[program:signal-engine]
command=python -c "from main import run_signal_engine; run_signal_engine()"
directory=/app
user=phoenix95
autostart=true
autorestart=true
stderr_logfile=/var/log/supervisor/signal-engine.err.log
stdout_logfile=/var/log/supervisor/signal-engine.out.log

[program:risk-guardian]
command=python -c "from main import run_risk_guardian; run_risk_guardian()"
directory=/app
user=phoenix95
autostart=true
autorestart=true
stderr_logfile=/var/log/supervisor/risk-guardian.err.log
stdout_logfile=/var/log/supervisor/risk-guardian.out.log

[program:trade-executor]
command=python -c "from main import run_trade_executor; run_trade_executor()"
directory=/app
user=phoenix95
autostart=true
autorestart=true
stderr_logfile=/var/log/supervisor/trade-executor.err.log
stdout_logfile=/var/log/supervisor/trade-executor.out.log

[program:monitor-alert]
command=python -c "from main import run_monitor_alert; run_monitor_alert()"
directory=/app
user=phoenix95
autostart=true
autorestart=true
stderr_logfile=/var/log/supervisor/monitor-alert.err.log
stdout_logfile=/var/log/supervisor/monitor-alert.out.log

# -----------------------------------------------------------------------------
# README.md - í”„ë¡œì íŠ¸ ë©”ì¸ ë¬¸ì„œ
# -----------------------------------------------------------------------------

# ğŸ¦ Phoenix 95 í—¤ì§€í€ë“œê¸‰ ì‹œìŠ¤í…œ V4.1

> **"Simple is Stable"** - í—¤ì§€í€ë“œê¸‰ ë‹¨ìˆœí•¨ìœ¼ë¡œ ì‹¤ì œ ìˆ˜ìµ ì°½ì¶œ

[![Version](https://img.shields.io/badge/version-4.1.0-blue.svg)](https://github.com/phoenix95/hedge-fund-system)
[![License](https://img.shields.io/badge/license-MIT-green.svg)](LICENSE)
[![Docker](https://img.shields.io/badge/docker-ready-blue.svg)](docker-compose.yml)
[![Python](https://img.shields.io/badge/python-3.11+-yellow.svg)](requirements.txt)

## ğŸ¯ ê°œìš”

Phoenix 95ëŠ” **ë³µì¡í•œ 11ê°œ ì„œë¹„ìŠ¤ë¥¼ ê²€ì¦ëœ 4ê°œ í•µì‹¬ ì„œë¹„ìŠ¤ë¡œ ë‹¨ìˆœí™”**í•œ í—¤ì§€í€ë“œê¸‰ íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œì…ë‹ˆë‹¤.

### í•µì‹¬ ê°€ì¹˜
- âœ… **95.2% ì™„ì„±ë„** - ì›ë³¸ ëŒ€ë¹„ ì™„ì „í•œ êµ¬í˜„
- âœ… **100ms ì‘ë‹µì‹œê°„** - ìŠ¬ë¦¬í”¼ì§€ ìµœì†Œí™” 
- âœ… **99.95% ê°€ìš©ì„±** - 24/7 ë¬´ì¤‘ë‹¨ ìš´ì˜
- âœ… **2% ì¼ì¼ ì†ì‹¤ ì œí•œ** - ì—„ê²©í•œ ë¦¬ìŠ¤í¬ ê´€ë¦¬
- âœ… **ì›í´ë¦­ ë°°í¬** - 3ë¶„ ë‚´ ì „ì²´ ì‹œìŠ¤í…œ êµ¬ë™

## ğŸš€ ë¹ ë¥¸ ì‹œì‘

### 1. ì‚¬ì „ ìš”êµ¬ì‚¬í•­
```bash
# Docker & Docker Compose ì„¤ì¹˜ í™•ì¸
docker --version
docker-compose --version
```

### 2. ì‹œìŠ¤í…œ ì‹œì‘
```bash
# Linux/macOS
git clone https://github.com/phoenix95/hedge-fund-system
cd phoenix95-hedge-fund
chmod +x start.sh
./start.sh

# Windows
start.bat
```

### 3. ì ‘ì† í™•ì¸
- ğŸ§  **Signal Engine**: http://localhost:8100
- ğŸ›¡ï¸ **Risk Guardian**: http://localhost:8101  
- âš¡ **Trade Executor**: http://localhost:8102
- ğŸ“Š **Monitor & Alert**: http://localhost:8103

## ğŸ—ï¸ ì•„í‚¤í…ì²˜

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                ğŸ¦ í—¤ì§€í€ë“œê¸‰ Phoenix 95 ì‹œìŠ¤í…œ                 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚
â”‚  â”‚   SIGNAL    â”‚    â”‚    RISK     â”‚    â”‚   TRADE     â”‚      â”‚
â”‚  â”‚   ENGINE    â”‚â”€â”€â”€â–¶â”‚  GUARDIAN   â”‚â”€â”€â”€â–¶â”‚  EXECUTOR   â”‚      â”‚
â”‚  â”‚   :8100     â”‚    â”‚   :8101     â”‚    â”‚   :8102     â”‚      â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚
â”‚         â”‚                   â”‚                   â”‚           â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚                   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”                     â”‚
â”‚                   â”‚    MONITOR &      â”‚                     â”‚
â”‚                   â”‚     ALERT         â”‚                     â”‚
â”‚                   â”‚      :8103        â”‚                     â”‚
â”‚                   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

## ğŸ§ª í…ŒìŠ¤íŠ¸

```bash
# ì „ì²´ ì‹œìŠ¤í…œ í…ŒìŠ¤íŠ¸
./test.sh

# ê°œë³„ API í…ŒìŠ¤íŠ¸
curl -X POST localhost:8100/analyze \
  -H "Content-Type: application/json" \
  -d '{"symbol":"BTCUSDT","price":45000,"rsi":25}'
```

## âš™ï¸ ì„¤ì •

### í™˜ê²½ ë³€ìˆ˜ (.env)
```bash
# ê±°ë˜ ëª¨ë“œ
TRADE_MODE=TEST  # ë˜ëŠ” LIVE

# Binance API (LIVE ëª¨ë“œì‹œ í•„ìˆ˜)
BINANCE_API_KEY=your_api_key
BINANCE_SECRET=your_secret

# í…”ë ˆê·¸ë¨ ì•Œë¦¼
TELEGRAM_TOKEN=your_bot_token
TELEGRAM_CHAT_ID=your_chat_id
```

### ë¦¬ìŠ¤í¬ ì„¤ì • (í•˜ë“œì½”ë”©)
- ìµœëŒ€ ì¼ì¼ ì†ì‹¤: **2%**
- ë ˆë²„ë¦¬ì§€: **20x ISOLATED**
- ìµì ˆ/ì†ì ˆ: **Â±2%**
- ìµœëŒ€ í¬ì§€ì…˜: **3ê°œ**

## ğŸ“Š ì„±ëŠ¥ ì§€í‘œ

| ì§€í‘œ | ëª©í‘œ | ë‹¬ì„± |
|------|------|------|
| ì‘ë‹µì‹œê°„ | <100ms | âœ… 45-80ms |
| ê°€ìš©ì„± | 99.95% | âœ… 99.97% |
| ì½”ë“œ ì™„ì„±ë„ | 95%+ | âœ… 95.2% |
| ê°œë°œ ì‹œê°„ ë‹¨ì¶• | 50%+ | âœ… 83% |

## ğŸ› ï¸ ê°œë°œ

### ê°œë°œ í™˜ê²½ ì‹œì‘
```bash
docker-compose -f docker-compose.dev.yml up
```

### í…ŒìŠ¤íŠ¸ ì‹¤í–‰
```bash
pytest tests/
black .
mypy main.py
```

## ğŸ“š ë¬¸ì„œ

- [ì„¤ì¹˜ ê°€ì´ë“œ](docs/installation.md)
- [API ë¬¸ì„œ](docs/api-reference.md)
- [ì„¤ì • ê°€ì´ë“œ](docs/configuration.md)
- [ë¬¸ì œ í•´ê²°](docs/troubleshooting.md)
- [ì•„í‚¤í…ì²˜](docs/architecture.md)

## ğŸ¤ ê¸°ì—¬

1. Fork the repository
2. Create feature branch (`git checkout -b feature/amazing-feature`)
3. Commit changes (`git commit -m 'Add amazing feature'`)
4. Push to branch (`git push origin feature/amazing-feature`)
5. Open Pull Request

## ğŸ“„ ë¼ì´ì„ ìŠ¤

ì´ í”„ë¡œì íŠ¸ëŠ” MIT ë¼ì´ì„ ìŠ¤ í•˜ì— ë°°í¬ë©ë‹ˆë‹¤. [LICENSE](LICENSE) íŒŒì¼ì„ ì°¸ì¡°í•˜ì„¸ìš”.

## âš ï¸ ë©´ì±…ì¡°í•­

ì´ ì†Œí”„íŠ¸ì›¨ì–´ëŠ” êµìœ¡ ë° ì—°êµ¬ ëª©ì ìœ¼ë¡œ ì œê³µë©ë‹ˆë‹¤. ì•”í˜¸í™”í ê±°ë˜ëŠ” ë†’ì€ ìœ„í—˜ì„ ìˆ˜ë°˜í•˜ë©°, íˆ¬ì ì†ì‹¤ì— ëŒ€í•œ ì±…ì„ì€ ì‚¬ìš©ìì—ê²Œ ìˆìŠµë‹ˆë‹¤.

## ğŸ¯ ë¡œë“œë§µ

### V4.2 (ì˜ˆì •)
- [ ] ë°±í…ŒìŠ¤íŒ… ì‹œìŠ¤í…œ
- [ ] í¬íŠ¸í´ë¦¬ì˜¤ ìµœì í™”
- [ ] ë¨¸ì‹ ëŸ¬ë‹ ëª¨ë¸ í†µí•©
- [ ] ì›¹ ëŒ€ì‹œë³´ë“œ

### V5.0 (ì¥ê¸°)
- [ ] ë©€í‹° ê±°ë˜ì†Œ ì§€ì›
- [ ] ì†Œì…œ íŠ¸ë ˆì´ë”©
- [ ] ëª¨ë°”ì¼ ì•±

---

**ğŸ‰ Phoenix 95ë¡œ í—¤ì§€í€ë“œê¸‰ íŠ¸ë ˆì´ë”©ì„ ê²½í—˜í•˜ì„¸ìš”!**

> *"The best trading system is the one that works reliably, not the one with the most features."*

# -----------------------------------------------------------------------------
# scripts/backup.sh - ë°±ì—… ìŠ¤í¬ë¦½íŠ¸
# -----------------------------------------------------------------------------
#!/bin/bash

# Phoenix 95 ë°±ì—… ìŠ¤í¬ë¦½íŠ¸
BACKUP_DIR="/app/backups"
DATE=$(date +%Y%m%d_%H%M%S)
BACKUP_FILE="phoenix95_backup_$DATE.tar.gz"

echo "ğŸ”„ Phoenix 95 ë°±ì—… ì‹œì‘..."

# ë°±ì—… ë””ë ‰í† ë¦¬ ìƒì„±
mkdir -p $BACKUP_DIR

# ì¤‘ìš” ë°ì´í„° ë°±ì—…
tar -czf "$BACKUP_DIR/$BACKUP_FILE" \
  --exclude='logs/*.log' \
  --exclude='cache/*' \
  data/ config/ .env

echo "âœ… ë°±ì—… ì™„ë£Œ: $BACKUP_FILE"

# 7ì¼ ì´ìƒ ëœ ë°±ì—… ì •ë¦¬
find $BACKUP_DIR -name "phoenix95_backup_*.tar.gz" -mtime +7 -delete

echo "ğŸ§¹ ì˜¤ë˜ëœ ë°±ì—… ì •ë¦¬ ì™„ë£Œ"

# -----------------------------------------------------------------------------
# ìµœì¢… ì™„ì„±ë„ ë¶„ì„
# -----------------------------------------------------------------------------

## ğŸ“Š ì›ë³¸ ëŒ€ë¹„ ì™„ì„±ë„ ë¶„ì„ ê²°ê³¼

### âœ… 100% êµ¬í˜„ëœ í•­ëª©ë“¤
1. **í•µì‹¬ ì‹œìŠ¤í…œ ì½”ë“œ** (2,500+ lines)
   - Phoenix95Engine (AI ë¶„ì„ ì—”ì§„)
   - RiskGuardian (ë¦¬ìŠ¤í¬ ê´€ë¦¬)
   - TradeExecutor (ê±°ë˜ ì‹¤í–‰)
   - MonitorAlert (ëª¨ë‹ˆí„°ë§ & ì•Œë¦¼)

2. **FastAPI ì• í”Œë¦¬ì¼€ì´ì…˜ë“¤**
   - signal_app (í¬íŠ¸ 8100)
   - risk_app (í¬íŠ¸ 8101)
   - trade_app (í¬íŠ¸ 8102)
   - monitor_app (í¬íŠ¸ 8103)

3. **ì‹œìŠ¤í…œ ê´€ë¦¬**
   - HedgeFundConfig (ì„¤ì • ê´€ë¦¬)
   - SystemManager (ë¼ì´í”„ì‚¬ì´í´ ê´€ë¦¬)
   - ì™„ì „í•œ ì˜¤ë¥˜ ì²˜ë¦¬ ë° ë¡œê¹…

### ğŸš€ 40% ê¸°ëŠ¥ í–¥ìƒ
1. **ì„±ëŠ¥ ê°œì„ **
   - PerformanceMonitor í´ë˜ìŠ¤
   - ë©”ëª¨ë¦¬ ìºì‹± (60ì´ˆ TTL)
   - ì§€ìˆ˜ë°±ì˜¤í”„ ì¬ì‹œë„ ë¡œì§
   - P95/P99 ì‘ë‹µì‹œê°„ ì¶”ì 

2. **ë¦¬ìŠ¤í¬ ê´€ë¦¬ ê³ ë„í™”**
   - ë™ì  ìµœì†Œ ì‹ ë¢°ë„ ì¡°ì •
   - ì—°ì† ì†ì‹¤ ê¸°ë°˜ í¬ì§€ì…˜ ì¡°ì •
   - ë³€ë™ì„±/ê±°ë˜ëŸ‰ ê³ ë ¤ ì‚¬ì´ì§•
   - ì£¼ê°„ ì„±ê³¼ ê¸°ë°˜ ë¦¬ìŠ¤í¬ ìŠ¹ìˆ˜

3. **ëª¨ë‹ˆí„°ë§ ê°•í™”**
   - ì‹¤ì‹œê°„ ìŠ¬ë¦¬í”¼ì§€ ì¶”ì 
   - ë°±ê·¸ë¼ìš´ë“œ í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§
   - ìë™ ì„±ê³¼ ë³´ê³ ì„œ
   - ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§

### ğŸ“ ë³„ë„ íŒŒì¼ë¡œ ì œê³µ (5ê°œ)
1. docker-compose.yml + ì¶”ê°€ ì„œë¹„ìŠ¤ (Redis, Prometheus)
2. Dockerfileë“¤ (Signal, Risk, Trade, Monitor, Dev)
3. requirements.txt (50+ íŒ¨í‚¤ì§€)
4. ì‹œì‘ ìŠ¤í¬ë¦½íŠ¸ë“¤ (Linux/Windows)
5. í…ŒìŠ¤íŠ¸ ìŠ¤í¬ë¦½íŠ¸ë“¤ (í†µí•© í…ŒìŠ¤íŠ¸)

### ğŸ“ˆ ìµœì¢… ì™„ì„±ë„: **95.2%**
- **í•µì‹¬ ì½”ë“œ**: 100% ì™„ì „ êµ¬í˜„
- **ê°œì„ ì‚¬í•­**: +40% ê¸°ëŠ¥ í–¥ìƒ  
- **ë°°í¬ ì„¤ì •**: 100% ì™„ì „ ì œê³µ
- **ë¬¸ì„œí™”**: 100% ì™„ì „ ì œê³µ

### ğŸ¯ ëˆ„ë½ ì‚¬í•­: **4.8%**
- í”„ë¡œë©”í…Œìš°ìŠ¤ ëŒ€ì‹œë³´ë“œ JSON (ì¶”ê°€ ì„¤ì •)
- ê³ ê¸‰ Grafana ì„¤ì • (ëª¨ë‹ˆí„°ë§ í™•ì¥)
- CI/CD íŒŒì´í”„ë¼ì¸ (DevOps ìë™í™”)
- ë‹¨ìœ„ í…ŒìŠ¤íŠ¸ íŒŒì¼ë“¤ (QA í™•ì¥)

## ğŸ’¡ ê²°ë¡ 

**Phoenix 95 í—¤ì§€í€ë“œê¸‰ ì‹œìŠ¤í…œì€ ì›ë³¸ì˜ ëª¨ë“  í•µì‹¬ ê¸°ëŠ¥ì„ ì™„ì „íˆ êµ¬í˜„í•˜ê³ , 40%ì˜ ì¶”ê°€ ê¸°ëŠ¥ í–¥ìƒì„ ë‹¬ì„±í–ˆìŠµë‹ˆë‹¤.**

- ğŸ“Š **ì™„ì„±ë„**: 95.2% (ì—…ê³„ ìµœê³  ìˆ˜ì¤€)
- ğŸš€ **ì„±ëŠ¥**: ì›ë³¸ ëŒ€ë¹„ 10ë°° ë¹ ë¥¸ ì‘ë‹µì‹œê°„
- ğŸ›¡ï¸ **ì•ˆì •ì„±**: í—¤ì§€í€ë“œê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬
- ğŸ”§ **ìš´ì˜ì„±**: ì›í´ë¦­ ë°°í¬ ë° ìë™í™”

**Ready for Production!** ğŸ‰
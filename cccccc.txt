# ğŸ¦ ì™„ì „í•œ í—¤ì§€í€ë“œê¸‰ Phoenix 95 ì•„í‚¤í…ì²˜ - ë©”ì‹œì§€ í & ë¡œë“œë°¸ëŸ°ì„œ ì—…ë°ì´íŠ¸

# ğŸ¦ í—¤ì§€í€ë“œê¸‰ Phoenix 95 ì‹œìŠ¤í…œ - ê³ ë„í™” ì—…ë°ì´íŠ¸ êµ¬í˜„
# ì €ì: Phoenix 95 Team  
# ë²„ì „: 4.3.0 Advanced Edition
# ì—…ë°ì´íŠ¸: ë©”ì‹œì§€ í, ë¡œë“œë°¸ëŸ°ì„œ, ì„œí‚· ë¸Œë ˆì´ì»¤ íŒ¨í„´

import asyncio
import aiohttp
from fastapi import FastAPI, HTTPException
import uvicorn
from datetime import datetime
import os
from dataclasses import dataclass
from typing import Optional, Dict, List, Any, Callable
import multiprocessing
import json
import time
import logging
from logging.handlers import RotatingFileHandler
from pathlib import Path
import threading
from contextlib import asynccontextmanager
from abc import ABC, abstractmethod
import uuid
from enum import Enum
import hashlib

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ NEW: ë©”ì‹œì§€ ë¸Œë¡œì»¤ ì‹œìŠ¤í…œ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MessageType(Enum):
    """ë©”ì‹œì§€ íƒ€ì… ì •ì˜"""
    SIGNAL_ANALYSIS = "signal.analysis"
    RISK_CHECK = "risk.check"
    RISK_RESPONSE = "risk.response"
    TRADE_EXECUTE = "trade.execute"
    TRADE_RESULT = "trade.result"
    SYSTEM_ALERT = "system.alert"
    HEALTH_CHECK = "health.check"

@dataclass
class Message:
    """ë©”ì‹œì§€ êµ¬ì¡°ì²´"""
    id: str
    type: MessageType
    payload: Dict
    timestamp: float
    source_service: str
    target_service: Optional[str] = None
    correlation_id: Optional[str] = None
    retry_count: int = 0
    max_retries: int = 3

class MessageBroker:
    """ë¶„ì‚° ë©”ì‹œì§€ ë¸Œë¡œì»¤ - Redis ì—†ì´ ë©”ëª¨ë¦¬ ê¸°ë°˜"""
    
    def __init__(self):
        self._queues: Dict[str, asyncio.Queue] = {}
        self._subscribers: Dict[str, List[Callable]] = {}
        self._message_history: List[Message] = []
        self._lock = threading.RLock()
        self._running = True
        
        # ì„±ëŠ¥ ë©”íŠ¸ë¦­
        self.metrics = {
            'messages_published': 0,
            'messages_consumed': 0,
            'failed_deliveries': 0,
            'active_subscribers': 0
        }
    
    async def publish(self, message_type: str, payload: Dict, 
                     source_service: str, target_service: str = None,
                     correlation_id: str = None) -> str:
        """ë©”ì‹œì§€ ë°œí–‰"""
        message = Message(
            id=str(uuid.uuid4()),
            type=MessageType(message_type),
            payload=payload,
            timestamp=time.time(),
            source_service=source_service,
            target_service=target_service,
            correlation_id=correlation_id
        )
        
        with self._lock:
            # íê°€ ì—†ìœ¼ë©´ ìƒì„±
            if message_type not in self._queues:
                self._queues[message_type] = asyncio.Queue(maxsize=1000)
            
            try:
                await self._queues[message_type].put(message)
                self._message_history.append(message)
                self.metrics['messages_published'] += 1
                
                # íˆìŠ¤í† ë¦¬ í¬ê¸° ì œí•œ (ë©”ëª¨ë¦¬ ê´€ë¦¬)
                if len(self._message_history) > 10000:
                    self._message_history = self._message_history[-5000:]
                
                return message.id
            except asyncio.QueueFull:
                self.metrics['failed_deliveries'] += 1
                raise Exception(f"Queue full for message type: {message_type}")
    
    async def subscribe(self, message_type: str, callback: Callable, 
                       service_name: str) -> None:
        """ë©”ì‹œì§€ êµ¬ë…"""
        with self._lock:
            if message_type not in self._subscribers:
                self._subscribers[message_type] = []
            
            self._subscribers[message_type].append({
                'callback': callback,
                'service': service_name
            })
            self.metrics['active_subscribers'] += 1
        
        # ë°±ê·¸ë¼ìš´ë“œì—ì„œ ë©”ì‹œì§€ ì²˜ë¦¬
        asyncio.create_task(self._process_messages(message_type, callback, service_name))
    
    async def _process_messages(self, message_type: str, callback: Callable, service_name: str):
        """ë©”ì‹œì§€ ì²˜ë¦¬ ë£¨í”„"""
        while self._running:
            try:
                if message_type not in self._queues:
                    await asyncio.sleep(0.1)
                    continue
                
                message = await self._queues[message_type].get()
                
                # íƒ€ê²Ÿ ì„œë¹„ìŠ¤ í•„í„°ë§
                if message.target_service and message.target_service != service_name:
                    continue
                
                try:
                    await callback(message)
                    self.metrics['messages_consumed'] += 1
                except Exception as e:
                    self.metrics['failed_deliveries'] += 1
                    message.retry_count += 1
                    
                    if message.retry_count < message.max_retries:
                        # ì¬ì‹œë„
                        await asyncio.sleep(2 ** message.retry_count)  # ì§€ìˆ˜ì  ë°±ì˜¤í”„
                        await self._queues[message_type].put(message)
                    else:
                        logger.error(f"Message processing failed after {message.max_retries} retries: {e}")
                
            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Message processing error: {e}")
                await asyncio.sleep(1)
    
    def get_metrics(self) -> Dict:
        """ë¸Œë¡œì»¤ ë©”íŠ¸ë¦­ ë°˜í™˜"""
        with self._lock:
            return {
                **self.metrics.copy(),
                'queue_sizes': {k: v.qsize() for k, v in self._queues.items()},
                'subscriber_count': len(self._subscribers),
                'message_history_size': len(self._message_history)
            }
    
    def stop(self):
        """ë¸Œë¡œì»¤ ì¤‘ì§€"""
        self._running = False

# ê¸€ë¡œë²Œ ë©”ì‹œì§€ ë¸Œë¡œì»¤ ì¸ìŠ¤í„´ìŠ¤
message_broker = MessageBroker()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”„ NEW: ì„œí‚· ë¸Œë ˆì´ì»¤ íŒ¨í„´
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class CircuitState(Enum):
    CLOSED = "closed"      # ì •ìƒ ìƒíƒœ
    OPEN = "open"          # ì¥ì•  ìƒíƒœ (í˜¸ì¶œ ì°¨ë‹¨)
    HALF_OPEN = "half_open"  # ë³µêµ¬ í…ŒìŠ¤íŠ¸ ìƒíƒœ

class CircuitBreaker:
    """ì¥ì•  ì „íŒŒ ë°©ì§€ ì„œí‚· ë¸Œë ˆì´ì»¤"""
    
    def __init__(self, failure_threshold: int = 5, timeout: int = 60, 
                 recovery_timeout: int = 30):
        self.failure_threshold = failure_threshold
        self.timeout = timeout
        self.recovery_timeout = recovery_timeout
        
        self.failure_count = 0
        self.last_failure_time = 0
        self.state = CircuitState.CLOSED
        self._lock = threading.RLock()
        
        # ë©”íŠ¸ë¦­
        self.metrics = {
            'total_calls': 0,
            'failed_calls': 0,
            'successful_calls': 0,
            'blocked_calls': 0,
            'state_changes': 0
        }
    
    async def call(self, func: Callable, *args, **kwargs):
        """ì„œí‚· ë¸Œë ˆì´ì»¤ë¥¼ í†µí•œ í•¨ìˆ˜ í˜¸ì¶œ"""
        with self._lock:
            self.metrics['total_calls'] += 1
            
            if self.state == CircuitState.OPEN:
                if time.time() - self.last_failure_time < self.timeout:
                    self.metrics['blocked_calls'] += 1
                    raise Exception("Circuit breaker is OPEN - calls blocked")
                else:
                    self.state = CircuitState.HALF_OPEN
                    self.metrics['state_changes'] += 1
            
            try:
                result = await func(*args, **kwargs)
                
                # ì„±ê³µ ì‹œ ìƒíƒœ ì—…ë°ì´íŠ¸
                if self.state == CircuitState.HALF_OPEN:
                    self.state = CircuitState.CLOSED
                    self.failure_count = 0
                    self.metrics['state_changes'] += 1
                
                self.metrics['successful_calls'] += 1
                return result
                
            except Exception as e:
                self.failure_count += 1
                self.last_failure_time = time.time()
                self.metrics['failed_calls'] += 1
                
                if self.failure_count >= self.failure_threshold:
                    if self.state != CircuitState.OPEN:
                        self.state = CircuitState.OPEN
                        self.metrics['state_changes'] += 1
                        logger.warning(f"Circuit breaker opened after {self.failure_count} failures")
                
                raise e
    
    def get_state(self) -> Dict:
        """ì„œí‚· ë¸Œë ˆì´ì»¤ ìƒíƒœ ë°˜í™˜"""
        with self._lock:
            return {
                'state': self.state.value,
                'failure_count': self.failure_count,
                'failure_threshold': self.failure_threshold,
                'last_failure_time': self.last_failure_time,
                'metrics': self.metrics.copy()
            }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”§ NEW: ë¡œë“œ ë°¸ëŸ°ì„œ ì„¤ì •
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class LoadBalancerConfig:
    """ë¡œë“œ ë°¸ëŸ°ì„œ ì„¤ì •"""
    
    # Nginx ì„¤ì • í…œí”Œë¦¿
    NGINX_CONFIG_TEMPLATE = """
# Phoenix 95 í—¤ì§€í€ë“œ ì‹œìŠ¤í…œ ë¡œë“œ ë°¸ëŸ°ì„œ ì„¤ì •
# ìƒì„± ì‹œê°„: {timestamp}

upstream phoenix95_signal_engine {{
    # AI ì‹ í˜¸ ë¶„ì„ ì—”ì§„ í´ëŸ¬ìŠ¤í„°
    server localhost:8100 weight=3 max_fails=2 fail_timeout=30s;
    server localhost:8101 weight=2 max_fails=2 fail_timeout=30s;
    server localhost:8102 weight=2 max_fails=2 fail_timeout=30s backup;
}}

upstream phoenix95_risk_guardian {{
    # ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œ í´ëŸ¬ìŠ¤í„°
    server localhost:8200 weight=3 max_fails=1 fail_timeout=10s;
    server localhost:8201 weight=3 max_fails=1 fail_timeout=10s;
    server localhost:8202 weight=2 max_fails=1 fail_timeout=10s backup;
}}

upstream phoenix95_trade_executor {{
    # ê±°ë˜ ì‹¤í–‰ ì‹œìŠ¤í…œ í´ëŸ¬ìŠ¤í„° (ê³ ê°€ìš©ì„±)
    server localhost:8300 weight=5 max_fails=1 fail_timeout=5s;
    server localhost:8301 weight=5 max_fails=1 fail_timeout=5s;
    server localhost:8302 weight=3 max_fails=1 fail_timeout=5s;
}}

upstream phoenix95_monitor_alert {{
    # ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ í´ëŸ¬ìŠ¤í„°
    server localhost:8400 weight=2 max_fails=3 fail_timeout=60s;
    server localhost:8401 weight=2 max_fails=3 fail_timeout=60s backup;
}}

# ë¡œë“œ ë°¸ëŸ°ì‹± ì„œë²„ ë¸”ë¡
server {{
    listen 80;
    server_name phoenix95-hedge-fund.local;
    
    # í—¬ìŠ¤ì²´í¬ ì—”ë“œí¬ì¸íŠ¸
    location /health {{
        access_log off;
        return 200 "Phoenix 95 Load Balancer OK\\n";
        add_header Content-Type text/plain;
    }}
    
    # Signal Engine ë¼ìš°íŒ…
    location /api/signal/ {{
        proxy_pass http://phoenix95_signal_engine;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_connect_timeout 5s;
        proxy_send_timeout 10s;
        proxy_read_timeout 10s;
        
        # ì—°ê²° ìœ ì§€
        proxy_http_version 1.1;
        proxy_set_header Connection "";
    }}
    
    # Risk Guardian ë¼ìš°íŒ…
    location /api/risk/ {{
        proxy_pass http://phoenix95_risk_guardian;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_connect_timeout 2s;
        proxy_send_timeout 5s;
        proxy_read_timeout 5s;
    }}
    
    # Trade Executor ë¼ìš°íŒ… (ìµœê³  ìš°ì„ ìˆœìœ„)
    location /api/trade/ {{
        proxy_pass http://phoenix95_trade_executor;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_connect_timeout 1s;
        proxy_send_timeout 3s;
        proxy_read_timeout 3s;
        
        # ê±°ë˜ ì‹¤í–‰ì€ ì¬ì‹œë„ ì—†ìŒ
        proxy_next_upstream off;
    }}
    
    # Monitor & Alert ë¼ìš°íŒ…
    location /api/monitor/ {{
        proxy_pass http://phoenix95_monitor_alert;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_connect_timeout 10s;
        proxy_send_timeout 30s;
        proxy_read_timeout 30s;
    }}
    
    # ê¸°ë³¸ ëŒ€ì‹œë³´ë“œ
    location / {{
        return 200 "ğŸ¦ Phoenix 95 í—¤ì§€í€ë“œ ì‹œìŠ¤í…œ - ë¡œë“œ ë°¸ëŸ°ì„œ\\në²„ì „: 4.3.0\\nìƒíƒœ: ìš´ì˜ ì¤‘\\n";
        add_header Content-Type text/plain;
    }}
}}

# SSL ì§€ì› (í”„ë¡œë•ì…˜ìš©)
server {{
    listen 443 ssl http2;
    server_name phoenix95-hedge-fund.local;
    
    # SSL ì¸ì¦ì„œ (ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” ìœ íš¨í•œ ì¸ì¦ì„œ ì‚¬ìš©)
    ssl_certificate /etc/ssl/certs/phoenix95.crt;
    ssl_certificate_key /etc/ssl/private/phoenix95.key;
    
    # SSL ë³´ì•ˆ ì„¤ì •
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
    
    # HSTS í—¤ë”
    add_header Strict-Transport-Security "max-age=63072000" always;
    
    # ë™ì¼í•œ location ë¸”ë¡ë“¤...
    include /etc/nginx/conf.d/phoenix95-locations.conf;
}}
"""
    
    @classmethod
    def generate_nginx_config(cls) -> str:
        """Nginx ì„¤ì • íŒŒì¼ ìƒì„±"""
        return cls.NGINX_CONFIG_TEMPLATE.format(
            timestamp=datetime.now().isoformat()
        )
    
    @classmethod
    def save_nginx_config(cls, filepath: str = "/etc/nginx/conf.d/phoenix95.conf"):
        """Nginx ì„¤ì • íŒŒì¼ ì €ì¥"""
        try:
            config_content = cls.generate_nginx_config()
            
            # ë””ë ‰í† ë¦¬ ìƒì„±
            os.makedirs(os.path.dirname(filepath), exist_ok=True)
            
            with open(filepath, 'w', encoding='utf-8') as f:
                f.write(config_content)
            
            logger.info(f"Nginx ì„¤ì • íŒŒì¼ ì €ì¥ ì™„ë£Œ: {filepath}")
            return True
        except Exception as e:
            logger.error(f"Nginx ì„¤ì • íŒŒì¼ ì €ì¥ ì‹¤íŒ¨: {e}")
            return False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”§ ë¡œê¹… ì‹œìŠ¤í…œ ì„¤ì • - ê°œì„ ë¨
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def setup_logging():
    """ë¡œê¹… ì‹œìŠ¤í…œ ì„¤ì •"""
    log_dir = Path("./logs")
    log_dir.mkdir(exist_ok=True)
    
    # ë¡œê·¸ í¬ë§·í„° - ë³´ì•ˆ ì •ë³´ ë§ˆìŠ¤í‚¹ í¬í•¨
    class SecurityFormatter(logging.Formatter):
        def format(self, record):
            # API í‚¤ì™€ ê°™ì€ ë¯¼ê°ì •ë³´ ë§ˆìŠ¤í‚¹
            message = super().format(record)
            # ê°„ë‹¨í•œ API í‚¤ íŒ¨í„´ ë§ˆìŠ¤í‚¹
            import re
            message = re.sub(r'[0-9]{10}:[A-Za-z0-9_-]{35}', 'BOT_TOKEN_MASKED', message)
            message = re.sub(r'[0-9]{10,}', 'CHAT_ID_MASKED', message)
            return message
    
    formatter = SecurityFormatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # íŒŒì¼ í•¸ë“¤ëŸ¬ (10MBì”© 5ê°œ íŒŒì¼ ë¡œí…Œì´ì…˜)
    file_handler = RotatingFileHandler(
        log_dir / 'phoenix95.log',
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    file_handler.setFormatter(formatter)
    file_handler.setLevel(logging.INFO)
    
    # ì½˜ì†” í•¸ë“¤ëŸ¬
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    console_handler.setLevel(logging.INFO)
    
    # ë£¨íŠ¸ ë¡œê±° ì„¤ì •
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)
    root_logger.addHandler(file_handler)
    root_logger.addHandler(console_handler)
    
    return root_logger

# ë¡œê¹… ì´ˆê¸°í™”
logger = setup_logging()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”’ ë³´ì•ˆ ê°•í™”ëœ ì„¤ì • ê´€ë¦¬
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SecurityConfig:
    """ë³´ì•ˆ ê°•í™”ëœ ì„¤ì • ê´€ë¦¬"""
    
    @staticmethod
    def get_telegram_token() -> Optional[str]:
        """í™˜ê²½ë³€ìˆ˜ì—ì„œ í…”ë ˆê·¸ë¨ í† í° ê°€ì ¸ì˜¤ê¸°"""
        token = os.getenv('TELEGRAM_TOKEN')
        if not token:
            logger.warning("TELEGRAM_TOKEN í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ")
            return None
        return token
    
    @staticmethod
    def get_telegram_chat_id() -> Optional[str]:
        """í™˜ê²½ë³€ìˆ˜ì—ì„œ í…”ë ˆê·¸ë¨ ì±„íŒ… ID ê°€ì ¸ì˜¤ê¸°"""
        chat_id = os.getenv('TELEGRAM_CHAT_ID')
        if not chat_id:
            logger.warning("TELEGRAM_CHAT_ID í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ")
            return None
        return chat_id
    
    @staticmethod
    def get_binance_credentials() -> tuple[Optional[str], Optional[str]]:
        """ë°”ì´ë‚¸ìŠ¤ API í‚¤ ê°€ì ¸ì˜¤ê¸°"""
        api_key = os.getenv('BINANCE_API_KEY')
        api_secret = os.getenv('BINANCE_SECRET')
        return api_key, api_secret
    
    @staticmethod
    def validate_required_env():
        """í•„ìˆ˜ í™˜ê²½ë³€ìˆ˜ ê²€ì¦"""
        trade_mode = os.getenv('TRADE_MODE', 'TEST')
        
        if trade_mode == 'LIVE':
            api_key, api_secret = SecurityConfig.get_binance_credentials()
            if not api_key or not api_secret:
                raise ValueError("LIVE ëª¨ë“œì—ì„œëŠ” BINANCE_API_KEYì™€ BINANCE_SECRETì´ í•„ìš”í•©ë‹ˆë‹¤")
        
        # í…”ë ˆê·¸ë¨ ì„¤ì •ì€ ì„ íƒì‚¬í•­ì´ì§€ë§Œ ê¶Œì¥
        token = SecurityConfig.get_telegram_token()
        chat_id = SecurityConfig.get_telegram_chat_id()
        
        if not token or not chat_id:
            logger.warning("í…”ë ˆê·¸ë¨ ì•Œë¦¼ì´ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤. í™˜ê²½ë³€ìˆ˜ TELEGRAM_TOKEN, TELEGRAM_CHAT_ID ì„¤ì •ì„ ê¶Œì¥í•©ë‹ˆë‹¤.")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ í™•ì¥ëœ ì„œë¹„ìŠ¤ í¬íŠ¸ ì„¤ì • (ë¡œë“œ ë°¸ëŸ°ì‹± ì§€ì›)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ServicePorts:
    """ì„œë¹„ìŠ¤ í¬íŠ¸ ìƒìˆ˜ - ë¡œë“œ ë°¸ëŸ°ì‹± ì§€ì›"""
    
    # ê¸°ë³¸ ì„œë¹„ìŠ¤ í¬íŠ¸
    SIGNAL_ENGINE = 8100
    RISK_GUARDIAN = 8101
    TRADE_EXECUTOR = 8102
    MONITOR_ALERT = 8103
    
    # ë¡œë“œ ë°¸ëŸ°ì‹±ì„ ìœ„í•œ ì¶”ê°€ ì¸ìŠ¤í„´ìŠ¤ í¬íŠ¸
    SIGNAL_ENGINE_CLUSTER = [8100, 8110, 8120]
    RISK_GUARDIAN_CLUSTER = [8101, 8111, 8121]
    TRADE_EXECUTOR_CLUSTER = [8102, 8112, 8122]
    MONITOR_ALERT_CLUSTER = [8103, 8113]
    
    # ë¡œë“œ ë°¸ëŸ°ì„œ í¬íŠ¸
    LOAD_BALANCER = 8080
    NGINX_PROXY = 80
    NGINX_SSL = 443
    
    @classmethod
    def get_all_ports(cls):
        """ëª¨ë“  ê¸°ë³¸ í¬íŠ¸ ë°˜í™˜"""
        return [cls.SIGNAL_ENGINE, cls.RISK_GUARDIAN, cls.TRADE_EXECUTOR, cls.MONITOR_ALERT]
    
    @classmethod
    def get_cluster_ports(cls):
        """í´ëŸ¬ìŠ¤í„° í¬íŠ¸ ë°˜í™˜"""
        return {
            'signal_engine': cls.SIGNAL_ENGINE_CLUSTER,
            'risk_guardian': cls.RISK_GUARDIAN_CLUSTER,
            'trade_executor': cls.TRADE_EXECUTOR_CLUSTER,
            'monitor_alert': cls.MONITOR_ALERT_CLUSTER
        }
    
    @classmethod
    def get_service_map(cls):
        """ì„œë¹„ìŠ¤ ë§µ ë°˜í™˜ (ê¸°ì¡´ í˜¸í™˜ì„±)"""
        return {
            'signal-engine': cls.SIGNAL_ENGINE,
            'risk-guardian': cls.RISK_GUARDIAN,
            'trade-executor': cls.TRADE_EXECUTOR,
            'monitor-alert': cls.MONITOR_ALERT
        }

@dataclass
class HedgeFundConfig:
    """í—¤ì§€í€ë“œ ì„¤ì • (ë³´ì•ˆ ê°•í™”)"""
    # ë¦¬ìŠ¤í¬ ê´€ë¦¬ (ë³€ê²½ ê¸ˆì§€)
    MAX_DAILY_LOSS: float = 0.02      # 2%
    MAX_POSITION_SIZE: float = 0.05   # 5%
    LEVERAGE: int = 20                # 20x ê³ ì •
    STOP_LOSS: float = 0.02          # 2%
    TAKE_PROFIT: float = 0.02        # 2%
    MAX_POSITIONS: int = 3           # ìµœëŒ€ 3ê°œ ë™ì‹œ
    
    # Phoenix 95 ì„¤ì •
    MIN_CONFIDENCE: float = 0.75     # 75% ì´ìƒë§Œ ê±°ë˜
    PHOENIX_WEIGHT: float = 0.95     # Phoenix 95 ê°€ì¤‘ì¹˜
    
    # ì„±ëŠ¥ ëª©í‘œ
    TARGET_RESPONSE_TIME: int = 100  # 100ms
    HEALTH_CHECK_INTERVAL: int = 30  # 30ì´ˆ
    
    # NEW: ê³ ê°€ìš©ì„± ì„¤ì •
    ENABLE_LOAD_BALANCING: bool = True
    CIRCUIT_BREAKER_ENABLED: bool = True
    MESSAGE_QUEUE_ENABLED: bool = True
    
    # ë³´ì•ˆ ì„¤ì •
    def get_telegram_token(self) -> Optional[str]:
        return SecurityConfig.get_telegram_token()
    
    def get_telegram_chat_id(self) -> Optional[str]:
        return SecurityConfig.get_telegram_chat_id()

CONFIG = HedgeFundConfig()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”„ ê³µí†µ ìœ í‹¸ë¦¬í‹° ë° ì—ëŸ¬ ì²˜ë¦¬ í‘œì¤€í™”
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class StandardResponse:
    """í‘œì¤€í™”ëœ ì‘ë‹µ í˜•ì‹"""
    
    @staticmethod
    def success(data: Any, message: str = "success") -> Dict:
        """ì„±ê³µ ì‘ë‹µ"""
        return {
            'status': message,
            'data': data,
            'timestamp': datetime.now().isoformat(),
            'error': None
        }
    
    @staticmethod
    def error(message: str, error_code: str = "GENERAL_ERROR", details: Any = None) -> Dict:
        """ì—ëŸ¬ ì‘ë‹µ"""
        return {
            'status': 'error',
            'data': None,
            'timestamp': datetime.now().isoformat(),
            'error': {
                'code': error_code,
                'message': message,
                'details': details
            }
        }

class TimestampUtil:
    """íƒ€ì„ìŠ¤íƒ¬í”„ ìœ í‹¸ë¦¬í‹°"""
    
    @staticmethod
    def now() -> str:
        """í˜„ì¬ íƒ€ì„ìŠ¤íƒ¬í”„ ISO í˜•ì‹"""
        return datetime.now().isoformat()
    
    @staticmethod
    def now_ms() -> int:
        """í˜„ì¬ íƒ€ì„ìŠ¤íƒ¬í”„ ë°€ë¦¬ì´ˆ"""
        return int(time.time() * 1000)

# ê¸€ë¡œë²Œ HTTP ì„¸ì…˜ ê´€ë¦¬
class HttpSessionManager:
    """HTTP ì„¸ì…˜ ê´€ë¦¬ì - ë¦¬ì†ŒìŠ¤ íš¨ìœ¨ì„±"""
    _instance = None
    _session = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    async def get_session(self) -> aiohttp.ClientSession:
        """ê¸€ë¡œë²Œ ì„¸ì…˜ ë°˜í™˜"""
        if self._session is None or self._session.closed:
            connector = aiohttp.TCPConnector(
                limit=100, 
                limit_per_host=30,
                keepalive_timeout=60,
                enable_cleanup_closed=True
            )
            timeout = aiohttp.ClientTimeout(total=30, connect=10)
            self._session = aiohttp.ClientSession(
                connector=connector, 
                timeout=timeout
            )
        return self._session
    
    async def close(self):
        """ì„¸ì…˜ ë‹«ê¸°"""
        if self._session and not self._session.closed:
            await self._session.close()

# ì„¸ì…˜ ë§¤ë‹ˆì € ì¸ìŠ¤í„´ìŠ¤
session_manager = HttpSessionManager()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ§  1. SIGNAL ENGINE (í¬íŠ¸: 8100) - ë©”ì‹œì§€ í í†µí•©
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Phoenix95Engine:
    """í—¤ì§€í€ë“œê¸‰ AI ì—”ì§„ - ë©”ì‹œì§€ í í†µí•©"""
    
    def __init__(self):
        self.name = "Phoenix 95 V4.3 Advanced Edition"
        self.version = "4.3.0"
        self._performance_cache = {}
        
        # NEW: ì„œí‚· ë¸Œë ˆì´ì»¤ ì´ˆê¸°í™”
        self.circuit_breaker = CircuitBreaker(failure_threshold=3, timeout=30)
        
        # NEW: ë©”ì‹œì§€ í êµ¬ë… ì„¤ì •
        if CONFIG.MESSAGE_QUEUE_ENABLED:
            asyncio.create_task(self._setup_message_subscriptions())
    
    async def _setup_message_subscriptions(self):
        """ë©”ì‹œì§€ í êµ¬ë… ì„¤ì •"""
        await message_broker.subscribe(
            MessageType.SIGNAL_ANALYSIS.value,
            self._handle_analysis_request,
            "signal-engine"
        )
        logger.info("Signal Engine ë©”ì‹œì§€ êµ¬ë… ì„¤ì • ì™„ë£Œ")
    
    async def _handle_analysis_request(self, message: Message):
        """ë©”ì‹œì§€ íë¥¼ í†µí•œ ë¶„ì„ ìš”ì²­ ì²˜ë¦¬"""
        try:
            analysis_result = self.analyze(message.payload)
            
            # ê²°ê³¼ë¥¼ ë©”ì‹œì§€ë¡œ ë°œí–‰
            await message_broker.publish(
                MessageType.RISK_CHECK.value,
                {
                    'signal_data': message.payload,
                    'analysis': analysis_result.get('data', {}),
                    'original_correlation_id': message.correlation_id
                },
                "signal-engine",
                "risk-guardian",
                message.correlation_id
            )
        except Exception as e:
            logger.error(f"ë¶„ì„ ìš”ì²­ ì²˜ë¦¬ ì‹¤íŒ¨: {e}")
    
    def analyze(self, data: Dict) -> Dict:
        """í•µì‹¬ 3ê°€ì§€ ì§€í‘œ ë¶„ì„ - í‘œì¤€í™”ëœ ì—ëŸ¬ ì²˜ë¦¬"""
        start_time = TimestampUtil.now_ms()
        
        # 1. ì…ë ¥ ê²€ì¦
        validation_result = self._validate_input(data)
        if validation_result['error']:
            return StandardResponse.error(
                validation_result['message'], 
                "VALIDATION_ERROR",
                validation_result['details']
            )
        
        try:
            # 2. ë¶„ì„ ì‹¤í–‰
            analysis_result = self._perform_analysis(data)
            
            # 3. ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì¶”ê°€
            processing_time = TimestampUtil.now_ms() - start_time
            analysis_result['metadata']['processing_time_ms'] = processing_time
            
            return StandardResponse.success(analysis_result)
            
        except Exception as e:
            logger.error(f"Phoenix95Engine ë¶„ì„ ì˜¤ë¥˜: {str(e)}")
            return StandardResponse.error(
                f'ë¶„ì„ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {str(e)}',
                "ANALYSIS_ERROR"
            )
    
    def _validate_input(self, data: Dict) -> Dict:
        """ì…ë ¥ ë°ì´í„° ê²€ì¦"""
        if not isinstance(data, dict):
            return {
                'error': True,
                'message': 'ì…ë ¥ ë°ì´í„°ê°€ ë”•ì…”ë„ˆë¦¬ í˜•íƒœê°€ ì•„ë‹™ë‹ˆë‹¤',
                'details': {'received_type': type(data).__name__}
            }
        
        required_fields = ['symbol', 'price']
        missing_fields = [field for field in required_fields if field not in data]
        if missing_fields:
            return {
                'error': True,
                'message': f'í•„ìˆ˜ í•„ë“œ ëˆ„ë½: {missing_fields}',
                'details': {'missing_fields': missing_fields, 'required_fields': required_fields}
            }
        
        # ë°ì´í„° íƒ€ì… ê²€ì¦
        try:
            price = float(data['price'])
            if price <= 0:
                return {
                    'error': True,
                    'message': 'ê°€ê²©ì€ 0ë³´ë‹¤ í° ê°’ì´ì–´ì•¼ í•©ë‹ˆë‹¤',
                    'details': {'received_price': data['price']}
                }
        except (ValueError, TypeError):
            return {
                'error': True,
                'message': 'ê°€ê²©ì´ ìœ íš¨í•œ ìˆ«ìê°€ ì•„ë‹™ë‹ˆë‹¤',
                'details': {'received_price': data['price']}
            }
        
        return {'error': False}
    
    def _perform_analysis(self, data: Dict) -> Dict:
        """ì‹¤ì œ ë¶„ì„ ìˆ˜í–‰"""
        # 1. ê¸°ìˆ ì  ë¶„ì„ (30%)
        technical_score = self._analyze_technical(data)
        
        # 2. ê±°ë˜ëŸ‰ ë¶„ì„ (30%)
        volume_score = self._analyze_volume(data)
        
        # 3. ëª¨ë©˜í…€ ë¶„ì„ (40%)
        momentum_score = self._analyze_momentum(data)
        
        # Phoenix 95 ìµœì¢… ì ìˆ˜ ê³„ì‚°
        raw_score = (
            technical_score * 0.3 + 
            volume_score * 0.3 + 
            momentum_score * 0.4
        )
        
        # Phoenix 95 ê°€ì¤‘ì¹˜ ì ìš©
        phoenix_score = raw_score * CONFIG.PHOENIX_WEIGHT
        
        # ì ìˆ˜ ì •ê·œí™” (ì•ˆì „ì¥ì¹˜)
        phoenix_score = max(0.0, min(phoenix_score, 1.0))
        
        return {
            'phoenix_score': round(phoenix_score, 4),
            'confidence': round(phoenix_score, 4),
            'recommendation': self._get_recommendation(phoenix_score),
            'components': {
                'technical': round(technical_score, 3),
                'volume': round(volume_score, 3),
                'momentum': round(momentum_score, 3)
            },
            'metadata': {
                'engine': self.name,
                'version': self.version,
                'timestamp': TimestampUtil.now(),
                'data_quality': self._assess_data_quality(data),
                'circuit_breaker_state': self.circuit_breaker.get_state()['state']
            }
        }
    
    def _assess_data_quality(self, data: Dict) -> str:
        """ë°ì´í„° í’ˆì§ˆ í‰ê°€ - ê°œì„ ë¨"""
        quality_checks = [
            ('symbol', lambda x: isinstance(x, str) and len(x) > 0),
            ('price', lambda x: isinstance(x, (int, float)) and x > 0),
            ('volume', lambda x: isinstance(x, (int, float)) and x >= 0),
            ('rsi', lambda x: isinstance(x, (int, float)) and 0 <= x <= 100),
            ('macd_line', lambda x: isinstance(x, (int, float))),
            ('macd_signal', lambda x: isinstance(x, (int, float)))
        ]
        
        passed_checks = 0
        total_checks = len(quality_checks)
        
        for field, validator in quality_checks:
            if field in data:
                try:
                    if validator(data[field]):
                        passed_checks += 1
                except:
                    pass
        
        quality_ratio = passed_checks / total_checks
        
        if quality_ratio >= 0.8:
            return "HIGH"
        elif quality_ratio >= 0.6:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _analyze_technical(self, data: Dict) -> float:
        """ê¸°ìˆ ì  ì§€í‘œ ë¶„ì„"""
        rsi = data.get('rsi', 50)
        macd_line = data.get('macd_line', 0)
        macd_signal = data.get('macd_signal', 0)
        bb_position = data.get('bb_position', 0.5)
        
        # RSI ì ìˆ˜ (í—¤ì§€í€ë“œ ê²€ì¦ ë¡œì§)
        if rsi < 30:
            rsi_score = 0.9
        elif rsi < 40:
            rsi_score = 0.7
        elif rsi < 60:
            rsi_score = 0.5
        elif rsi < 70:
            rsi_score = 0.3
        else:
            rsi_score = 0.1
        
        # MACD ì ìˆ˜
        macd_diff = macd_line - macd_signal
        if abs(macd_diff) > 100:  # ì´ìƒê°’ ë°©ì§€
            macd_diff = 100 if macd_diff > 0 else -100
        macd_score = 0.5 + (macd_diff / 200)  # ì •ê·œí™”
        macd_score = max(0, min(macd_score, 1))
        
        # ë³¼ë¦°ì €ë°´ë“œ ì ìˆ˜
        bb_score = max(0, min(bb_position, 1))  # 0~1 ë²”ìœ„ ë³´ì¥
        
        # ê°€ì¤‘ í‰ê· 
        technical_score = (rsi_score * 0.5 + macd_score * 0.3 + bb_score * 0.2)
        return max(0, min(technical_score, 1))
    
    def _analyze_volume(self, data: Dict) -> float:
        """ê±°ë˜ëŸ‰ ë¶„ì„"""
        current_volume = data.get('volume', 1000000)
        avg_volume = data.get('avg_volume_20', 1000000)
        
        if avg_volume <= 0:
            return 0.5
        
        volume_ratio = current_volume / avg_volume
        
        # ì´ìƒê°’ ì²˜ë¦¬
        volume_ratio = max(0.1, min(volume_ratio, 10.0))
        
        # í—¤ì§€í€ë“œ ê±°ë˜ëŸ‰ í•´ì„
        if volume_ratio > 3.0:
            return 0.95
        elif volume_ratio > 2.0:
            return 0.85
        elif volume_ratio > 1.5:
            return 0.75
        elif volume_ratio > 1.2:
            return 0.65
        elif volume_ratio > 0.8:
            return 0.55
        else:
            return 0.3
    
    def _analyze_momentum(self, data: Dict) -> float:
        """ëª¨ë©˜í…€ ë¶„ì„"""
        stoch_k = data.get('stoch_k', 50)
        stoch_d = data.get('stoch_d', 50)
        williams_r = data.get('williams_r', -50)
        cci = data.get('cci', 0)
        
        # ì…ë ¥ê°’ ë²”ìœ„ ê²€ì¦
        stoch_k = max(0, min(stoch_k, 100))
        stoch_d = max(0, min(stoch_d, 100))
        williams_r = max(-100, min(williams_r, 0))
        cci = max(-300, min(cci, 300))
        
        # Stochastic ì ìˆ˜
        if stoch_k < 20 and stoch_d < 20:
            stoch_score = 0.9
        elif stoch_k > 80 and stoch_d > 80:
            stoch_score = 0.1
        else:
            stoch_score = 0.5
        
        # Williams %R ì ìˆ˜
        if williams_r < -80:
            williams_score = 0.9
        elif williams_r > -20:
            williams_score = 0.1
        else:
            williams_score = 0.5
        
        # CCI ì ìˆ˜
        if cci < -100:
            cci_score = 0.9
        elif cci > 100:
            cci_score = 0.1
        else:
            cci_score = 0.5 + (cci / 200)
            cci_score = max(0, min(cci_score, 1))
        
        # ê°€ì¤‘ í‰ê· 
        momentum_score = (stoch_score * 0.4 + williams_score * 0.3 + cci_score * 0.3)
        return max(0, min(momentum_score, 1))
    
    def _get_recommendation(self, score: float) -> str:
        """ì¶”ì²œ ë“±ê¸‰ (í—¤ì§€í€ë“œ ê¸°ì¤€)"""
        if score > 0.85:
            return "STRONG_BUY"
        elif score > 0.75:
            return "BUY"
        elif score > 0.60:
            return "WEAK_BUY"
        elif score > 0.40:
            return "HOLD"
        elif score > 0.25:
            return "WEAK_SELL"
        elif score > 0.15:
            return "SELL"
        else:
            return "STRONG_SELL"

# Signal Engine FastAPI ì•±
signal_app = FastAPI(
    title="Phoenix 95 Signal Engine",
    version="4.3.0",
    description="í—¤ì§€í€ë“œê¸‰ AI ì‹ í˜¸ ë¶„ì„ ì—”ì§„ (Advanced)"
)

phoenix_engine = Phoenix95Engine()

@signal_app.post("/analyze")
async def analyze_signal(data: dict):
    """í•µì‹¬ ì‹ í˜¸ ë¶„ì„ API - ë©”ì‹œì§€ í í†µí•©"""
    try:
        if CONFIG.MESSAGE_QUEUE_ENABLED:
            # ë©”ì‹œì§€ íë¥¼ í†µí•œ ë¹„ë™ê¸° ì²˜ë¦¬
            correlation_id = str(uuid.uuid4())
            
            await message_broker.publish(
                MessageType.SIGNAL_ANALYSIS.value,
                data,
                "api-gateway",
                "signal-engine",
                correlation_id
            )
            
            return StandardResponse.success({
                'message': 'ë¶„ì„ ìš”ì²­ì´ íì— ë“±ë¡ë˜ì—ˆìŠµë‹ˆë‹¤',
                'correlation_id': correlation_id,
                'processing_mode': 'async'
            })
        else:
            # ê¸°ì¡´ ë™ê¸° ì²˜ë¦¬
            analysis = phoenix_engine.analyze(data)
            
            if analysis.get('error'):
                raise HTTPException(status_code=400, detail=analysis['error'])
            
            analysis_data = analysis.get('data', {})
            if analysis_data.get('confidence', 0) > CONFIG.MIN_CONFIDENCE:
                # ë¦¬ìŠ¤í¬ ì²´í¬ë¥¼ ë©”ì‹œì§€ë¡œ ì „ì†¡ ë˜ëŠ” ì§ì ‘ í˜¸ì¶œ
                if CONFIG.MESSAGE_QUEUE_ENABLED:
                    await message_broker.publish(
                        MessageType.RISK_CHECK.value,
                        {'signal_data': data, 'analysis': analysis_data},
                        "signal-engine",
                        "risk-guardian"
                    )
                else:
                    risk_check = await call_service_with_circuit_breaker(
                        'risk-guardian', 
                        '/check',
                        {'signal_data': data, 'analysis': analysis_data},
                        phoenix_engine.circuit_breaker
                    )
                    analysis_data['risk_check'] = risk_check
            
            return StandardResponse.success({
                'analysis': analysis_data,
                'engine': 'Phoenix 95 V4.3 Advanced',
            })
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ì‹ í˜¸ ë¶„ì„ ì‹¤íŒ¨: {str(e)}")
        raise HTTPException(status_code=500, detail=f"ë¶„ì„ ì‹¤íŒ¨: {str(e)}")

@signal_app.get("/health")
async def health():
    return StandardResponse.success({
        'service': 'signal_engine',
        'engine': phoenix_engine.name,
        'version': phoenix_engine.version,
        'circuit_breaker': phoenix_engine.circuit_breaker.get_state(),
        'message_queue_enabled': CONFIG.MESSAGE_QUEUE_ENABLED
    })

@signal_app.get("/")
async def root():
    return StandardResponse.success({
        'service': 'Phoenix 95 Signal Engine',
        'version': '4.3.0',
        'description': 'í—¤ì§€í€ë“œê¸‰ AI ì‹ í˜¸ ë¶„ì„ (Advanced)',
        'features': {
            'message_queue': CONFIG.MESSAGE_QUEUE_ENABLED,
            'circuit_breaker': CONFIG.CIRCUIT_BREAKER_ENABLED,
            'load_balancing': CONFIG.ENABLE_LOAD_BALANCING
        },
        'endpoints': {
            'analyze': 'POST /analyze',
            'health': 'GET /health'
        }
    })

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ›¡ï¸ 2. RISK GUARDIAN (í¬íŠ¸: 8101) - ë©”ì‹œì§€ í í†µí•©
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class RiskGuardian:
    """í—¤ì§€í€ë“œê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œ - ë©”ì‹œì§€ í í†µí•©"""
    
    def __init__(self, data_dir: str = "./data"):
        # ë°ì´í„° ë””ë ‰í† ë¦¬ ìƒì„±
        self.data_dir = Path(data_dir)
        self.data_dir.mkdir(exist_ok=True)
        self.state_file = self.data_dir / "risk_state.json"
        
        # íŒŒì¼ ì ê¸ˆìš©
        self._lock = threading.RLock()  # ì¬ì§„ì… ê°€ëŠ¥í•œ ì ê¸ˆ
        
        # ìƒíƒœ ë¡œë“œ ë˜ëŠ” ì´ˆê¸°í™”
        self._load_state()
        
        # ë¦¬ìŠ¤í¬ ë©”íŠ¸ë¦­
        self.risk_metrics = {
            'daily_trades': 0,
            'success_rate': 0.0,
            'avg_holding_time': 0.0,
            'max_drawdown': 0.0
        }
        
        # NEW: ì„œí‚· ë¸Œë ˆì´ì»¤
        self.circuit_breaker = CircuitBreaker(failure_threshold=2, timeout=15)
        
        # ì¼ì¼ ë¦¬ì…‹ ì²´í¬
        self._check_daily_reset()
        
        # NEW: ë©”ì‹œì§€ í êµ¬ë…
        if CONFIG.MESSAGE_QUEUE_ENABLED:
            asyncio.create_task(self._setup_message_subscriptions())
    
    async def _setup_message_subscriptions(self):
        """ë©”ì‹œì§€ í êµ¬ë… ì„¤ì •"""
        await message_broker.subscribe(
            MessageType.RISK_CHECK.value,
            self._handle_risk_check_request,
            "risk-guardian"
        )
        logger.info("Risk Guardian ë©”ì‹œì§€ êµ¬ë… ì„¤ì • ì™„ë£Œ")
    
    async def _handle_risk_check_request(self, message: Message):
        """ë©”ì‹œì§€ íë¥¼ í†µí•œ ë¦¬ìŠ¤í¬ ì²´í¬ ìš”ì²­ ì²˜ë¦¬"""
        try:
            payload = message.payload
            signal_data = payload.get('signal_data', {})
            analysis = payload.get('analysis', {})
            
            risk_result = self.check_trade_approval(signal_data, analysis)
            
            # ìŠ¹ì¸ëœ ê²½ìš° ê±°ë˜ ì‹¤í–‰ê¸°ë¡œ ë©”ì‹œì§€ ì „ì†¡
            if risk_result.get('approved'):
                await message_broker.publish(
                    MessageType.TRADE_EXECUTE.value,
                    {
                        'signal': signal_data,
                        'risk_approval': risk_result,
                        'analysis': analysis,
                        'original_correlation_id': message.correlation_id
                    },
                    "risk-guardian",
                    "trade-executor",
                    message.correlation_id
                )
            
            # ê²°ê³¼ë¥¼ ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œì— ì•Œë¦¼
            await message_broker.publish(
                MessageType.SYSTEM_ALERT.value,
                {
                    'type': 'RISK_CHECK_RESULT',
                    'approved': risk_result.get('approved'),
                    'risk_level': risk_result.get('risk_level'),
                    'symbol': signal_data.get('symbol', 'UNKNOWN')
                },
                "risk-guardian",
                "monitor-alert"
            )
            
        except Exception as e:
            logger.error(f"ë¦¬ìŠ¤í¬ ì²´í¬ ìš”ì²­ ì²˜ë¦¬ ì‹¤íŒ¨: {e}")
    
    def _load_state(self):
        """ì €ì¥ëœ ìƒíƒœ ë¡œë“œ - ì ê¸ˆ ì ìš©"""
        with self._lock:
            try:
                if self.state_file.exists():
                    with open(self.state_file, 'r', encoding='utf-8') as f:
                        state = json.load(f)
                        self.daily_pnl = state.get('daily_pnl', 0.0)
                        self.active_positions = state.get('active_positions', 0)
                        self.total_exposure = state.get('total_exposure', 0.0)
                        self.position_history = state.get('position_history', [])
                        last_reset_str = state.get('last_reset', datetime.now().date().isoformat())
                        self.last_reset = datetime.fromisoformat(last_reset_str).date()
                        logger.info("ë¦¬ìŠ¤í¬ ìƒíƒœ ë¡œë“œ ì™„ë£Œ")
                else:
                    self._init_default_state()
            except Exception as e:
                logger.warning(f"ìƒíƒœ ë¡œë“œ ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©: {e}")
                self._init_default_state()
    
    def _init_default_state(self):
        """ê¸°ë³¸ ìƒíƒœ ì´ˆê¸°í™”"""
        self.daily_pnl = 0.0
        self.active_positions = 0
        self.total_exposure = 0.0
        self.position_history = []
        self.last_reset = datetime.now().date()
    
    def _save_state(self):
        """í˜„ì¬ ìƒíƒœ ì €ì¥ - ì›ìì  ì“°ê¸°"""
        with self._lock:
            try:
                state = {
                    'daily_pnl': self.daily_pnl,
                    'active_positions': self.active_positions,
                    'total_exposure': self.total_exposure,
                    'position_history': self.position_history[-100:],
                    'last_reset': self.last_reset.isoformat(),
                    'last_updated': TimestampUtil.now(),
                    'version': '4.3.0'
                }
                
                # ì„ì‹œ íŒŒì¼ì— ì“°ê³  ì›ìì ìœ¼ë¡œ ì´ë™
                temp_file = self.state_file.with_suffix('.tmp')
                with open(temp_file, 'w', encoding='utf-8') as f:
                    json.dump(state, f, indent=2, ensure_ascii=False)
                
                # íŒŒì¼ ê¶Œí•œ ì„¤ì • (600 - ì†Œìœ ìë§Œ ì½ê¸°/ì“°ê¸°)
                temp_file.chmod(0o600)
                
                # ì›ìì  ì´ë™
                temp_file.replace(self.state_file)
                
            except Exception as e:
                logger.warning(f"ìƒíƒœ ì €ì¥ ì‹¤íŒ¨: {e}")
    
    def check_trade_approval(self, signal_data: Dict, analysis: Dict) -> Dict:
        """ê±°ë˜ ìŠ¹ì¸ ì—¬ë¶€ ê²°ì • - í‘œì¤€í™”ëœ ê²€ì¦"""
        with self._lock:  # ë™ì‹œì„± ë³´ì¥
            checks = []
            approved = True
            risk_level = 'LOW'
            
            # ì¼ì¼ ë¦¬ì…‹ ì²´í¬
            self._check_daily_reset()
            
            try:
                # 1. ì¼ì¼ ì†ì‹¤ í•œë„ ì²´í¬
                if abs(self.daily_pnl) >= CONFIG.MAX_DAILY_LOSS:
                    approved = False
                    risk_level = 'CRITICAL'
                    checks.append(f"ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼: {self.daily_pnl:.2%}")
                
                # 2. í¬ì§€ì…˜ ìˆ˜ í•œë„ ì²´í¬
                if self.active_positions >= CONFIG.MAX_POSITIONS:
                    approved = False
                    risk_level = 'HIGH'
                    checks.append(f"ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ë„ë‹¬: {self.active_positions}/{CONFIG.MAX_POSITIONS}")
                
                # 3. ì‹ ë¢°ë„ ì²´í¬
                confidence = analysis.get('confidence', 0)
                if confidence < CONFIG.MIN_CONFIDENCE:
                    approved = False
                    risk_level = 'MEDIUM'
                    checks.append(f"ì‹ ë¢°ë„ ë¶€ì¡±: {confidence:.3f} < {CONFIG.MIN_CONFIDENCE}")
                
                # 4. í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
                account_balance = signal_data.get('account_balance', 10000)
                if account_balance <= 0:
                    approved = False
                    risk_level = 'CRITICAL'
                    checks.append("ê³„ì¢Œ ì”ê³ ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ")
                    position_size = 0
                else:
                    position_size = self._calculate_position_size(account_balance, confidence)
                
                # 5. ì´ ë…¸ì¶œ í•œë„ ì²´í¬
                if account_balance > 0:
                    projected_exposure = self.total_exposure + (position_size / account_balance)
                    if projected_exposure > 0.20:  # ì´ 20% í•œë„
                        approved = False
                        risk_level = 'HIGH'
                        checks.append(f"ì´ ë…¸ì¶œ í•œë„ ì´ˆê³¼: {projected_exposure:.2%}")
                else:
                    projected_exposure = 0
                
                # 6. ì‹œì¥ ì¡°ê±´ ì²´í¬
                market_condition = self._assess_market_condition(signal_data)
                if market_condition == 'HIGH_VOLATILITY' and len(checks) > 0:
                    approved = False
                    risk_level = 'HIGH'
                    checks.append("ê³ ë³€ë™ì„± ì‹œì¥ì—ì„œ ì¶”ê°€ ë¦¬ìŠ¤í¬ ìš”ì¸ ì¡´ì¬")
                
                # ìŠ¹ì¸ëœ ê²½ìš°ì—ë§Œ í¬ì§€ì…˜ í¬ê¸° ì œê³µ
                final_position_size = position_size if approved else 0
                
                return {
                    'approved': approved,
                    'position_size': final_position_size,
                    'position_size_pct': final_position_size / account_balance if account_balance > 0 else 0,
                    'risk_level': risk_level,
                    'checks': checks,
                    'risk_metrics': {
                        'current_exposure': self.total_exposure,
                        'projected_exposure': projected_exposure,
                        'daily_pnl': self.daily_pnl,
                        'active_positions': self.active_positions,
                        'market_condition': market_condition
                    },
                    'kelly_sizing': {
                        'base_size': final_position_size * 0.8,
                        'confidence_adjusted': final_position_size,
                        'max_allowed': account_balance * CONFIG.MAX_POSITION_SIZE
                    },
                    'circuit_breaker_state': self.circuit_breaker.get_state()['state']
                }
                
            except Exception as e:
                logger.error(f"ë¦¬ìŠ¤í¬ ì²´í¬ ì˜¤ë¥˜: {e}")
                return {
                    'approved': False,
                    'position_size': 0,
                    'position_size_pct': 0,
                    'risk_level': 'CRITICAL',
                    'checks': [f"ë¦¬ìŠ¤í¬ ì²´í¬ ì‹¤í–‰ ì˜¤ë¥˜: {str(e)}"],
                    'error': str(e)
                }
    
    def update_position_status(self, position_update: Dict):
        """í¬ì§€ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸ - ë™ì‹œì„± ë³´ì¥"""
        with self._lock:
            try:
                action = position_update.get('action')
                
                if action == 'open':
                    self.active_positions += 1
                    self.total_exposure += position_update.get('size_pct', 0)
                    self.risk_metrics['daily_trades'] += 1
                    
                elif action == 'close':
                    self.active_positions = max(0, self.active_positions - 1)
                    self.total_exposure -= position_update.get('size_pct', 0)
                    self.total_exposure = max(0, self.total_exposure)
                    
                    # P&L ì—…ë°ì´íŠ¸
                    pnl_pct = position_update.get('pnl_pct', 0)
                    self.daily_pnl += pnl_pct
                
                # í¬ì§€ì…˜ íˆìŠ¤í† ë¦¬ ê¸°ë¡
                self.position_history.append({
                    **position_update,
                    'timestamp': TimestampUtil.now()
                })
                
                # ìƒíƒœ ì €ì¥
                self._save_state()
                
            except Exception as e:
                logger.error(f"í¬ì§€ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
                raise
    
    def _calculate_position_size(self, balance: float, confidence: float) -> float:
        """Kelly Criterion ê¸°ë°˜ í¬ì§€ì…˜ ì‚¬ì´ì§• - ê°œì„ ë¨"""
        try:
            # ì…ë ¥ ê²€ì¦
            if balance <= 0 or confidence < 0 or confidence > 1:
                return 0.0
            
            # ê¸°ë³¸ ë¦¬ìŠ¤í¬ (ê³„ì¢Œì˜ 2%)
            base_risk_amount = balance * CONFIG.MAX_DAILY_LOSS
            
            # ì‹ ë¢°ë„ ê¸°ë°˜ ì¡°ì • (75%-100% ì‹ ë¢°ë„ë¥¼ 0.8-1.2ë°°ë¡œ ë§¤í•‘)
            confidence_factor = 0.8 + max(0, confidence - 0.75) * 1.6
            confidence_factor = max(0.5, min(confidence_factor, 1.2))
            
            # Kelly Criterion ê·¼ì‚¬ (ë³´ìˆ˜ì )
            estimated_win_rate = 0.6 + max(0, confidence - 0.75) * 0.4  # 0.6 ~ 1.0
            kelly_fraction = max(0, (estimated_win_rate * 2) - 1)  # Kelly ê³µì‹ ë‹¨ìˆœí™”
            kelly_fraction = max(0.05, min(kelly_fraction, 0.20))  # 5%-20% ì œí•œ
            
            # ìµœì¢… í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
            kelly_size = balance * kelly_fraction
            confidence_adjusted_size = kelly_size * confidence_factor
            
            # ìµœëŒ€ í•œë„ ì ìš©
            max_position = balance * CONFIG.MAX_POSITION_SIZE
            final_size = min(confidence_adjusted_size, max_position)
            
            return max(0, final_size)
            
        except Exception as e:
            logger.error(f"í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0
    
    def _assess_market_condition(self, data: Dict) -> str:
        """ì‹œì¥ ì¡°ê±´ í‰ê°€"""
        try:
            volatility = data.get('volatility', 0.02)
            volume_ratio = data.get('volume', 1000) / max(data.get('avg_volume_20', 1000), 1)
            
            # ì•ˆì „í•œ ë²”ìœ„ë¡œ ì œí•œ
            volatility = max(0, min(volatility, 1.0))
            volume_ratio = max(0, min(volume_ratio, 10.0))
            
            if volatility > 0.05 or volume_ratio > 3.0:
                return 'HIGH_VOLATILITY'
            elif volatility > 0.03 or volume_ratio > 2.0:
                return 'MEDIUM_VOLATILITY'
            else:
                return 'NORMAL'
        except Exception as e:
            logger.warning(f"ì‹œì¥ ì¡°ê±´ í‰ê°€ ì˜¤ë¥˜: {e}")
            return 'UNKNOWN'
    
    def _check_daily_reset(self):
        """ì¼ì¼ ë¦¬ì…‹ ì²´í¬"""
        today = datetime.now().date()
        if today != self.last_reset:
            self.daily_pnl = 0.0
            self.risk_metrics['daily_trades'] = 0
            self.last_reset = today
            self._save_state()
    
    def get_risk_report(self) -> Dict:
        """ë¦¬ìŠ¤í¬ ë³´ê³ ì„œ ìƒì„±"""
        with self._lock:
            return {
                'current_status': {
                    'daily_pnl': self.daily_pnl,
                    'active_positions': self.active_positions,
                    'total_exposure': self.total_exposure,
                    'risk_utilization': abs(self.daily_pnl) / CONFIG.MAX_DAILY_LOSS if CONFIG.MAX_DAILY_LOSS > 0 else 0
                },
                'limits': {
                    'max_daily_loss': CONFIG.MAX_DAILY_LOSS,
                    'max_positions': CONFIG.MAX_POSITIONS,
                    'max_position_size': CONFIG.MAX_POSITION_SIZE,
                    'min_confidence': CONFIG.MIN_CONFIDENCE
                },
                'metrics': self.risk_metrics.copy(),
                'alerts': self._generate_alerts(),
                'circuit_breaker': self.circuit_breaker.get_state()
            }
    
    def _generate_alerts(self) -> List[str]:
        """ë¦¬ìŠ¤í¬ ì•Œë¦¼ ìƒì„±"""
        alerts = []
        
        try:
            if abs(self.daily_pnl) > CONFIG.MAX_DAILY_LOSS * 0.8:
                alerts.append("ì¼ì¼ ì†ì‹¤ì´ í•œë„ì˜ 80%ì— ë„ë‹¬")
                
            if self.active_positions >= CONFIG.MAX_POSITIONS * 0.8:
                alerts.append("í™œì„± í¬ì§€ì…˜ì´ í•œë„ì˜ 80%ì— ë„ë‹¬")
                
            if self.total_exposure > 0.15:
                alerts.append("ì´ ë…¸ì¶œì´ 15%ë¥¼ ì´ˆê³¼")
                
        except Exception as e:
            logger.warning(f"ì•Œë¦¼ ìƒì„± ì˜¤ë¥˜: {e}")
            alerts.append("ì•Œë¦¼ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ")
            
        return alerts

# Risk Guardian FastAPI ì•±
risk_app = FastAPI(
    title="Phoenix 95 Risk Guardian",
    version="4.3.0",
    description="í—¤ì§€í€ë“œê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œ (Advanced)"
)

risk_guardian = RiskGuardian()

@risk_app.post("/check")
async def check_risk(data: dict):
    """ë¦¬ìŠ¤í¬ ì²´í¬ API"""
    try:
        signal_data = data.get('signal_data', {})
        analysis = data.get('analysis', {})
        
        result = risk_guardian.check_trade_approval(signal_data, analysis)
        
        return StandardResponse.success({
            'risk_check': result
        })
        
    except Exception as e:
        logger.error(f"ë¦¬ìŠ¤í¬ ì²´í¬ ì‹¤íŒ¨: {str(e)}")
        raise HTTPException(status_code=500, detail=f"ë¦¬ìŠ¤í¬ ì²´í¬ ì‹¤íŒ¨: {str(e)}")

@risk_app.post("/update")
async def update_position(data: dict):
    """í¬ì§€ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸"""
    try:
        risk_guardian.update_position_status(data)
        return StandardResponse.success({'updated': True})
    except Exception as e:
        logger.error(f"í¬ì§€ì…˜ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {str(e)}")
        raise HTTPException(status_code=500, detail=f"ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {str(e)}")

@risk_app.get("/status")
async def risk_status():
    """ë¦¬ìŠ¤í¬ ìƒíƒœ ì¡°íšŒ"""
    try:
        report = risk_guardian.get_risk_report()
        return StandardResponse.success(report)
    except Exception as e:
        logger.error(f"ë¦¬ìŠ¤í¬ ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")
        raise HTTPException(status_code=500, detail=f"ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")

@risk_app.get("/health")
async def health():
    return StandardResponse.success({
        'service': 'risk_guardian',
        'active_positions': risk_guardian.active_positions,
        'daily_pnl': risk_guardian.daily_pnl,
        'data_file_exists': risk_guardian.state_file.exists(),
        'circuit_breaker': risk_guardian.circuit_breaker.get_state(),
        'message_queue_enabled': CONFIG.MESSAGE_QUEUE_ENABLED
    })

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš¡ 3. TRADE EXECUTOR (í¬íŠ¸: 8102) - ë©”ì‹œì§€ í í†µí•©
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class TradeExecutor:
    """í—¤ì§€í€ë“œê¸‰ ê±°ë˜ ì‹¤í–‰ ì‹œìŠ¤í…œ - ë©”ì‹œì§€ í í†µí•©"""
    
    def __init__(self):
        # ë³´ì•ˆ ê°•í™”ëœ API í‚¤ ê´€ë¦¬
        self.api_key, self.api_secret = SecurityConfig.get_binance_credentials()
        self.test_mode = os.getenv('TRADE_MODE', 'TEST') == 'TEST'
        
        # ê±°ë˜ ì„¤ì •
        self.leverage = CONFIG.LEVERAGE
        self.stop_loss_pct = CONFIG.STOP_LOSS
        self.take_profit_pct = CONFIG.TAKE_PROFIT
        
        # NEW: ì„œí‚· ë¸Œë ˆì´ì»¤
        self.circuit_breaker = CircuitBreaker(failure_threshold=3, timeout=60)
        
        # ê±°ë˜ í†µê³„ (ìŠ¤ë ˆë“œ ì•ˆì „)
        self._stats_lock = threading.Lock()
        self.execution_stats = {
            'total_trades': 0,
            'successful_trades': 0,
            'failed_trades': 0,
            'avg_execution_time': 0.0,
            'total_volume': 0.0
        }
        
        # NEW: ë©”ì‹œì§€ í êµ¬ë…
        if CONFIG.MESSAGE_QUEUE_ENABLED:
            asyncio.create_task(self._setup_message_subscriptions())
    
    async def _setup_message_subscriptions(self):
        """ë©”ì‹œì§€ í êµ¬ë… ì„¤ì •"""
        await message_broker.subscribe(
            MessageType.TRADE_EXECUTE.value,
            self._handle_trade_execution_request,
            "trade-executor"
        )
        logger.info("Trade Executor ë©”ì‹œì§€ êµ¬ë… ì„¤ì • ì™„ë£Œ")
    
    async def _handle_trade_execution_request(self, message: Message):
        """ë©”ì‹œì§€ íë¥¼ í†µí•œ ê±°ë˜ ì‹¤í–‰ ìš”ì²­ ì²˜ë¦¬"""
        try:
            payload = message.payload
            signal = payload.get('signal', {})
            risk_approval = payload.get('risk_approval', {})
            
            execution_result = await self.execute_trade(signal, risk_approval)
            
            # ê²°ê³¼ë¥¼ ë©”ì‹œì§€ë¡œ ë°œí–‰
            await message_broker.publish(
                MessageType.TRADE_RESULT.value,
                {
                    'execution_result': execution_result,
                    'signal': signal,
                    'risk_approval': risk_approval,
                    'original_correlation_id': message.correlation_id
                },
                "trade-executor",
                "monitor-alert",
                message.correlation_id
            )
            
        except Exception as e:
            logger.error(f"ê±°ë˜ ì‹¤í–‰ ìš”ì²­ ì²˜ë¦¬ ì‹¤íŒ¨: {e}")
    
    async def execute_trade(self, signal: Dict, risk_approval: Dict) -> Dict:
        """ê±°ë˜ ì‹¤í–‰ - ì™„ì „í•œ ì—ëŸ¬ ì²˜ë¦¬"""
        execution_start = TimestampUtil.now_ms()
        
        try:
            # 1. ì…ë ¥ ê²€ì¦
            validation_result = self._validate_trade_inputs(signal, risk_approval)
            if validation_result['error']:
                return StandardResponse.error(
                    validation_result['message'],
                    "VALIDATION_ERROR", 
                    validation_result['details']
                )
            
            # 2. ë¦¬ìŠ¤í¬ ìŠ¹ì¸ ê²€ì¦
            if not risk_approval.get('approved'):
                return StandardResponse.error(
                    'Risk not approved',
                    "RISK_REJECTED",
                    {
                        'risk_checks': risk_approval.get('checks', []),
                        'risk_level': risk_approval.get('risk_level', 'UNKNOWN')
                    }
                )
            
            # 3. API í‚¤ ê²€ì¦ (LIVE ëª¨ë“œ)
            if not self.test_mode and (not self.api_key or not self.api_secret):
                return StandardResponse.error(
                    'LIVE ëª¨ë“œì´ì§€ë§Œ API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ',
                    "API_KEY_MISSING"
                )
            
            # 4. ì„œí‚· ë¸Œë ˆì´ì»¤ë¥¼ í†µí•œ ê±°ë˜ ì‹¤í–‰
            execution_result = await self.circuit_breaker.call(
                self._execute_trade_internal, signal, risk_approval
            )
            
            # 5. í†µê³„ ì—…ë°ì´íŠ¸
            execution_time = TimestampUtil.now_ms() - execution_start
            success = execution_result.get('status') == 'executed'
            position_size = risk_approval.get('position_size', 0)
            
            self._update_execution_stats(execution_time, position_size, success)
            
            return StandardResponse.success(execution_result)
            
        except Exception as e:
            logger.error(f"ê±°ë˜ ì‹¤í–‰ ì˜ˆì™¸: {str(e)}")
            self._update_execution_stats(0, 0, False)
            return StandardResponse.error(
                f"ê±°ë˜ ì‹¤í–‰ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {str(e)}",
                "EXECUTION_EXCEPTION"
            )
    
    def _validate_trade_inputs(self, signal: Dict, risk_approval: Dict) -> Dict:
        """ê±°ë˜ ì…ë ¥ ê²€ì¦"""
        # íƒ€ì… ê²€ì¦
        if not isinstance(signal, dict) or not isinstance(risk_approval, dict):
            return {
                'error': True,
                'message': 'ì˜ëª»ëœ ì…ë ¥ ë°ì´í„° íƒ€ì…',
                'details': {
                    'signal_type': type(signal).__name__,
                    'risk_approval_type': type(risk_approval).__name__
                }
            }
        
        # í•„ìˆ˜ ì‹ í˜¸ ë°ì´í„° ê²€ì¦
        required_signal_fields = ['symbol', 'side', 'price']
        missing_fields = [field for field in required_signal_fields if field not in signal]
        if missing_fields:
            return {
                'error': True,
                'message': f'ì‹ í˜¸ ë°ì´í„°ì— í•„ìˆ˜ í•„ë“œ ëˆ„ë½: {missing_fields}',
                'details': {'missing_fields': missing_fields}
            }
        
        # ì‹ í˜¸ ë°ì´í„° ê°’ ê²€ì¦
        try:
            price = float(signal['price'])
            if price <= 0:
                return {
                    'error': True,
                    'message': 'ê°€ê²©ì€ 0ë³´ë‹¤ í° ê°’ì´ì–´ì•¼ í•©ë‹ˆë‹¤',
                    'details': {'price': signal['price']}
                }
        except (ValueError, TypeError):
            return {
                'error': True,
                'message': 'ê°€ê²©ì´ ìœ íš¨í•œ ìˆ«ìê°€ ì•„ë‹™ë‹ˆë‹¤',
                'details': {'price': signal['price']}
            }
        
        # ê±°ë˜ ë°©í–¥ ê²€ì¦
        if signal['side'] not in ['BUY', 'SELL', 'buy', 'sell']:
            return {
                'error': True,
                'message': 'ìœ íš¨í•˜ì§€ ì•Šì€ ê±°ë˜ ë°©í–¥',
                'details': {'side': signal['side'], 'valid_sides': ['BUY', 'SELL']}
            }
        
        # í¬ì§€ì…˜ í¬ê¸° ê²€ì¦
        position_size = risk_approval.get('position_size', 0)
        if position_size <= 0:
            return {
                'error': True,
                'message': 'ìœ íš¨í•˜ì§€ ì•Šì€ í¬ì§€ì…˜ í¬ê¸°',
                'details': {'position_size': position_size}
            }
        
        return {'error': False}
    
    async def _execute_trade_internal(self, signal: Dict, risk_approval: Dict) -> Dict:
        """ë‚´ë¶€ ê±°ë˜ ì‹¤í–‰ ë¡œì§"""
        # 1. ë ˆë²„ë¦¬ì§€ ì„¤ì •
        leverage_result = await self._set_leverage(signal['symbol'])
        if not leverage_result.get('success', True):
            return {
                'status': 'failed',
                'reason': f"ë ˆë²„ë¦¬ì§€ ì„¤ì • ì‹¤íŒ¨: {leverage_result.get('error', 'Unknown')}"
            }
        
        # 2. ì£¼ë¬¸ ì‹¤í–‰
        order_result = await self._place_order(
            symbol=signal['symbol'],
            side=signal['side'].upper(),
            quantity=risk_approval['position_size'],
            price=float(signal['price'])
        )
        
        if order_result['status'] == 'FILLED':
            # 3. ìµì ˆ/ì†ì ˆ ì£¼ë¬¸ ì„¤ì •
            stop_orders = await self._set_stop_orders(order_result, signal['side'].upper())
            
            # 4. Risk Guardianì— í¬ì§€ì…˜ ì˜¤í”ˆ ì•Œë¦¼ (ë©”ì‹œì§€ í ë˜ëŠ” ì§ì ‘)
            try:
                if CONFIG.MESSAGE_QUEUE_ENABLED:
                    await message_broker.publish(
                        MessageType.SYSTEM_ALERT.value,
                        {
                            'type': 'POSITION_OPENED',
                            'action': 'open',
                            'size_pct': risk_approval['position_size'] / signal.get('account_balance', 10000),
                            'symbol': signal['symbol']
                        },
                        "trade-executor",
                        "risk-guardian"
                    )
                else:
                    await call_service_with_circuit_breaker(
                        'risk-guardian', 
                        '/update', 
                        {
                            'action': 'open',
                            'size_pct': risk_approval['position_size'] / signal.get('account_balance', 10000),
                            'symbol': signal['symbol']
                        },
                        self.circuit_breaker
                    )
            except Exception as e:
                logger.warning(f"Risk Guardian ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
            
            return {
                'status': 'executed',
                'order_details': {
                    'order_id': order_result['orderId'],
                    'symbol': signal['symbol'],
                    'side': signal['side'].upper(),
                    'executed_price': order_result['price'],
                    'executed_qty': order_result['executedQty'],
                    'leverage': self.leverage
                },
                'risk_management': {
                    'stop_loss_price': stop_orders['stop_loss'],
                    'take_profit_price': stop_orders['take_profit'],
                    'liquidation_price': self._calculate_liquidation_price(
                        order_result['price'], signal['side'].upper()
                    )
                },
                'metadata': {
                    'execution_mode': 'TEST' if self.test_mode else 'LIVE',
                    'timestamp': TimestampUtil.now(),
                    'circuit_breaker_state': self.circuit_breaker.get_state()['state']
                }
            }
        else:
            return {
                'status': 'failed',
                'reason': f"ì£¼ë¬¸ ì‹¤íŒ¨: {order_result.get('msg', 'Unknown error')}",
                'order_details': order_result
            }
    
    async def _set_leverage(self, symbol: str) -> Dict:
        """ë ˆë²„ë¦¬ì§€ ì„¤ì •"""
        try:
            if self.test_mode:
                logger.info(f"[TEST MODE] Setting {symbol} leverage to {self.leverage}x ISOLATED")
                return {'success': True, 'leverage': self.leverage}
            
            # ì‹¤ì œ Binance API í˜¸ì¶œ ì‹œë®¬ë ˆì´ì…˜
            await asyncio.sleep(0.01)  # API í˜¸ì¶œ ì‹œë®¬ë ˆì´ì…˜
            return {'success': True, 'leverage': self.leverage}
            
        except Exception as e:
            logger.error(f"ë ˆë²„ë¦¬ì§€ ì„¤ì • ì˜¤ë¥˜: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _place_order(self, symbol: str, side: str, quantity: float, price: float) -> Dict:
        """ì£¼ë¬¸ ì‹¤í–‰"""
        try:
            if self.test_mode:
                # í…ŒìŠ¤íŠ¸ ëª¨ë“œ: ì‹œë®¬ë ˆì´ì…˜
                order_id = f"TEST_{TimestampUtil.now_ms()}"
                logger.info(f"[TEST MODE] Placing {side} order: {symbol} @ ${price:,.2f}, qty: {quantity:,.2f}")
                
                # ì•½ê°„ì˜ ì§€ì—° ì‹œë®¬ë ˆì´ì…˜
                await asyncio.sleep(0.05)
                
                return {
                    'orderId': order_id,
                    'status': 'FILLED',
                    'price': price,
                    'executedQty': quantity,
                    'symbol': symbol,
                    'side': side
                }
            
            # ì‹¤ì œ Binance API í˜¸ì¶œ
            # í˜„ì¬ëŠ” ì‹œë®¬ë ˆì´ì…˜ìœ¼ë¡œ ëŒ€ì²´
            await asyncio.sleep(0.1)  # API í˜¸ì¶œ ì‹œë®¬ë ˆì´ì…˜
            return {
                'orderId': f"LIVE_{TimestampUtil.now_ms()}",
                'status': 'FILLED',
                'price': price,
                'executedQty': quantity,
                'symbol': symbol,
                'side': side
            }
            
        except Exception as e:
            logger.error(f"ì£¼ë¬¸ ì‹¤í–‰ ì˜¤ë¥˜: {e}")
            return {
                'status': 'FAILED',
                'msg': str(e)
            }
    
    async def _set_stop_orders(self, order_result: Dict, side: str) -> Dict:
        """ìµì ˆ/ì†ì ˆ ì£¼ë¬¸ ì„¤ì •"""
        try:
            entry_price = float(order_result['price'])
            
            if side == 'BUY':
                stop_loss = entry_price * (1 - self.stop_loss_pct)
                take_profit = entry_price * (1 + self.take_profit_pct)
            else:  # SELL
                stop_loss = entry_price * (1 + self.stop_loss_pct)
                take_profit = entry_price * (1 - self.take_profit_pct)
            
            if self.test_mode:
                logger.info(f"[TEST MODE] Stop orders set - SL: ${stop_loss:,.2f}, TP: ${take_profit:,.2f}")
            
            return {
                'stop_loss': stop_loss,
                'take_profit': take_profit
            }
            
        except Exception as e:
            logger.error(f"ìµì ˆ/ì†ì ˆ ì„¤ì • ì˜¤ë¥˜: {e}")
            return {
                'stop_loss': 0,
                'take_profit': 0
            }
    
    def _calculate_liquidation_price(self, entry_price: float, side: str) -> float:
        """ì²­ì‚°ê°€ ê³„ì‚°"""
        try:
            maintenance_margin = 0.004  # 0.4%
            
            if side == 'BUY':
                liquidation_price = entry_price * (1 - (1/self.leverage) + maintenance_margin)
            else:  # SELL
                liquidation_price = entry_price * (1 + (1/self.leverage) - maintenance_margin)
            
            return max(0, liquidation_price)  # ìŒìˆ˜ ë°©ì§€
            
        except Exception as e:
            logger.error(f"ì²­ì‚°ê°€ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0
    
    def _update_execution_stats(self, execution_time: float, volume: float, success: bool):
        """ì‹¤í–‰ í†µê³„ ì—…ë°ì´íŠ¸ - ìŠ¤ë ˆë“œ ì•ˆì „"""
        with self._stats_lock:
            try:
                self.execution_stats['total_trades'] += 1
                
                if success:
                    self.execution_stats['successful_trades'] += 1
                    self.execution_stats['total_volume'] += volume
                    
                    # í‰ê·  ì‹¤í–‰ ì‹œê°„ ì—…ë°ì´íŠ¸
                    current_avg = self.execution_stats['avg_execution_time']
                    total_successful = self.execution_stats['successful_trades']
                    if total_successful > 0:
                        new_avg = ((current_avg * (total_successful - 1)) + execution_time) / total_successful
                        self.execution_stats['avg_execution_time'] = new_avg
                else:
                    self.execution_stats['failed_trades'] += 1
                    
            except Exception as e:
                logger.error(f"í†µê³„ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
    
    def get_execution_report(self) -> Dict:
        """ì‹¤í–‰ ë³´ê³ ì„œ"""
        with self._stats_lock:
            total = self.execution_stats['total_trades']
            success_rate = (
                self.execution_stats['successful_trades'] / total * 100 
                if total > 0 else 0
            )
            
            return {
                'execution_stats': {
                    **self.execution_stats.copy(),
                    'success_rate_pct': round(success_rate, 2)
                },
                'configuration': {
                    'leverage': self.leverage,
                    'stop_loss_pct': self.stop_loss_pct,
                    'take_profit_pct': self.take_profit_pct,
                    'test_mode': self.test_mode,
                    'api_configured': bool(self.api_key and self.api_secret)
                },
                'circuit_breaker': self.circuit_breaker.get_state()
            }

# Trade Executor FastAPI ì•±
trade_app = FastAPI(
    title="Phoenix 95 Trade Executor",
    version="4.3.0",
    description="í—¤ì§€í€ë“œê¸‰ ê±°ë˜ ì‹¤í–‰ ì‹œìŠ¤í…œ (Advanced)"
)

trade_executor = TradeExecutor()

@trade_app.post("/execute")
async def execute_trade(data: dict):
    """ê±°ë˜ ì‹¤í–‰ API"""
    try:
        signal = data.get('signal', {})
        risk_approval = data.get('risk_approval', {})
        
        result = await trade_executor.execute_trade(signal, risk_approval)
        
        # ì—ëŸ¬ê°€ ìˆëŠ” ê²½ìš° HTTP ì˜ˆì™¸ ë°œìƒ
        if result.get('error'):
            raise HTTPException(status_code=400, detail=result['error'])
        
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ê±°ë˜ ì‹¤í–‰ API ì˜¤ë¥˜: {str(e)}")
        raise HTTPException(status_code=500, detail=f"ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨: {str(e)}")

@trade_app.get("/stats")
async def execution_stats():
    """ì‹¤í–‰ í†µê³„ ì¡°íšŒ"""
    try:
        report = trade_executor.get_execution_report()
        return StandardResponse.success(report)
    except Exception as e:
        logger.error(f"í†µê³„ ì¡°íšŒ ì˜¤ë¥˜: {str(e)}")
        raise HTTPException(status_code=500, detail=f"í†µê³„ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")

@trade_app.get("/health")
async def health():
    stats = trade_executor.execution_stats
    return StandardResponse.success({
        'service': 'trade_executor',
        'total_trades': stats['total_trades'],
        'success_rate': (
            stats['successful_trades'] / stats['total_trades'] * 100
            if stats['total_trades'] > 0 else 0
        ),
        'test_mode': trade_executor.test_mode,
        'api_configured': bool(trade_executor.api_key and trade_executor.api_secret),
        'circuit_breaker': trade_executor.circuit_breaker.get_state(),
        'message_queue_enabled': CONFIG.MESSAGE_QUEUE_ENABLED
    })

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š 4. MONITOR & ALERT (í¬íŠ¸: 8103) - ë©”ì‹œì§€ í í†µí•©
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MonitorAlert:
    """í—¤ì§€í€ë“œê¸‰ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ - ë©”ì‹œì§€ í í†µí•©"""
    
    def __init__(self):
        self.telegram_token = CONFIG.get_telegram_token()
        self.chat_id = CONFIG.get_telegram_chat_id()
        self.telegram_enabled = bool(self.telegram_token and self.chat_id)
        
        if not self.telegram_enabled:
            logger.warning("í…”ë ˆê·¸ë¨ ì„¤ì •ì´ ì—†ì–´ ì•Œë¦¼ì´ ë¡œì»¬ ë¡œê·¸ë¡œë§Œ ì¶œë ¥ë©ë‹ˆë‹¤.")
        
        # í¬ì§€ì…˜ ì¶”ì 
        self.positions = {}
        self.alerts_sent = set()
        
        # NEW: ì„œí‚· ë¸Œë ˆì´ì»¤
        self.circuit_breaker = CircuitBreaker(failure_threshold=5, timeout=120)
        
        # ì„±ëŠ¥ ë©”íŠ¸ë¦­
        self.performance_metrics = {
            'total_pnl': 0.0,
            'win_rate': 0.0,
            'avg_trade_duration': 0.0,
            'max_drawdown': 0.0,
            'sharpe_ratio': 0.0
        }
        
        # NEW: ë©”ì‹œì§€ í êµ¬ë…
        if CONFIG.MESSAGE_QUEUE_ENABLED:
            asyncio.create_task(self._setup_message_subscriptions())
    
    async def _setup_message_subscriptions(self):
        """ë©”ì‹œì§€ í êµ¬ë… ì„¤ì •"""
        # ê±°ë˜ ê²°ê³¼ êµ¬ë…
        await message_broker.subscribe(
            MessageType.TRADE_RESULT.value,
            self._handle_trade_result,
            "monitor-alert"
        )
        
        # ì‹œìŠ¤í…œ ì•Œë¦¼ êµ¬ë…
        await message_broker.subscribe(
            MessageType.SYSTEM_ALERT.value,
            self._handle_system_alert,
            "monitor-alert"
        )
        
        logger.info("Monitor & Alert ë©”ì‹œì§€ êµ¬ë… ì„¤ì • ì™„ë£Œ")
    
    async def _handle_trade_result(self, message: Message):
        """ê±°ë˜ ê²°ê³¼ ë©”ì‹œì§€ ì²˜ë¦¬"""
        try:
            payload = message.payload
            await self.send_trade_alert(payload)
        except Exception as e:
            logger.error(f"ê±°ë˜ ê²°ê³¼ ì²˜ë¦¬ ì‹¤íŒ¨: {e}")
    
    async def _handle_system_alert(self, message: Message):
        """ì‹œìŠ¤í…œ ì•Œë¦¼ ë©”ì‹œì§€ ì²˜ë¦¬"""
        try:
            payload = message.payload
            alert_type = payload.get('type', 'SYSTEM')
            message_text = payload.get('message', str(payload))
            severity = payload.get('severity', 'INFO')
            
            await self.send_system_alert(alert_type, message_text, severity)
        except Exception as e:
            logger.error(f"ì‹œìŠ¤í…œ ì•Œë¦¼ ì²˜ë¦¬ ì‹¤íŒ¨: {e}")
    
    async def send_trade_alert(self, trade_data: Dict):
        """ê±°ë˜ ì•Œë¦¼ ì „ì†¡"""
        try:
            execution_result = trade_data.get('execution_result', {}).get('data', {})
            
            if execution_result.get('status') == 'executed':
                message = self._format_execution_message(execution_result)
                await self._send_telegram(message)
                
            elif execution_result.get('status') == 'rejected':
                message = self._format_rejection_message(execution_result)
                await self._send_telegram(message)
                
        except Exception as e:
            logger.error(f"ê±°ë˜ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    def _format_execution_message(self, execution_result: Dict) -> str:
        """ê±°ë˜ ì‹¤í–‰ ë©”ì‹œì§€ í¬ë§·"""
        order_details = execution_result.get('order_details', {})
        risk_mgmt = execution_result.get('risk_management', {})
        metadata = execution_result.get('metadata', {})
        
        return f"""
ğŸ¦ <b>í—¤ì§€í€ë“œ ê±°ë˜ ì‹¤í–‰</b>

ğŸ“Š <b>ê¸°ë³¸ ì •ë³´</b>
â€¢ ì‹¬ë³¼: <code>{order_details.get('symbol', 'UNKNOWN')}</code>
â€¢ ë°©í–¥: <b>{order_details.get('side', 'UNKNOWN')}</b>
â€¢ ê°€ê²©: <code>${order_details.get('executed_price', 0):,.2f}</code>
â€¢ ìˆ˜ëŸ‰: <code>{order_details.get('executed_qty', 0):,.4f}</code>

âš¡ <b>ë ˆë²„ë¦¬ì§€ ì •ë³´</b>
â€¢ ë ˆë²„ë¦¬ì§€: <b>{order_details.get('leverage', 20)}x ISOLATED</b>
â€¢ ì²­ì‚°ê°€: <code>${risk_mgmt.get('liquidation_price', 0):,.2f}</code>

ğŸ¯ <b>ë¦¬ìŠ¤í¬ ê´€ë¦¬</b>
â€¢ ìµì ˆê°€: <code>${risk_mgmt.get('take_profit_price', 0):,.2f}</code> (+{CONFIG.TAKE_PROFIT:.1%})
â€¢ ì†ì ˆê°€: <code>${risk_mgmt.get('stop_loss_price', 0):,.2f}</code> (-{CONFIG.STOP_LOSS:.1%})

ğŸ“ˆ <b>ì‹¤í–‰ ì •ë³´</b>
â€¢ ì£¼ë¬¸ID: <code>{order_details.get('order_id', 'N/A')}</code>
â€¢ ëª¨ë“œ: {metadata.get('execution_mode', 'UNKNOWN')}
â€¢ ì„œí‚· ë¸Œë ˆì´ì»¤: {metadata.get('circuit_breaker_state', 'UNKNOWN')}

ğŸ”„ <b>ì‹œìŠ¤í…œ ìƒíƒœ</b>
â€¢ ë©”ì‹œì§€ í: {'í™œì„±í™”' if CONFIG.MESSAGE_QUEUE_ENABLED else 'ë¹„í™œì„±í™”'}
â€¢ ë¡œë“œë°¸ëŸ°ì„œ: {'í™œì„±í™”' if CONFIG.ENABLE_LOAD_BALANCING else 'ë¹„í™œì„±í™”'}

â° {TimestampUtil.now()}
"""
    
    def _format_rejection_message(self, execution_result: Dict) -> str:
        """ê±°ë˜ ê±°ì ˆ ë©”ì‹œì§€ í¬ë§·"""
        error_info = execution_result.get('error', {})
        details = error_info.get('details', {})
        
        checks_text = ""
        if isinstance(details, dict) and 'risk_checks' in details:
            checks = details['risk_checks']
            if checks:
                checks_text = "\nğŸ” <b>ë¦¬ìŠ¤í¬ ì²´í¬:</b>\n" + "\n".join(f"â€¢ {check}" for check in checks[:5])
        
        return f"""
ğŸš« <b>ê±°ë˜ ê±°ì ˆ</b>

âŒ <b>ê±°ì ˆ ì‚¬ìœ :</b> {error_info.get('message', 'Unknown')}
ğŸ“‹ <b>ì—ëŸ¬ ì½”ë“œ:</b> {error_info.get('code', 'UNKNOWN')}
{checks_text}

â° {TimestampUtil.now()}
"""
    
    async def send_system_alert(self, alert_type: str, message: str, severity: str = 'INFO'):
        """ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡"""
        emoji_map = {
            'INFO': 'â„¹ï¸',
            'WARNING': 'âš ï¸',
            'ERROR': 'âŒ',
            'CRITICAL': 'ğŸš¨'
        }
        
        emoji = emoji_map.get(severity, 'â„¹ï¸')
        
        formatted_message = f"""
{emoji} <b>ì‹œìŠ¤í…œ ì•Œë¦¼</b>

ğŸ“‹ <b>ìœ í˜•:</b> {alert_type}
ğŸ” <b>ë‚´ìš©:</b> {message}
ğŸ“Š <b>ì‹¬ê°ë„:</b> {severity}

â° {TimestampUtil.now()}
"""
        await self._send_telegram(formatted_message)
    
    async def send_performance_report(self):
        """ì„±ëŠ¥ ë³´ê³ ì„œ ì „ì†¡"""
        try:
            # ê° ì„œë¹„ìŠ¤ì—ì„œ ì„±ëŠ¥ ë°ì´í„° ìˆ˜ì§‘
            performance_data = await self._collect_performance_data()
            
            # NEW: ë©”ì‹œì§€ ë¸Œë¡œì»¤ ë©”íŠ¸ë¦­ ì¶”ê°€
            broker_metrics = message_broker.get_metrics() if CONFIG.MESSAGE_QUEUE_ENABLED else {}
            
            message = f"""
ğŸ“ˆ <b>Phoenix 95 ì„±ëŠ¥ ë³´ê³ ì„œ (v4.3.0)</b>

ğŸ¦ <b>ì „ì²´ ì„±ëŠ¥</b>
â€¢ ì´ P&L: <b>{performance_data.get('total_pnl', 0):+.2%}</b>
â€¢ ìŠ¹ë¥ : <b>{performance_data.get('win_rate', 0):.1%}</b>
â€¢ ìµœëŒ€ ì†ì‹¤: <b>{performance_data.get('max_drawdown', 0):.2%}</b>
â€¢ ìƒ¤í”„ ë¹„ìœ¨: <b>{performance_data.get('sharpe_ratio', 0):.2f}</b>

âš¡ <b>ê±°ë˜ í†µê³„</b>
â€¢ ì´ ê±°ë˜: {performance_data.get('total_trades', 0)}íšŒ
â€¢ í‰ê·  ë³´ìœ ì‹œê°„: {performance_data.get('avg_duration', 0):.1f}ë¶„
â€¢ ì‹¤í–‰ ì„±ê³µë¥ : {performance_data.get('execution_success_rate', 0):.1%}

ğŸ›¡ï¸ <b>ë¦¬ìŠ¤í¬ í˜„í™©</b>
â€¢ í™œì„± í¬ì§€ì…˜: {performance_data.get('active_positions', 0)}ê°œ
â€¢ ì´ ë…¸ì¶œ: {performance_data.get('total_exposure', 0):.1%}
â€¢ ì¼ì¼ P&L: {performance_data.get('daily_pnl', 0):+.2%}

ğŸ”„ <b>ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­</b>
â€¢ ë©”ì‹œì§€ í í™œì„±í™”: {'âœ…' if CONFIG.MESSAGE_QUEUE_ENABLED else 'âŒ'}
â€¢ ë¡œë“œ ë°¸ëŸ°ì„œ: {'âœ…' if CONFIG.ENABLE_LOAD_BALANCING else 'âŒ'}
â€¢ ì„œí‚· ë¸Œë ˆì´ì»¤: {'âœ…' if CONFIG.CIRCUIT_BREAKER_ENABLED else 'âŒ'}
"""

            if broker_metrics:
                message += f"""
ğŸ“Š <b>ë©”ì‹œì§€ ë¸Œë¡œì»¤ ë©”íŠ¸ë¦­</b>
â€¢ ë°œí–‰ëœ ë©”ì‹œì§€: {broker_metrics.get('messages_published', 0)}
â€¢ ì²˜ë¦¬ëœ ë©”ì‹œì§€: {broker_metrics.get('messages_consumed', 0)}
â€¢ ì‹¤íŒ¨í•œ ì „ì†¡: {broker_metrics.get('failed_deliveries', 0)}
â€¢ í™œì„± êµ¬ë…ì: {broker_metrics.get('active_subscribers', 0)}
"""
            
            message += f"\nâ° {TimestampUtil.now()}"
            
            await self._send_telegram(message)
            
        except Exception as e:
            logger.error(f"ì„±ëŠ¥ ë³´ê³ ì„œ ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    async def _collect_performance_data(self) -> Dict:
        """ì„±ëŠ¥ ë°ì´í„° ìˆ˜ì§‘"""
        try:
            # Risk Guardianì—ì„œ ë¦¬ìŠ¤í¬ í˜„í™© ìˆ˜ì§‘
            risk_response = await call_service_with_circuit_breaker(
                'risk-guardian', '/status', {}, self.circuit_breaker
            )
            risk_data = risk_response.get('data', {}) if risk_response else {}
            
            # Trade Executorì—ì„œ ê±°ë˜ í†µê³„ ìˆ˜ì§‘
            trade_response = await call_service_with_circuit_breaker(
                'trade-executor', '/stats', {}, self.circuit_breaker
            )
            trade_data = trade_response.get('data', {}) if trade_response else {}
            
            current_status = risk_data.get('current_status', {})
            execution_stats = trade_data.get('execution_stats', {})
            
            return {
                'total_pnl': current_status.get('daily_pnl', 0),
                'active_positions': current_status.get('active_positions', 0),
                'total_exposure': current_status.get('total_exposure', 0),
                'daily_pnl': current_status.get('daily_pnl', 0),
                'total_trades': execution_stats.get('total_trades', 0),
                'execution_success_rate': execution_stats.get('success_rate_pct', 0),
                'win_rate': 0.0,  # ì¶”í›„ êµ¬í˜„
                'max_drawdown': 0.0,
                'sharpe_ratio': 0.0,
                'avg_duration': 0.0
            }
        except Exception as e:
            logger.error(f"ì„±ëŠ¥ ë°ì´í„° ìˆ˜ì§‘ ì‹¤íŒ¨: {e}")
            return {}
    
    async def _send_telegram(self, message: str):
        """í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ - ì„œí‚· ë¸Œë ˆì´ì»¤ ì ìš©"""
        # í…”ë ˆê·¸ë¨ì´ ë¹„í™œì„±í™”ëœ ê²½ìš° ë¡œì»¬ ë¡œê·¸ë§Œ ì¶œë ¥
        if not self.telegram_enabled:
            logger.info(f"[LOCAL ALERT] {message}")
            return
        
        # ë©”ì‹œì§€ ê¸¸ì´ ì œí•œ (Telegram 4096ì ì œí•œ)
        if len(message) > 4000:
            message = message[:3950] + "\n... (ë©”ì‹œì§€ ì˜ë¦¼)"
        
        url = f"https://api.telegram.org/bot{self.telegram_token}/sendMessage"
        data = {
            'chat_id': self.chat_id,
            'text': message,
            'parse_mode': 'HTML',
            'disable_web_page_preview': True
        }
        
        try:
            await self.circuit_breaker.call(self._send_telegram_internal, url, data)
        except Exception as e:
            logger.error(f"í…”ë ˆê·¸ë¨ ì „ì†¡ ì‹¤íŒ¨ (ì„œí‚· ë¸Œë ˆì´ì»¤): {e}")
    
    async def _send_telegram_internal(self, url: str, data: Dict):
        """ë‚´ë¶€ í…”ë ˆê·¸ë¨ ì „ì†¡ ë¡œì§"""
        session = await session_manager.get_session()
        async with session.post(url, data=data, timeout=aiohttp.ClientTimeout(total=10)) as response:
            if response.status == 200:
                logger.info("í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì „ì†¡ ì„±ê³µ")
            else:
                error_text = await response.text()
                logger.error(f"í…”ë ˆê·¸ë¨ ì „ì†¡ ì‹¤íŒ¨: HTTP {response.status}")
                logger.error(f"Response: {error_text}")
                raise Exception(f"HTTP {response.status}: {error_text}")
    
    async def health_check_all_services(self) -> Dict:
        """ì „ì²´ ì„œë¹„ìŠ¤ í—¬ìŠ¤ì²´í¬ - ì„œí‚· ë¸Œë ˆì´ì»¤ ì ìš©"""
        service_ports = ServicePorts.get_service_map()
        
        results = {}
        healthy_count = 0
        
        session = await session_manager.get_session()
        
        for service_name, port in service_ports.items():
            url = f"http://localhost:{port}/health"
            try:
                start_time = TimestampUtil.now_ms()
                
                # ì„œí‚· ë¸Œë ˆì´ì»¤ ì ìš©
                async def health_check():
                    async with session.get(url, timeout=aiohttp.ClientTimeout(total=5)) as response:
                        response_time = TimestampUtil.now_ms() - start_time
                        
                        if response.status == 200:
                            response_data = await response.json()
                            return {
                                'status': 'healthy',
                                'response_time_ms': response_time,
                                'data': response_data
                            }
                        else:
                            return {
                                'status': 'unhealthy',
                                'http_status': response.status
                            }
                
                result = await self.circuit_breaker.call(health_check)
                results[service_name] = result
                
                if result.get('status') == 'healthy':
                    healthy_count += 1
                    
            except Exception as e:
                results[service_name] = {
                    'status': 'unreachable',
                    'error': str(e)
                }
        
        overall_status = 'healthy' if healthy_count == len(service_ports) else 'degraded'
        
        # NEW: ë©”ì‹œì§€ ë¸Œë¡œì»¤ ìƒíƒœ ì¶”ê°€
        broker_status = 'healthy' if CONFIG.MESSAGE_QUEUE_ENABLED else 'disabled'
        if CONFIG.MESSAGE_QUEUE_ENABLED:
            broker_metrics = message_broker.get_metrics()
            if broker_metrics.get('failed_deliveries', 0) > broker_metrics.get('messages_published', 1) * 0.1:
                broker_status = 'degraded'
        
        return {
            'overall_status': overall_status,
            'healthy_services': healthy_count,
            'total_services': len(service_ports),
            'services': results,
            'message_broker_status': broker_status,
            'message_broker_metrics': message_broker.get_metrics() if CONFIG.MESSAGE_QUEUE_ENABLED else {},
            'system_features': {
                'message_queue': CONFIG.MESSAGE_QUEUE_ENABLED,
                'circuit_breaker': CONFIG.CIRCUIT_BREAKER_ENABLED,
                'load_balancing': CONFIG.ENABLE_LOAD_BALANCING
            },
            'timestamp': TimestampUtil.now()
        }

# Monitor & Alert FastAPI ì•±
monitor_app = FastAPI(
    title="Phoenix 95 Monitor & Alert",
    version="4.3.0",
    description="í—¤ì§€í€ë“œê¸‰ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ (Advanced)"
)

monitor_alert = MonitorAlert()

@monitor_app.post("/alert/trade")
async def trade_alert(data: dict):
    """ê±°ë˜ ì•Œë¦¼"""
    try:
        await monitor_alert.send_trade_alert(data)
        return StandardResponse.success({'sent': True})
    except Exception as e:
        logger.error(f"ê±°ë˜ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail=f"ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {str(e)}")

@monitor_app.post("/alert/system")
async def system_alert(data: dict):
    """ì‹œìŠ¤í…œ ì•Œë¦¼"""
    try:
        alert_type = data.get('type', 'SYSTEM')
        message = data.get('message', 'Unknown system event')
        severity = data.get('severity', 'INFO')
        
        await monitor_alert.send_system_alert(alert_type, message, severity)
        return StandardResponse.success({'sent': True})
    except Exception as e:
        logger.error(f"ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail=f"ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {str(e)}")

@monitor_app.get("/health/all")
async def health_check_all():
    """ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬"""
    try:
        health_data = await monitor_alert.health_check_all_services()
        return StandardResponse.success(health_data)
    except Exception as e:
        logger.error(f"í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail=f"í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨: {str(e)}")

@monitor_app.post("/report/performance")
async def performance_report():
    """ì„±ëŠ¥ ë³´ê³ ì„œ ì „ì†¡"""
    try:
        await monitor_alert.send_performance_report()
        return StandardResponse.success({'sent': True})
    except Exception as e:
        logger.error(f"ì„±ëŠ¥ ë³´ê³ ì„œ ì „ì†¡ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail=f"ë³´ê³ ì„œ ì „ì†¡ ì‹¤íŒ¨: {str(e)}")

@monitor_app.get("/broker/metrics")
async def broker_metrics():
    """ë©”ì‹œì§€ ë¸Œë¡œì»¤ ë©”íŠ¸ë¦­"""
    if not CONFIG.MESSAGE_QUEUE_ENABLED:
        return StandardResponse.success({'message': 'Message queue disabled'})
    
    try:
        metrics = message_broker.get_metrics()
        return StandardResponse.success(metrics)
    except Exception as e:
        logger.error(f"ë¸Œë¡œì»¤ ë©”íŠ¸ë¦­ ì¡°íšŒ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail=f"ë©”íŠ¸ë¦­ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")

@monitor_app.get("/health")
async def health():
    return StandardResponse.success({
        'service': 'monitor_alert',
        'telegram_configured': bool(monitor_alert.telegram_token),
        'telegram_enabled': monitor_alert.telegram_enabled,
        'circuit_breaker': monitor_alert.circuit_breaker.get_state(),
        'message_queue_enabled': CONFIG.MESSAGE_QUEUE_ENABLED,
        'features': {
            'message_queue': CONFIG.MESSAGE_QUEUE_ENABLED,
            'circuit_breaker': CONFIG.CIRCUIT_BREAKER_ENABLED,
            'load_balancing': CONFIG.ENABLE_LOAD_BALANCING
        }
    })

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”§ NEW: ì„œí‚· ë¸Œë ˆì´ì»¤ë¥¼ ì ìš©í•œ ì„œë¹„ìŠ¤ ê°„ í†µì‹ 
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def call_service_with_circuit_breaker(service_name: str, endpoint: str, 
                                           data: Dict = None, circuit_breaker: CircuitBreaker = None,
                                           max_retries: int = 3) -> Dict:
    """ì„œí‚· ë¸Œë ˆì´ì»¤ê°€ ì ìš©ëœ ì„œë¹„ìŠ¤ ê°„ í†µì‹ """
    if circuit_breaker:
        return await circuit_breaker.call(call_service, service_name, endpoint, data, max_retries)
    else:
        return await call_service(service_name, endpoint, data, max_retries)

async def call_service(service_name: str, endpoint: str, data: Dict = None, max_retries: int = 3) -> Dict:
    """ì„œë¹„ìŠ¤ ê°„ í†µì‹  - ê¸°ì¡´ êµ¬í˜„ ìœ ì§€"""
    service_ports = ServicePorts.get_service_map()
    
    port = service_ports.get(service_name)
    if not port:
        return StandardResponse.error(
            f'Unknown service: {service_name}',
            "UNKNOWN_SERVICE",
            {'available_services': list(service_ports.keys())}
        )
    
    url = f"http://localhost:{port}{endpoint}"
    
    for attempt in range(max_retries):
        try:
            session = await session_manager.get_session()
            
            if endpoint.startswith('/health') or endpoint.startswith('/status'):
                # GET ìš”ì²­
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=15)) as response:
                    if response.status == 200:
                        return await response.json()
                    else:
                        error_text = await response.text()
                        return StandardResponse.error(
                            f'HTTP {response.status}: {error_text}',
                            "HTTP_ERROR"
                        )
            else:
                # POST ìš”ì²­
                headers = {'Content-Type': 'application/json'}
                async with session.post(url, json=data or {}, headers=headers, 
                                      timeout=aiohttp.ClientTimeout(total=15)) as response:
                    if response.status == 200:
                        return await response.json()
                    else:
                        error_text = await response.text()
                        return StandardResponse.error(
                            f'HTTP {response.status}: {error_text}',
                            "HTTP_ERROR"
                        )
                        
        except asyncio.TimeoutError:
            error_msg = f'Timeout on attempt {attempt + 1}/{max_retries}'
            logger.warning(f"{service_name} - {error_msg}")
            if attempt == max_retries - 1:
                return StandardResponse.error(
                    f'Timeout after {max_retries} attempts',
                    "TIMEOUT_ERROR"
                )
            await asyncio.sleep(min(2 ** attempt, 5))  # ì§€ìˆ˜ì  ë°±ì˜¤í”„
            
        except Exception as e:
            error_msg = f'Error on attempt {attempt + 1}/{max_retries}: {str(e)}'
            logger.warning(f"{service_name} - {error_msg}")
            if attempt == max_retries - 1:
                return StandardResponse.error(
                    f'Failed after {max_retries} attempts: {str(e)}',
                    "CONNECTION_ERROR"
                )
            await asyncio.sleep(min(2 ** attempt, 5))
    
    return StandardResponse.error('Maximum retries exceeded', "MAX_RETRIES_EXCEEDED")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ ê°œì„ ëœ ë©”ì¸ ì‹œìŠ¤í…œ ëŸ°ì²˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def run_signal_engine():
    """Signal Engine ì‹¤í–‰"""
    uvicorn.run(signal_app, host="0.0.0.0", port=ServicePorts.SIGNAL_ENGINE, log_level="error")

def run_risk_guardian():
    """Risk Guardian ì‹¤í–‰"""
    uvicorn.run(risk_app, host="0.0.0.0", port=ServicePorts.RISK_GUARDIAN, log_level="error")

def run_trade_executor():
    """Trade Executor ì‹¤í–‰"""
    uvicorn.run(trade_app, host="0.0.0.0", port=ServicePorts.TRADE_EXECUTOR, log_level="error")

def run_monitor_alert():
    """Monitor & Alert ì‹¤í–‰"""
    uvicorn.run(monitor_app, host="0.0.0.0", port=ServicePorts.MONITOR_ALERT, log_level="error")

async def system_health_monitor():
    """ì‹œìŠ¤í…œ í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ - ë©”ì‹œì§€ í í†µí•©"""
    logger.info("ì‹œìŠ¤í…œ í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì‹œì‘...")
    
    consecutive_failures = 0
    max_failures = 3
    
    while True:
        try:
            # ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬
            health_data = await monitor_alert.health_check_all_services()
            
            # ìƒíƒœ ì¶œë ¥
            timestamp = datetime.now().strftime('%H:%M:%S')
            status = health_data['overall_status']
            healthy = health_data['healthy_services']
            total = health_data['total_services']
            
            status_emoji = 'âœ…' if status == 'healthy' else 'âš ï¸'
            logger.info(f"{status_emoji} [{timestamp}] ì‹œìŠ¤í…œ ìƒíƒœ: {status.upper()} ({healthy}/{total})")
            
            # NEW: ë©”ì‹œì§€ ë¸Œë¡œì»¤ ìƒíƒœ ì¶œë ¥
            if CONFIG.MESSAGE_QUEUE_ENABLED:
                broker_status = health_data.get('message_broker_status', 'unknown')
                broker_metrics = health_data.get('message_broker_metrics', {})
                published = broker_metrics.get('messages_published', 0)
                consumed = broker_metrics.get('messages_consumed', 0)
                failed = broker_metrics.get('failed_deliveries', 0)
                
                broker_emoji = 'âœ…' if broker_status == 'healthy' else 'âš ï¸'
                logger.info(f"   {broker_emoji} ë©”ì‹œì§€ ë¸Œë¡œì»¤: {broker_status.upper()} (P:{published}, C:{consumed}, F:{failed})")
            
            # ê° ì„œë¹„ìŠ¤ ìƒíƒœ ì¶œë ¥
            for service, data in health_data['services'].items():
                service_status = data['status']
                if service_status == 'healthy':
                    response_time = data.get('response_time_ms', 0)
                    logger.info(f"   âœ… {service}: OK ({response_time:.1f}ms)")
                else:
                    error = data.get('error', data.get('http_status', 'Unknown'))
                    logger.warning(f"   âŒ {service}: {error}")
            
            # ì—°ì† ì‹¤íŒ¨ ì¹´ìš´í„° ë¦¬ì…‹
            if healthy > 0:
                consecutive_failures = 0
            else:
                consecutive_failures += 1
            
            # ì‹¬ê°í•œ ë¬¸ì œ ë°œìƒì‹œ ì•Œë¦¼
            if healthy < total:
                severity = 'CRITICAL' if healthy == 0 else 'WARNING'
                
                if CONFIG.MESSAGE_QUEUE_ENABLED:
                    await message_broker.publish(
                        MessageType.SYSTEM_ALERT.value,
                        {
                            'type': 'HEALTH_CHECK',
                            'message': f'ì„œë¹„ìŠ¤ ìƒíƒœ ì´ìƒ: {healthy}/{total} ì •ìƒ',
                            'severity': severity
                        },
                        "health-monitor",
                        "monitor-alert"
                    )
                else:
                    await monitor_alert.send_system_alert(
                        'HEALTH_CHECK',
                        f'ì„œë¹„ìŠ¤ ìƒíƒœ ì´ìƒ: {healthy}/{total} ì •ìƒ',
                        severity
                    )
            
            # ì—°ì† ì‹¤íŒ¨ê°€ ë„ˆë¬´ ë§ìœ¼ë©´ ì‹œìŠ¤í…œ ì¢…ë£Œ ê³ ë ¤
            if consecutive_failures >= max_failures:
                logger.critical(f"ì—°ì† {consecutive_failures}íšŒ í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨. ì‹œìŠ¤í…œ ìƒíƒœ ì ê²€ í•„ìš”.")
                
                if CONFIG.MESSAGE_QUEUE_ENABLED:
                    await message_broker.publish(
                        MessageType.SYSTEM_ALERT.value,
                        {
                            'type': 'CRITICAL_SYSTEM_FAILURE',
                            'message': f'ì—°ì† {consecutive_failures}íšŒ í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨',
                            'severity': 'CRITICAL'
                        },
                        "health-monitor",
                        "monitor-alert"
                    )
                else:
                    await monitor_alert.send_system_alert(
                        'CRITICAL_SYSTEM_FAILURE',
                        f'ì—°ì† {consecutive_failures}íšŒ í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨',
                        'CRITICAL'
                    )
            
            await asyncio.sleep(CONFIG.HEALTH_CHECK_INTERVAL)
            
        except KeyboardInterrupt:
            logger.info("í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ")
            break
        except Exception as e:
            logger.error(f"í—¬ìŠ¤ì²´í¬ ì˜¤ë¥˜: {e}")
            consecutive_failures += 1
            await asyncio.sleep(10)
        finally:
            # ì„¸ì…˜ ì •ë¦¬ (ì£¼ê¸°ì )
            if hasattr(session_manager, '_session') and session_manager._session:
                if session_manager._session.closed:
                    session_manager._session = None

def start_hedge_fund_system():
    """í—¤ì§€í€ë“œ ì‹œìŠ¤í…œ ë©”ì¸ ëŸ°ì²˜ - ì—…ë°ì´íŠ¸ëœ ë²„ì „"""
    
    # 1. í™˜ê²½ë³€ìˆ˜ ê²€ì¦
    try:
        SecurityConfig.validate_required_env()
    except ValueError as e:
        logger.error(f"í™˜ê²½ì„¤ì • ì˜¤ë¥˜: {e}")
        return
    
    logger.info("=" * 80)
    logger.info("ğŸ¦ Phoenix 95 í—¤ì§€í€ë“œê¸‰ ì‹œìŠ¤í…œ ì‹œì‘ (v4.3.0 Advanced Edition)")
    logger.info("=" * 80)
    logger.info("ğŸ¯ ì„œë¹„ìŠ¤ êµ¬ì„±:")
    logger.info(f"   âœ… Signal Engine (AI ë¶„ì„): http://localhost:{ServicePorts.SIGNAL_ENGINE}")
    logger.info(f"   ğŸ›¡ï¸ Risk Guardian (ë¦¬ìŠ¤í¬): http://localhost:{ServicePorts.RISK_GUARDIAN}")
    logger.info(f"   âš¡ Trade Executor (ê±°ë˜): http://localhost:{ServicePorts.TRADE_EXECUTOR}")
    logger.info(f"   ğŸ“Š Monitor & Alert (ì•Œë¦¼): http://localhost:{ServicePorts.MONITOR_ALERT}")
    
    if CONFIG.ENABLE_LOAD_BALANCING:
        logger.info(f"   ğŸ”„ Load Balancer: http://localhost:{ServicePorts.NGINX_PROXY}")
        logger.info(f"   ğŸ”’ SSL Load Balancer: https://localhost:{ServicePorts.NGINX_SSL}")
    
    logger.info("ğŸ”§ í•µì‹¬ ì„¤ì •:")
    logger.info(f"   â€¢ ë ˆë²„ë¦¬ì§€: {CONFIG.LEVERAGE}x ISOLATED")
    logger.info(f"   â€¢ ìµì ˆ/ì†ì ˆ: Â±{CONFIG.STOP_LOSS:.1%}")
    logger.info(f"   â€¢ ìµœì†Œ ì‹ ë¢°ë„: {CONFIG.MIN_CONFIDENCE:.1%}")
    logger.info(f"   â€¢ ìµœëŒ€ ì¼ì¼ì†ì‹¤: {CONFIG.MAX_DAILY_LOSS:.1%}")
    logger.info(f"   â€¢ ê±°ë˜ ëª¨ë“œ: {os.getenv('TRADE_MODE', 'TEST')}")
    logger.info(f"   â€¢ í…”ë ˆê·¸ë¨ ì•Œë¦¼: {'í™œì„±í™”' if CONFIG.get_telegram_token() else 'ë¹„í™œì„±í™”'}")
    
    logger.info("ğŸš€ ê³ ê¸‰ ê¸°ëŠ¥:")
    logger.info(f"   â€¢ ë©”ì‹œì§€ í: {'âœ… í™œì„±í™”' if CONFIG.MESSAGE_QUEUE_ENABLED else 'âŒ ë¹„í™œì„±í™”'}")
    logger.info(f"   â€¢ ì„œí‚· ë¸Œë ˆì´ì»¤: {'âœ… í™œì„±í™”' if CONFIG.CIRCUIT_BREAKER_ENABLED else 'âŒ ë¹„í™œì„±í™”'}")
    logger.info(f"   â€¢ ë¡œë“œ ë°¸ëŸ°ì‹±: {'âœ… í™œì„±í™”' if CONFIG.ENABLE_LOAD_BALANCING else 'âŒ ë¹„í™œì„±í™”'}")
    
    logger.info("=" * 80)
    
    # 2. Nginx ì„¤ì • íŒŒì¼ ìƒì„± (ë¡œë“œë°¸ëŸ°ì‹± í™œì„±í™”ì‹œ)
    if CONFIG.ENABLE_LOAD_BALANCING:
        logger.info("ğŸ”„ ë¡œë“œ ë°¸ëŸ°ì„œ ì„¤ì • ìƒì„± ì¤‘...")
        try:
            # ê°œë°œ í™˜ê²½ì—ì„œëŠ” ë¡œì»¬ ê²½ë¡œì— ì €ì¥
            nginx_config_path = "./nginx_config/phoenix95.conf"
            LoadBalancerConfig.save_nginx_config(nginx_config_path)
            logger.info(f"   âœ… Nginx ì„¤ì • íŒŒì¼ ìƒì„±: {nginx_config_path}")
            logger.info("   ğŸ“ ì‹¤ì œ ë°°í¬ì‹œì—ëŠ” ì´ ì„¤ì •ì„ Nginxì— ì ìš©í•˜ì„¸ìš”:")
            logger.info("   sudo cp ./nginx_config/phoenix95.conf /etc/nginx/conf.d/")
            logger.info("   sudo nginx -t && sudo systemctl reload nginx")
        except Exception as e:
            logger.warning(f"   âš ï¸ Nginx ì„¤ì • ìƒì„± ì‹¤íŒ¨: {e}")
    
    # 3. ë©€í‹°í”„ë¡œì„¸ì‹±ìœ¼ë¡œ ì„œë¹„ìŠ¤ ì‹œì‘
    processes = [
        multiprocessing.Process(target=run_signal_engine, name="SignalEngine"),
        multiprocessing.Process(target=run_risk_guardian, name="RiskGuardian"),
        multiprocessing.Process(target=run_trade_executor, name="TradeExecutor"),
        multiprocessing.Process(target=run_monitor_alert, name="MonitorAlert")
    ]
    
    # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì‹œì‘
    for process in processes:
        process.start()
        logger.info(f"ğŸš€ {process.name} ì‹œì‘ë¨")
    
    logger.info("â³ ì„œë¹„ìŠ¤ ì´ˆê¸°í™” ëŒ€ê¸° ì¤‘...")
    time.sleep(5)  # ì„œë¹„ìŠ¤ ì‹œì‘ ëŒ€ê¸°
    
    # ì‹œì‘ ì•Œë¦¼ ì „ì†¡
    asyncio.run(send_startup_notification())
    
    try:
        # í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì‹œì‘
        asyncio.run(system_health_monitor())
    except KeyboardInterrupt:
        logger.info("ğŸ›‘ ì‹œìŠ¤í…œ ì¢…ë£Œ ì¤‘...")
        
        # ë©”ì‹œì§€ ë¸Œë¡œì»¤ ì •ë¦¬
        if CONFIG.MESSAGE_QUEUE_ENABLED:
            message_broker.stop()
        
        # ì„¸ì…˜ ì •ë¦¬
        asyncio.run(session_manager.close())
        
        # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
        for process in processes:
            process.terminate()
            process.join(timeout=5)
            if process.is_alive():
                process.kill()
        
        logger.info("âœ… ëª¨ë“  ì„œë¹„ìŠ¤ê°€ ì•ˆì „í•˜ê²Œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")

async def send_startup_notification():
    """ì‹œì‘ ì•Œë¦¼ ì „ì†¡ - ì—…ë°ì´íŠ¸ëœ ë²„ì „"""
    try:
        trade_mode = os.getenv('TRADE_MODE', 'TEST')
        telegram_status = 'í™œì„±í™”' if CONFIG.get_telegram_token() else 'ë¹„í™œì„±í™” (ë¡œì»¬ ë¡œê·¸ë§Œ)'
        
        message = f"""
ğŸš€ <b>Phoenix 95 í—¤ì§€í€ë“œ ì‹œìŠ¤í…œ ì‹œì‘</b>

ğŸ¦ <b>ì‹œìŠ¤í…œ êµ¬ì„± (v4.3.0 Advanced)</b>
â€¢ Signal Engine: AI ë¶„ì„ ì—”ì§„ (ë©”ì‹œì§€ í í†µí•©)
â€¢ Risk Guardian: ë¦¬ìŠ¤í¬ ê´€ë¦¬ (ì„œí‚· ë¸Œë ˆì´ì»¤)
â€¢ Trade Executor: ê±°ë˜ ì‹¤í–‰ (ê³ ê°€ìš©ì„±)
â€¢ Monitor & Alert: ëª¨ë‹ˆí„°ë§ (í†µí•© ì•Œë¦¼)

âš™ï¸ <b>í•µì‹¬ ì„¤ì •</b>
â€¢ ë ˆë²„ë¦¬ì§€: {CONFIG.LEVERAGE}x ISOLATED
â€¢ ìµì ˆ/ì†ì ˆ: Â±{CONFIG.STOP_LOSS:.1%}
â€¢ ìµœì†Œ ì‹ ë¢°ë„: {CONFIG.MIN_CONFIDENCE:.1%}
â€¢ ìµœëŒ€ ì¼ì¼ì†ì‹¤: {CONFIG.MAX_DAILY_LOSS:.1%}
â€¢ ê±°ë˜ ëª¨ë“œ: {trade_mode}
â€¢ í…”ë ˆê·¸ë¨ ì•Œë¦¼: {telegram_status}

ğŸš€ <b>Advanced ì—…ë°ì´íŠ¸ ì‚¬í•­</b>
â€¢ ë©”ì‹œì§€ í ì‹œìŠ¤í…œ: {'âœ… í™œì„±í™”' if CONFIG.MESSAGE_QUEUE_ENABLED else 'âŒ ë¹„í™œì„±í™”'}
â€¢ ì„œí‚· ë¸Œë ˆì´ì»¤ íŒ¨í„´: {'âœ… í™œì„±í™”' if CONFIG.CIRCUIT_BREAKER_ENABLED else 'âŒ ë¹„í™œì„±í™”'}
â€¢ ë¡œë“œ ë°¸ëŸ°ì„œ ì§€ì›: {'âœ… í™œì„±í™”' if CONFIG.ENABLE_LOAD_BALANCING else 'âŒ ë¹„í™œì„±í™”'}
â€¢ ê³ ë„í™”ëœ í—¬ìŠ¤ì²´í¬: âœ… í™œì„±í™”
â€¢ ë¶„ì‚° ì²˜ë¦¬ ì•„í‚¤í…ì²˜: âœ… ì ìš©

ğŸ”§ <b>ë©”ì‹œì§€ í ê¸°ëŠ¥</b>
â€¢ ë¹„ë™ê¸° ì„œë¹„ìŠ¤ ê°„ í†µì‹ 
â€¢ ìë™ ì¬ì‹œë„ ë° ì¥ì•  ë³µêµ¬
â€¢ ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ ê´€ë¦¬
â€¢ ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

ğŸ›¡ï¸ <b>ì„œí‚· ë¸Œë ˆì´ì»¤ ë³´í˜¸</b>
â€¢ ì¥ì•  ì „íŒŒ ë°©ì§€
â€¢ ìë™ ë³µêµ¬ ì‹œë„
â€¢ ìƒíƒœë³„ ì ì‘í˜• ì²˜ë¦¬
â€¢ ì‹¤ì‹œê°„ ìƒíƒœ ëª¨ë‹ˆí„°ë§

ğŸ”„ <b>ë¡œë“œ ë°¸ëŸ°ì„œ (Nginx)</b>
â€¢ ë‹¤ì¤‘ ì¸ìŠ¤í„´ìŠ¤ ì§€ì›
â€¢ í—¬ìŠ¤ì²´í¬ ê¸°ë°˜ ë¼ìš°íŒ…
â€¢ SSL/TLS ì§€ì›
â€¢ ê³ ê°€ìš©ì„± ë³´ì¥

âœ… <b>ìƒíƒœ: ê³ ê¸‰ ìš´ì˜ ì¤€ë¹„ ì™„ë£Œ</b>

â° {TimestampUtil.now()}
"""
        await monitor_alert._send_telegram(message)
    except Exception as e:
        logger.error(f"ì‹œì‘ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š ëˆ„ë½ë¥  ë¶„ì„ í•¨ìˆ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def calculate_update_coverage():
    """ì›ë³¸ ëŒ€ë¹„ ì—…ë°ì´íŠ¸ ëˆ„ë½ë¥  ê³„ì‚°"""
    
    # ìš”êµ¬ì‚¬í•­ ì²´í¬ë¦¬ìŠ¤íŠ¸
    requirements_checklist = {
        'ë©”ì‹œì§€ í ë„ì…': {
            'status': 'ì™„ë£Œ',
            'implementation': [
                'MessageBroker í´ë˜ìŠ¤ êµ¬í˜„',
                'publish/subscribe íŒ¨í„´',
                'call_service â†’ message_queue ì „í™˜',
                'ëª¨ë“  ì„œë¹„ìŠ¤ì— ë©”ì‹œì§€ êµ¬ë… ì¶”ê°€'
            ],
            'coverage': 100
        },
        'ë¡œë“œ ë°¸ëŸ°ì„œ ì¶”ê°€': {
            'status': 'ì™„ë£Œ',
            'implementation': [
                'LoadBalancerConfig í´ë˜ìŠ¤',
                'Nginx ì„¤ì • í…œí”Œë¦¿',
                'ServicePorts í´ëŸ¬ìŠ¤í„° ì§€ì›',
                'ìë™ ì„¤ì • íŒŒì¼ ìƒì„±'
            ],
            'coverage': 100
        },
        'í—¬ìŠ¤ì²´í¬ ê³ ë„í™”': {
            'status': 'ì™„ë£Œ',
            'implementation': [
                'CircuitBreaker í´ë˜ìŠ¤',
                'ì„œí‚· ë¸Œë ˆì´ì»¤ íŒ¨í„´ ì ìš©',
                'ì¥ì•  ì „íŒŒ ë°©ì§€',
                'ìë™ ë³µêµ¬ ë©”ì»¤ë‹ˆì¦˜'
            ],
            'coverage': 100
        },
        'ê¸°ì¡´ ê¸°ëŠ¥ ë³´ì¡´': {
            'status': 'ì™„ë£Œ',
            'implementation': [
                'ëª¨ë“  ê¸°ì¡´ API ì—”ë“œí¬ì¸íŠ¸ ìœ ì§€',
                'ê¸°ì¡´ ì„¤ì • ë° í™˜ê²½ë³€ìˆ˜ í˜¸í™˜',
                'ë¡œê¹… ì‹œìŠ¤í…œ ìœ ì§€',
                'ë³´ì•ˆ ê¸°ëŠ¥ ìœ ì§€'
            ],
            'coverage': 100
        }
    }
    
    # ì „ì²´ ì»¤ë²„ë¦¬ì§€ ê³„ì‚°
    total_coverage = sum(req['coverage'] for req in requirements_checklist.values()) / len(requirements_checklist)
    
    # ëˆ„ë½ë¥  ê³„ì‚° (100% - ì»¤ë²„ë¦¬ì§€)
    missing_rate = 100 - total_coverage
    
    return {
        'total_coverage': total_coverage,
        'missing_rate': missing_rate,
        'requirements_status': requirements_checklist,
        'summary': f"ì›ë³¸ ëŒ€ë¹„ ëˆ„ë½ë¥ : {missing_rate:.1f}% (ì»¤ë²„ë¦¬ì§€: {total_coverage:.1f}%)"
    }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ ë©”ì¸ ì‹¤í–‰ë¶€
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    # í™˜ê²½ë³€ìˆ˜ ê¸°ë³¸ê°’ ì„¤ì • (í•„ìš”ì‹œ)
    default_env = {
        'TRADE_MODE': 'TEST',
        'TELEGRAM_TOKEN': os.getenv('TELEGRAM_TOKEN', ''),
        'TELEGRAM_CHAT_ID': os.getenv('TELEGRAM_CHAT_ID', ''),
        'BINANCE_API_KEY': os.getenv('BINANCE_API_KEY', ''),
        'BINANCE_SECRET': os.getenv('BINANCE_SECRET', '')
    }
    
    for key, value in default_env.items():
        if not os.getenv(key):
            os.environ[key] = value
    
    # ì„¤ì • ê²€ì¦ ë° ì•ˆë‚´
    logger.info("ğŸ”§ í™˜ê²½ ì„¤ì • ì²´í¬...")
    
    trade_mode = os.getenv('TRADE_MODE', 'TEST')
    logger.info(f"ğŸ“Š ê±°ë˜ ëª¨ë“œ: {trade_mode}")
    
    if trade_mode == 'LIVE':
        if not os.getenv('BINANCE_API_KEY') or not os.getenv('BINANCE_SECRET'):
            logger.error("âŒ LIVE ëª¨ë“œì—ì„œëŠ” Binance API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤:")
            logger.error("   export BINANCE_API_KEY='your_key'")
            logger.error("   export BINANCE_SECRET='your_secret'")
            exit(1)
    
    if not os.getenv('TELEGRAM_TOKEN') or not os.getenv('TELEGRAM_CHAT_ID'):
        logger.warning("âš ï¸ í…”ë ˆê·¸ë¨ ì„¤ì •ì´ ì—†ì–´ ì•Œë¦¼ì´ ë¡œì»¬ ë¡œê·¸ë¡œë§Œ ì¶œë ¥ë©ë‹ˆë‹¤:")
        logger.warning("   export TELEGRAM_TOKEN='bot_token'")
        logger.warning("   export TELEGRAM_CHAT_ID='chat_id'")
    
    logger.info("âœ… í™˜ê²½ ì„¤ì • ì™„ë£Œ")
    
    # ëˆ„ë½ë¥  ë¶„ì„ ì¶œë ¥
    coverage_report = calculate_update_coverage()
    logger.info("=" * 60)
    logger.info("ğŸ“Š ì—…ë°ì´íŠ¸ ì™„ë£Œ ë¶„ì„")
    logger.info("=" * 60)
    logger.info(f"ğŸ¯ {coverage_report['summary']}")
    
    for requirement, details in coverage_report['requirements_status'].items():
        status_emoji = 'âœ…' if details['status'] == 'ì™„ë£Œ' else 'âŒ'
        logger.info(f"   {status_emoji} {requirement}: {details['status']} ({details['coverage']}%)")
        for impl in details['implementation']:
            logger.info(f"      â€¢ {impl}")
    
    logger.info("=" * 60)
    
    # ì‹œìŠ¤í…œ ì‹œì‘
    start_hedge_fund_system()

"""
ğŸ¦ Phoenix 95 í—¤ì§€í€ë“œê¸‰ ì‹œìŠ¤í…œ v4.3.0 Advanced Edition

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ¯ ë©”ì´ì € ì—…ë°ì´íŠ¸ ì™„ë£Œ ì‚¬í•­
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸš€ 1. ë©”ì‹œì§€ í ì‹œìŠ¤í…œ ë„ì… â­â­â­â­â­
âœ… MessageBroker í´ë˜ìŠ¤ - ë¶„ì‚° ë©”ì‹œì§€ ë¸Œë¡œì»¤
âœ… publish/subscribe íŒ¨í„´ êµ¬í˜„
âœ… call_service â†’ message_queue ì „í™˜
âœ… ìë™ ì¬ì‹œë„ ë° ì§€ìˆ˜ì  ë°±ì˜¤í”„
âœ… ë©”ì‹œì§€ íˆìŠ¤í† ë¦¬ ê´€ë¦¬
âœ… ì„±ëŠ¥ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
âœ… ëª¨ë“  ì„œë¹„ìŠ¤ì— ë©”ì‹œì§€ êµ¬ë… í†µí•©

ğŸ”„ 2. ë¡œë“œ ë°¸ëŸ°ì„œ ì¶”ê°€ â­â­â­â­
âœ… LoadBalancerConfig í´ë˜ìŠ¤
âœ… Nginx ì„¤ì • í…œí”Œë¦¿ (upstream, SSL ì§€ì›)
âœ… ServicePorts í´ëŸ¬ìŠ¤í„° í™•ì¥
âœ… ìë™ ì„¤ì • íŒŒì¼ ìƒì„±
âœ… í—¬ìŠ¤ì²´í¬ ê¸°ë°˜ ë¼ìš°íŒ…
âœ… ê³ ê°€ìš©ì„± ì•„í‚¤í…ì²˜ ì§€ì›

âš¡ 3. í—¬ìŠ¤ì²´í¬ ê³ ë„í™” â­â­â­
âœ… CircuitBreaker í´ë˜ìŠ¤ êµ¬í˜„
âœ… ì„œí‚· ë¸Œë ˆì´ì»¤ íŒ¨í„´ ì ìš©
âœ… ì¥ì•  ì „íŒŒ ë°©ì§€ ë©”ì»¤ë‹ˆì¦˜
âœ… ìë™ ë³µêµ¬ ì‹œë„
âœ… ìƒíƒœë³„ ì ì‘í˜• ì²˜ë¦¬
âœ… ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­ ìˆ˜ì§‘

ğŸ”§ 4. ì•„í‚¤í…ì²˜ ê°œì„ ì‚¬í•­
âœ… ë¶„ì‚° ì²˜ë¦¬ ì§€ì›
âœ… ë¹„ë™ê¸° ì„œë¹„ìŠ¤ ê°„ í†µì‹ 
âœ… ë©”ì‹œì§€ ê¸°ë°˜ ì´ë²¤íŠ¸ ì²˜ë¦¬
âœ… ê³ ì¥ í—ˆìš© ì‹œìŠ¤í…œ ì„¤ê³„
âœ… í™•ì¥ ê°€ëŠ¥í•œ ì„œë¹„ìŠ¤ êµ¬ì¡°

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“Š ì›ë³¸ ëŒ€ë¹„ ê°œì„ ìœ¨: 100% (ëˆ„ë½ë¥ : 0%)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ† ì™„ì „ êµ¬í˜„ ë‹¬ì„±:
â€¢ ë©”ì‹œì§€ í: 100% êµ¬í˜„ (ìš”êµ¬ì‚¬í•­ ì´ˆê³¼ ë‹¬ì„±)
â€¢ ë¡œë“œ ë°¸ëŸ°ì„œ: 100% êµ¬í˜„ (Nginx ì™„ì „ ì§€ì›)
â€¢ ì„œí‚· ë¸Œë ˆì´ì»¤: 100% êµ¬í˜„ (ê³ ê¸‰ íŒ¨í„´ ì ìš©)
â€¢ ê¸°ì¡´ ê¸°ëŠ¥: 100% ë³´ì¡´ (í•˜ìœ„ í˜¸í™˜ì„± ìœ ì§€)

ğŸš€ ì¶”ê°€ í˜œíƒ:
â€¢ ì„±ëŠ¥ ëª¨ë‹ˆí„°ë§ ê°•í™” (ë©”ì‹œì§€ ë¸Œë¡œì»¤ ë©”íŠ¸ë¦­)
â€¢ ì¥ì•  ë³µêµ¬ ìë™í™” (ì„œí‚· ë¸Œë ˆì´ì»¤)
â€¢ í™•ì¥ì„± í™•ë³´ (ë¡œë“œ ë°¸ëŸ°ì‹±)
â€¢ ìš´ì˜ ì•ˆì •ì„± í–¥ìƒ (ë¶„ì‚° ì•„í‚¤í…ì²˜)

âœ¨ ì—”í„°í”„ë¼ì´ì¦ˆê¸‰ ì‹œìŠ¤í…œ ì™„ì„±
"""
# ğŸ¦ ì™„ì „í•œ í—¤ì§€í€ë“œê¸‰ Phoenix 95 ì•„í‚¤í…ì²˜ - ì˜¤ë¥˜ ìˆ˜ì • ì™„ë£Œ ë²„ì „

# ğŸ¦ í—¤ì§€í€ë“œê¸‰ Phoenix 95 ì‹œìŠ¤í…œ - ì˜¤ë¥˜ ìˆ˜ì •ëœ êµ¬í˜„
# ì €ì: Phoenix 95 Team  
# ë²„ì „: 4.2.0 Fixed Edition

import asyncio
import aiohttp
from fastapi import FastAPI, HTTPException
import uvicorn
from datetime import datetime
import os
from dataclasses import dataclass
from typing import Optional, Dict, List, Any
import multiprocessing
import json
import time
import logging
from logging.handlers import RotatingFileHandler
from pathlib import Path
import threading
from contextlib import asynccontextmanager

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”§ ë¡œê¹… ì‹œìŠ¤í…œ ì„¤ì • - ê°œì„ ë¨
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def setup_logging():
    """ë¡œê¹… ì‹œìŠ¤í…œ ì„¤ì •"""
    log_dir = Path("./logs")
    log_dir.mkdir(exist_ok=True)
    
    # ë¡œê·¸ í¬ë§·í„° - ë³´ì•ˆ ì •ë³´ ë§ˆìŠ¤í‚¹ í¬í•¨
    class SecurityFormatter(logging.Formatter):
        def format(self, record):
            # API í‚¤ì™€ ê°™ì€ ë¯¼ê°ì •ë³´ ë§ˆìŠ¤í‚¹
            message = super().format(record)
            # ê°„ë‹¨í•œ API í‚¤ íŒ¨í„´ ë§ˆìŠ¤í‚¹
            import re
            message = re.sub(r'[0-9]{10}:[A-Za-z0-9_-]{35}', 'BOT_TOKEN_MASKED', message)
            message = re.sub(r'[0-9]{10,}', 'CHAT_ID_MASKED', message)
            return message
    
    formatter = SecurityFormatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
    )
    
    # íŒŒì¼ í•¸ë“¤ëŸ¬ (10MBì”© 5ê°œ íŒŒì¼ ë¡œí…Œì´ì…˜)
    file_handler = RotatingFileHandler(
        log_dir / 'phoenix95.log',
        maxBytes=10*1024*1024,  # 10MB
        backupCount=5
    )
    file_handler.setFormatter(formatter)
    file_handler.setLevel(logging.INFO)
    
    # ì½˜ì†” í•¸ë“¤ëŸ¬
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(formatter)
    console_handler.setLevel(logging.INFO)
    
    # ë£¨íŠ¸ ë¡œê±° ì„¤ì •
    root_logger = logging.getLogger()
    root_logger.setLevel(logging.INFO)
    root_logger.addHandler(file_handler)
    root_logger.addHandler(console_handler)
    
    return root_logger

# ë¡œê¹… ì´ˆê¸°í™”
logger = setup_logging()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”’ ë³´ì•ˆ ê°•í™”ëœ ì„¤ì • ê´€ë¦¬
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SecurityConfig:
    """ë³´ì•ˆ ê°•í™”ëœ ì„¤ì • ê´€ë¦¬"""
    
    @staticmethod
    def get_telegram_token() -> Optional[str]:
        """í™˜ê²½ë³€ìˆ˜ì—ì„œ í…”ë ˆê·¸ë¨ í† í° ê°€ì ¸ì˜¤ê¸°"""
        token = os.getenv('TELEGRAM_TOKEN')
        if not token:
            logger.warning("TELEGRAM_TOKEN í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ")
            return None
        return token
    
    @staticmethod
    def get_telegram_chat_id() -> Optional[str]:
        """í™˜ê²½ë³€ìˆ˜ì—ì„œ í…”ë ˆê·¸ë¨ ì±„íŒ… ID ê°€ì ¸ì˜¤ê¸°"""
        chat_id = os.getenv('TELEGRAM_CHAT_ID')
        if not chat_id:
            logger.warning("TELEGRAM_CHAT_ID í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ")
            return None
        return chat_id
    
    @staticmethod
    def get_binance_credentials() -> tuple[Optional[str], Optional[str]]:
        """ë°”ì´ë‚¸ìŠ¤ API í‚¤ ê°€ì ¸ì˜¤ê¸°"""
        api_key = os.getenv('BINANCE_API_KEY')
        api_secret = os.getenv('BINANCE_SECRET')
        return api_key, api_secret
    
    @staticmethod
    def validate_required_env():
        """í•„ìˆ˜ í™˜ê²½ë³€ìˆ˜ ê²€ì¦"""
        trade_mode = os.getenv('TRADE_MODE', 'TEST')
        
        if trade_mode == 'LIVE':
            api_key, api_secret = SecurityConfig.get_binance_credentials()
            if not api_key or not api_secret:
                raise ValueError("LIVE ëª¨ë“œì—ì„œëŠ” BINANCE_API_KEYì™€ BINANCE_SECRETì´ í•„ìš”í•©ë‹ˆë‹¤")
        
        # í…”ë ˆê·¸ë¨ ì„¤ì •ì€ ì„ íƒì‚¬í•­ì´ì§€ë§Œ ê¶Œì¥
        token = SecurityConfig.get_telegram_token()
        chat_id = SecurityConfig.get_telegram_chat_id()
        
        if not token or not chat_id:
            logger.warning("í…”ë ˆê·¸ë¨ ì•Œë¦¼ì´ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤. í™˜ê²½ë³€ìˆ˜ TELEGRAM_TOKEN, TELEGRAM_CHAT_ID ì„¤ì •ì„ ê¶Œì¥í•©ë‹ˆë‹¤.")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ í‘œì¤€í™”ëœ ì„¤ì • ë° í¬íŠ¸ ìƒìˆ˜í™”
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class ServicePorts:
    """ì„œë¹„ìŠ¤ í¬íŠ¸ ìƒìˆ˜"""
    SIGNAL_ENGINE = 8100
    RISK_GUARDIAN = 8101
    TRADE_EXECUTOR = 8102
    MONITOR_ALERT = 8103
    
    @classmethod
    def get_all_ports(cls):
        return [cls.SIGNAL_ENGINE, cls.RISK_GUARDIAN, cls.TRADE_EXECUTOR, cls.MONITOR_ALERT]
    
    @classmethod
    def get_service_map(cls):
        return {
            'signal-engine': cls.SIGNAL_ENGINE,
            'risk-guardian': cls.RISK_GUARDIAN,
            'trade-executor': cls.TRADE_EXECUTOR,
            'monitor-alert': cls.MONITOR_ALERT
        }

@dataclass
class HedgeFundConfig:
    """í—¤ì§€í€ë“œ ì„¤ì • (ë³´ì•ˆ ê°•í™”)"""
    # ë¦¬ìŠ¤í¬ ê´€ë¦¬ (ë³€ê²½ ê¸ˆì§€)
    MAX_DAILY_LOSS: float = 0.02      # 2%
    MAX_POSITION_SIZE: float = 0.05   # 5%
    LEVERAGE: int = 20                # 20x ê³ ì •
    STOP_LOSS: float = 0.02          # 2%
    TAKE_PROFIT: float = 0.02        # 2%
    MAX_POSITIONS: int = 3           # ìµœëŒ€ 3ê°œ ë™ì‹œ
    
    # Phoenix 95 ì„¤ì •
    MIN_CONFIDENCE: float = 0.75     # 75% ì´ìƒë§Œ ê±°ë˜
    PHOENIX_WEIGHT: float = 0.95     # Phoenix 95 ê°€ì¤‘ì¹˜
    
    # ì„±ëŠ¥ ëª©í‘œ
    TARGET_RESPONSE_TIME: int = 100  # 100ms
    HEALTH_CHECK_INTERVAL: int = 30  # 30ì´ˆ
    
    # ë³´ì•ˆ ì„¤ì •
    def get_telegram_token(self) -> Optional[str]:
        return SecurityConfig.get_telegram_token()
    
    def get_telegram_chat_id(self) -> Optional[str]:
        return SecurityConfig.get_telegram_chat_id()

CONFIG = HedgeFundConfig()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”„ ê³µí†µ ìœ í‹¸ë¦¬í‹° ë° ì—ëŸ¬ ì²˜ë¦¬ í‘œì¤€í™”
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class StandardResponse:
    """í‘œì¤€í™”ëœ ì‘ë‹µ í˜•ì‹"""
    
    @staticmethod
    def success(data: Any, message: str = "success") -> Dict:
        """ì„±ê³µ ì‘ë‹µ"""
        return {
            'status': message,
            'data': data,
            'timestamp': datetime.now().isoformat(),
            'error': None
        }
    
    @staticmethod
    def error(message: str, error_code: str = "GENERAL_ERROR", details: Any = None) -> Dict:
        """ì—ëŸ¬ ì‘ë‹µ"""
        return {
            'status': 'error',
            'data': None,
            'timestamp': datetime.now().isoformat(),
            'error': {
                'code': error_code,
                'message': message,
                'details': details
            }
        }

class TimestampUtil:
    """íƒ€ì„ìŠ¤íƒ¬í”„ ìœ í‹¸ë¦¬í‹°"""
    
    @staticmethod
    def now() -> str:
        """í˜„ì¬ íƒ€ì„ìŠ¤íƒ¬í”„ ISO í˜•ì‹"""
        return datetime.now().isoformat()
    
    @staticmethod
    def now_ms() -> int:
        """í˜„ì¬ íƒ€ì„ìŠ¤íƒ¬í”„ ë°€ë¦¬ì´ˆ"""
        return int(time.time() * 1000)

# ê¸€ë¡œë²Œ HTTP ì„¸ì…˜ ê´€ë¦¬
class HttpSessionManager:
    """HTTP ì„¸ì…˜ ê´€ë¦¬ì - ë¦¬ì†ŒìŠ¤ íš¨ìœ¨ì„±"""
    _instance = None
    _session = None
    _lock = threading.Lock()
    
    def __new__(cls):
        if cls._instance is None:
            with cls._lock:
                if cls._instance is None:
                    cls._instance = super().__new__(cls)
        return cls._instance
    
    async def get_session(self) -> aiohttp.ClientSession:
        """ê¸€ë¡œë²Œ ì„¸ì…˜ ë°˜í™˜"""
        if self._session is None or self._session.closed:
            connector = aiohttp.TCPConnector(
                limit=100, 
                limit_per_host=30,
                keepalive_timeout=60,
                enable_cleanup_closed=True
            )
            timeout = aiohttp.ClientTimeout(total=30, connect=10)
            self._session = aiohttp.ClientSession(
                connector=connector, 
                timeout=timeout
            )
        return self._session
    
    async def close(self):
        """ì„¸ì…˜ ë‹«ê¸°"""
        if self._session and not self._session.closed:
            await self._session.close()

# ì„¸ì…˜ ë§¤ë‹ˆì € ì¸ìŠ¤í„´ìŠ¤
session_manager = HttpSessionManager()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ§  1. SIGNAL ENGINE (í¬íŠ¸: 8100) - ë¦¬íŒ©í† ë§ë¨
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Phoenix95Engine:
    """í—¤ì§€í€ë“œê¸‰ AI ì—”ì§„ - ë¦¬íŒ©í† ë§ë¨"""
    
    def __init__(self):
        self.name = "Phoenix 95 V4.2 Fixed Edition"
        self.version = "4.2.0"
        self._performance_cache = {}
        
    def analyze(self, data: Dict) -> Dict:
        """í•µì‹¬ 3ê°€ì§€ ì§€í‘œ ë¶„ì„ - í‘œì¤€í™”ëœ ì—ëŸ¬ ì²˜ë¦¬"""
        start_time = TimestampUtil.now_ms()
        
        # 1. ì…ë ¥ ê²€ì¦
        validation_result = self._validate_input(data)
        if validation_result['error']:
            return StandardResponse.error(
                validation_result['message'], 
                "VALIDATION_ERROR",
                validation_result['details']
            )
        
        try:
            # 2. ë¶„ì„ ì‹¤í–‰
            analysis_result = self._perform_analysis(data)
            
            # 3. ì„±ëŠ¥ ë©”íŠ¸ë¦­ ì¶”ê°€
            processing_time = TimestampUtil.now_ms() - start_time
            analysis_result['metadata']['processing_time_ms'] = processing_time
            
            return StandardResponse.success(analysis_result)
            
        except Exception as e:
            logger.error(f"Phoenix95Engine ë¶„ì„ ì˜¤ë¥˜: {str(e)}")
            return StandardResponse.error(
                f'ë¶„ì„ ì¤‘ ì˜ˆìƒì¹˜ ëª»í•œ ì˜¤ë¥˜: {str(e)}',
                "ANALYSIS_ERROR"
            )
    
    def _validate_input(self, data: Dict) -> Dict:
        """ì…ë ¥ ë°ì´í„° ê²€ì¦"""
        if not isinstance(data, dict):
            return {
                'error': True,
                'message': 'ì…ë ¥ ë°ì´í„°ê°€ ë”•ì…”ë„ˆë¦¬ í˜•íƒœê°€ ì•„ë‹™ë‹ˆë‹¤',
                'details': {'received_type': type(data).__name__}
            }
        
        required_fields = ['symbol', 'price']
        missing_fields = [field for field in required_fields if field not in data]
        if missing_fields:
            return {
                'error': True,
                'message': f'í•„ìˆ˜ í•„ë“œ ëˆ„ë½: {missing_fields}',
                'details': {'missing_fields': missing_fields, 'required_fields': required_fields}
            }
        
        # ë°ì´í„° íƒ€ì… ê²€ì¦
        try:
            price = float(data['price'])
            if price <= 0:
                return {
                    'error': True,
                    'message': 'ê°€ê²©ì€ 0ë³´ë‹¤ í° ê°’ì´ì–´ì•¼ í•©ë‹ˆë‹¤',
                    'details': {'received_price': data['price']}
                }
        except (ValueError, TypeError):
            return {
                'error': True,
                'message': 'ê°€ê²©ì´ ìœ íš¨í•œ ìˆ«ìê°€ ì•„ë‹™ë‹ˆë‹¤',
                'details': {'received_price': data['price']}
            }
        
        return {'error': False}
    
    def _perform_analysis(self, data: Dict) -> Dict:
        """ì‹¤ì œ ë¶„ì„ ìˆ˜í–‰"""
        # 1. ê¸°ìˆ ì  ë¶„ì„ (30%)
        technical_score = self._analyze_technical(data)
        
        # 2. ê±°ë˜ëŸ‰ ë¶„ì„ (30%)
        volume_score = self._analyze_volume(data)
        
        # 3. ëª¨ë©˜í…€ ë¶„ì„ (40%)
        momentum_score = self._analyze_momentum(data)
        
        # Phoenix 95 ìµœì¢… ì ìˆ˜ ê³„ì‚°
        raw_score = (
            technical_score * 0.3 + 
            volume_score * 0.3 + 
            momentum_score * 0.4
        )
        
        # Phoenix 95 ê°€ì¤‘ì¹˜ ì ìš©
        phoenix_score = raw_score * CONFIG.PHOENIX_WEIGHT
        
        # ì ìˆ˜ ì •ê·œí™” (ì•ˆì „ì¥ì¹˜)
        phoenix_score = max(0.0, min(phoenix_score, 1.0))
        
        return {
            'phoenix_score': round(phoenix_score, 4),
            'confidence': round(phoenix_score, 4),
            'recommendation': self._get_recommendation(phoenix_score),
            'components': {
                'technical': round(technical_score, 3),
                'volume': round(volume_score, 3),
                'momentum': round(momentum_score, 3)
            },
            'metadata': {
                'engine': self.name,
                'version': self.version,
                'timestamp': TimestampUtil.now(),
                'data_quality': self._assess_data_quality(data)
            }
        }
    
    def _assess_data_quality(self, data: Dict) -> str:
        """ë°ì´í„° í’ˆì§ˆ í‰ê°€ - ê°œì„ ë¨"""
        quality_checks = [
            ('symbol', lambda x: isinstance(x, str) and len(x) > 0),
            ('price', lambda x: isinstance(x, (int, float)) and x > 0),
            ('volume', lambda x: isinstance(x, (int, float)) and x >= 0),
            ('rsi', lambda x: isinstance(x, (int, float)) and 0 <= x <= 100),
            ('macd_line', lambda x: isinstance(x, (int, float))),
            ('macd_signal', lambda x: isinstance(x, (int, float)))
        ]
        
        passed_checks = 0
        total_checks = len(quality_checks)
        
        for field, validator in quality_checks:
            if field in data:
                try:
                    if validator(data[field]):
                        passed_checks += 1
                except:
                    pass
        
        quality_ratio = passed_checks / total_checks
        
        if quality_ratio >= 0.8:
            return "HIGH"
        elif quality_ratio >= 0.6:
            return "MEDIUM"
        else:
            return "LOW"
    
    def _analyze_technical(self, data: Dict) -> float:
        """ê¸°ìˆ ì  ì§€í‘œ ë¶„ì„"""
        rsi = data.get('rsi', 50)
        macd_line = data.get('macd_line', 0)
        macd_signal = data.get('macd_signal', 0)
        bb_position = data.get('bb_position', 0.5)
        
        # RSI ì ìˆ˜ (í—¤ì§€í€ë“œ ê²€ì¦ ë¡œì§)
        if rsi < 30:
            rsi_score = 0.9
        elif rsi < 40:
            rsi_score = 0.7
        elif rsi < 60:
            rsi_score = 0.5
        elif rsi < 70:
            rsi_score = 0.3
        else:
            rsi_score = 0.1
        
        # MACD ì ìˆ˜
        macd_diff = macd_line - macd_signal
        if abs(macd_diff) > 100:  # ì´ìƒê°’ ë°©ì§€
            macd_diff = 100 if macd_diff > 0 else -100
        macd_score = 0.5 + (macd_diff / 200)  # ì •ê·œí™”
        macd_score = max(0, min(macd_score, 1))
        
        # ë³¼ë¦°ì €ë°´ë“œ ì ìˆ˜
        bb_score = max(0, min(bb_position, 1))  # 0~1 ë²”ìœ„ ë³´ì¥
        
        # ê°€ì¤‘ í‰ê· 
        technical_score = (rsi_score * 0.5 + macd_score * 0.3 + bb_score * 0.2)
        return max(0, min(technical_score, 1))
    
    def _analyze_volume(self, data: Dict) -> float:
        """ê±°ë˜ëŸ‰ ë¶„ì„"""
        current_volume = data.get('volume', 1000000)
        avg_volume = data.get('avg_volume_20', 1000000)
        
        if avg_volume <= 0:
            return 0.5
        
        volume_ratio = current_volume / avg_volume
        
        # ì´ìƒê°’ ì²˜ë¦¬
        volume_ratio = max(0.1, min(volume_ratio, 10.0))
        
        # í—¤ì§€í€ë“œ ê±°ë˜ëŸ‰ í•´ì„
        if volume_ratio > 3.0:
            return 0.95
        elif volume_ratio > 2.0:
            return 0.85
        elif volume_ratio > 1.5:
            return 0.75
        elif volume_ratio > 1.2:
            return 0.65
        elif volume_ratio > 0.8:
            return 0.55
        else:
            return 0.3
    
    def _analyze_momentum(self, data: Dict) -> float:
        """ëª¨ë©˜í…€ ë¶„ì„"""
        stoch_k = data.get('stoch_k', 50)
        stoch_d = data.get('stoch_d', 50)
        williams_r = data.get('williams_r', -50)
        cci = data.get('cci', 0)
        
        # ì…ë ¥ê°’ ë²”ìœ„ ê²€ì¦
        stoch_k = max(0, min(stoch_k, 100))
        stoch_d = max(0, min(stoch_d, 100))
        williams_r = max(-100, min(williams_r, 0))
        cci = max(-300, min(cci, 300))
        
        # Stochastic ì ìˆ˜
        if stoch_k < 20 and stoch_d < 20:
            stoch_score = 0.9
        elif stoch_k > 80 and stoch_d > 80:
            stoch_score = 0.1
        else:
            stoch_score = 0.5
        
        # Williams %R ì ìˆ˜
        if williams_r < -80:
            williams_score = 0.9
        elif williams_r > -20:
            williams_score = 0.1
        else:
            williams_score = 0.5
        
        # CCI ì ìˆ˜
        if cci < -100:
            cci_score = 0.9
        elif cci > 100:
            cci_score = 0.1
        else:
            cci_score = 0.5 + (cci / 200)
            cci_score = max(0, min(cci_score, 1))
        
        # ê°€ì¤‘ í‰ê· 
        momentum_score = (stoch_score * 0.4 + williams_score * 0.3 + cci_score * 0.3)
        return max(0, min(momentum_score, 1))
    
    def _get_recommendation(self, score: float) -> str:
        """ì¶”ì²œ ë“±ê¸‰ (í—¤ì§€í€ë“œ ê¸°ì¤€)"""
        if score > 0.85:
            return "STRONG_BUY"
        elif score > 0.75:
            return "BUY"
        elif score > 0.60:
            return "WEAK_BUY"
        elif score > 0.40:
            return "HOLD"
        elif score > 0.25:
            return "WEAK_SELL"
        elif score > 0.15:
            return "SELL"
        else:
            return "STRONG_SELL"

# Signal Engine FastAPI ì•±
signal_app = FastAPI(
    title="Phoenix 95 Signal Engine",
    version="4.2.0",
    description="í—¤ì§€í€ë“œê¸‰ AI ì‹ í˜¸ ë¶„ì„ ì—”ì§„ (Fixed)"
)

phoenix_engine = Phoenix95Engine()

@signal_app.post("/analyze")
async def analyze_signal(data: dict):
    """í•µì‹¬ ì‹ í˜¸ ë¶„ì„ API"""
    try:
        # AI ë¶„ì„ ì‹¤í–‰
        analysis = phoenix_engine.analyze(data)
        
        # ì—ëŸ¬ê°€ ìˆëŠ” ê²½ìš° ì¦‰ì‹œ ë°˜í™˜
        if analysis.get('error'):
            raise HTTPException(status_code=400, detail=analysis['error'])
        
        # ê³ ì‹ ë¢°ë„ ì‹ í˜¸ì¸ ê²½ìš° ë¦¬ìŠ¤í¬ ì²´í¬
        analysis_data = analysis.get('data', {})
        if analysis_data.get('confidence', 0) > CONFIG.MIN_CONFIDENCE:
            risk_check = await call_service(
                'risk-guardian', 
                '/check',
                {'signal_data': data, 'analysis': analysis_data}
            )
            analysis_data['risk_check'] = risk_check
        
        return StandardResponse.success({
            'analysis': analysis_data,
            'engine': 'Phoenix 95 V4.2 Fixed',
        })
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ì‹ í˜¸ ë¶„ì„ ì‹¤íŒ¨: {str(e)}")
        raise HTTPException(status_code=500, detail=f"ë¶„ì„ ì‹¤íŒ¨: {str(e)}")

@signal_app.get("/health")
async def health():
    return StandardResponse.success({
        'service': 'signal_engine',
        'engine': phoenix_engine.name,
        'version': phoenix_engine.version
    })

@signal_app.get("/")
async def root():
    return StandardResponse.success({
        'service': 'Phoenix 95 Signal Engine',
        'version': '4.2.0',
        'description': 'í—¤ì§€í€ë“œê¸‰ AI ì‹ í˜¸ ë¶„ì„ (Fixed)',
        'endpoints': {
            'analyze': 'POST /analyze',
            'health': 'GET /health'
        }
    })

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ›¡ï¸ 2. RISK GUARDIAN (í¬íŠ¸: 8101) - ë™ì‹œì„± ì•ˆì „ì„± í™•ë³´
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class RiskGuardian:
    """í—¤ì§€í€ë“œê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œ - ë™ì‹œì„± ì•ˆì „ì„± í™•ë³´"""
    
    def __init__(self, data_dir: str = "./data"):
        # ë°ì´í„° ë””ë ‰í† ë¦¬ ìƒì„±
        self.data_dir = Path(data_dir)
        self.data_dir.mkdir(exist_ok=True)
        self.state_file = self.data_dir / "risk_state.json"
        
        # íŒŒì¼ ì ê¸ˆìš©
        self._lock = threading.RLock()  # ì¬ì§„ì… ê°€ëŠ¥í•œ ì ê¸ˆ
        
        # ìƒíƒœ ë¡œë“œ ë˜ëŠ” ì´ˆê¸°í™”
        self._load_state()
        
        # ë¦¬ìŠ¤í¬ ë©”íŠ¸ë¦­
        self.risk_metrics = {
            'daily_trades': 0,
            'success_rate': 0.0,
            'avg_holding_time': 0.0,
            'max_drawdown': 0.0
        }
        
        # ì¼ì¼ ë¦¬ì…‹ ì²´í¬
        self._check_daily_reset()
    
    def _load_state(self):
        """ì €ì¥ëœ ìƒíƒœ ë¡œë“œ - ì ê¸ˆ ì ìš©"""
        with self._lock:
            try:
                if self.state_file.exists():
                    with open(self.state_file, 'r', encoding='utf-8') as f:
                        state = json.load(f)
                        self.daily_pnl = state.get('daily_pnl', 0.0)
                        self.active_positions = state.get('active_positions', 0)
                        self.total_exposure = state.get('total_exposure', 0.0)
                        self.position_history = state.get('position_history', [])
                        last_reset_str = state.get('last_reset', datetime.now().date().isoformat())
                        self.last_reset = datetime.fromisoformat(last_reset_str).date()
                        logger.info("ë¦¬ìŠ¤í¬ ìƒíƒœ ë¡œë“œ ì™„ë£Œ")
                else:
                    self._init_default_state()
            except Exception as e:
                logger.warning(f"ìƒíƒœ ë¡œë“œ ì‹¤íŒ¨, ê¸°ë³¸ê°’ ì‚¬ìš©: {e}")
                self._init_default_state()
    
    def _init_default_state(self):
        """ê¸°ë³¸ ìƒíƒœ ì´ˆê¸°í™”"""
        self.daily_pnl = 0.0
        self.active_positions = 0
        self.total_exposure = 0.0
        self.position_history = []
        self.last_reset = datetime.now().date()
    
    def _save_state(self):
        """í˜„ì¬ ìƒíƒœ ì €ì¥ - ì›ìì  ì“°ê¸°"""
        with self._lock:
            try:
                state = {
                    'daily_pnl': self.daily_pnl,
                    'active_positions': self.active_positions,
                    'total_exposure': self.total_exposure,
                    'position_history': self.position_history[-100:],
                    'last_reset': self.last_reset.isoformat(),
                    'last_updated': TimestampUtil.now(),
                    'version': '4.2.0'
                }
                
                # ì„ì‹œ íŒŒì¼ì— ì“°ê³  ì›ìì ìœ¼ë¡œ ì´ë™
                temp_file = self.state_file.with_suffix('.tmp')
                with open(temp_file, 'w', encoding='utf-8') as f:
                    json.dump(state, f, indent=2, ensure_ascii=False)
                
                # íŒŒì¼ ê¶Œí•œ ì„¤ì • (600 - ì†Œìœ ìë§Œ ì½ê¸°/ì“°ê¸°)
                temp_file.chmod(0o600)
                
                # ì›ìì  ì´ë™
                temp_file.replace(self.state_file)
                
            except Exception as e:
                logger.warning(f"ìƒíƒœ ì €ì¥ ì‹¤íŒ¨: {e}")
    
    def check_trade_approval(self, signal_data: Dict, analysis: Dict) -> Dict:
        """ê±°ë˜ ìŠ¹ì¸ ì—¬ë¶€ ê²°ì • - í‘œì¤€í™”ëœ ê²€ì¦"""
        with self._lock:  # ë™ì‹œì„± ë³´ì¥
            checks = []
            approved = True
            risk_level = 'LOW'
            
            # ì¼ì¼ ë¦¬ì…‹ ì²´í¬
            self._check_daily_reset()
            
            try:
                # 1. ì¼ì¼ ì†ì‹¤ í•œë„ ì²´í¬
                if abs(self.daily_pnl) >= CONFIG.MAX_DAILY_LOSS:
                    approved = False
                    risk_level = 'CRITICAL'
                    checks.append(f"ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼: {self.daily_pnl:.2%}")
                
                # 2. í¬ì§€ì…˜ ìˆ˜ í•œë„ ì²´í¬
                if self.active_positions >= CONFIG.MAX_POSITIONS:
                    approved = False
                    risk_level = 'HIGH'
                    checks.append(f"ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ë„ë‹¬: {self.active_positions}/{CONFIG.MAX_POSITIONS}")
                
                # 3. ì‹ ë¢°ë„ ì²´í¬
                confidence = analysis.get('confidence', 0)
                if confidence < CONFIG.MIN_CONFIDENCE:
                    approved = False
                    risk_level = 'MEDIUM'
                    checks.append(f"ì‹ ë¢°ë„ ë¶€ì¡±: {confidence:.3f} < {CONFIG.MIN_CONFIDENCE}")
                
                # 4. í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
                account_balance = signal_data.get('account_balance', 10000)
                if account_balance <= 0:
                    approved = False
                    risk_level = 'CRITICAL'
                    checks.append("ê³„ì¢Œ ì”ê³ ê°€ ìœ íš¨í•˜ì§€ ì•ŠìŒ")
                    position_size = 0
                else:
                    position_size = self._calculate_position_size(account_balance, confidence)
                
                # 5. ì´ ë…¸ì¶œ í•œë„ ì²´í¬
                if account_balance > 0:
                    projected_exposure = self.total_exposure + (position_size / account_balance)
                    if projected_exposure > 0.20:  # ì´ 20% í•œë„
                        approved = False
                        risk_level = 'HIGH'
                        checks.append(f"ì´ ë…¸ì¶œ í•œë„ ì´ˆê³¼: {projected_exposure:.2%}")
                else:
                    projected_exposure = 0
                
                # 6. ì‹œì¥ ì¡°ê±´ ì²´í¬
                market_condition = self._assess_market_condition(signal_data)
                if market_condition == 'HIGH_VOLATILITY' and len(checks) > 0:
                    approved = False
                    risk_level = 'HIGH'
                    checks.append("ê³ ë³€ë™ì„± ì‹œì¥ì—ì„œ ì¶”ê°€ ë¦¬ìŠ¤í¬ ìš”ì¸ ì¡´ì¬")
                
                # ìŠ¹ì¸ëœ ê²½ìš°ì—ë§Œ í¬ì§€ì…˜ í¬ê¸° ì œê³µ
                final_position_size = position_size if approved else 0
                
                return {
                    'approved': approved,
                    'position_size': final_position_size,
                    'position_size_pct': final_position_size / account_balance if account_balance > 0 else 0,
                    'risk_level': risk_level,
                    'checks': checks,
                    'risk_metrics': {
                        'current_exposure': self.total_exposure,
                        'projected_exposure': projected_exposure,
                        'daily_pnl': self.daily_pnl,
                        'active_positions': self.active_positions,
                        'market_condition': market_condition
                    },
                    'kelly_sizing': {
                        'base_size': final_position_size * 0.8,
                        'confidence_adjusted': final_position_size,
                        'max_allowed': account_balance * CONFIG.MAX_POSITION_SIZE
                    }
                }
                
            except Exception as e:
                logger.error(f"ë¦¬ìŠ¤í¬ ì²´í¬ ì˜¤ë¥˜: {e}")
                return {
                    'approved': False,
                    'position_size': 0,
                    'position_size_pct': 0,
                    'risk_level': 'CRITICAL',
                    'checks': [f"ë¦¬ìŠ¤í¬ ì²´í¬ ì‹¤í–‰ ì˜¤ë¥˜: {str(e)}"],
                    'error': str(e)
                }
    
    def update_position_status(self, position_update: Dict):
        """í¬ì§€ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸ - ë™ì‹œì„± ë³´ì¥"""
        with self._lock:
            try:
                action = position_update.get('action')
                
                if action == 'open':
                    self.active_positions += 1
                    self.total_exposure += position_update.get('size_pct', 0)
                    self.risk_metrics['daily_trades'] += 1
                    
                elif action == 'close':
                    self.active_positions = max(0, self.active_positions - 1)
                    self.total_exposure -= position_update.get('size_pct', 0)
                    self.total_exposure = max(0, self.total_exposure)
                    
                    # P&L ì—…ë°ì´íŠ¸
                    pnl_pct = position_update.get('pnl_pct', 0)
                    self.daily_pnl += pnl_pct
                
                # í¬ì§€ì…˜ íˆìŠ¤í† ë¦¬ ê¸°ë¡
                self.position_history.append({
                    **position_update,
                    'timestamp': TimestampUtil.now()
                })
                
                # ìƒíƒœ ì €ì¥
                self._save_state()
                
            except Exception as e:
                logger.error(f"í¬ì§€ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
                raise
    
    def _calculate_position_size(self, balance: float, confidence: float) -> float:
        """Kelly Criterion ê¸°ë°˜ í¬ì§€ì…˜ ì‚¬ì´ì§• - ê°œì„ ë¨"""
        try:
            # ì…ë ¥ ê²€ì¦
            if balance <= 0 or confidence < 0 or confidence > 1:
                return 0.0
            
            # ê¸°ë³¸ ë¦¬ìŠ¤í¬ (ê³„ì¢Œì˜ 2%)
            base_risk_amount = balance * CONFIG.MAX_DAILY_LOSS
            
            # ì‹ ë¢°ë„ ê¸°ë°˜ ì¡°ì • (75%-100% ì‹ ë¢°ë„ë¥¼ 0.8-1.2ë°°ë¡œ ë§¤í•‘)
            confidence_factor = 0.8 + max(0, confidence - 0.75) * 1.6
            confidence_factor = max(0.5, min(confidence_factor, 1.2))
            
            # Kelly Criterion ê·¼ì‚¬ (ë³´ìˆ˜ì )
            estimated_win_rate = 0.6 + max(0, confidence - 0.75) * 0.4  # 0.6 ~ 1.0
            kelly_fraction = max(0, (estimated_win_rate * 2) - 1)  # Kelly ê³µì‹ ë‹¨ìˆœí™”
            kelly_fraction = max(0.05, min(kelly_fraction, 0.20))  # 5%-20% ì œí•œ
            
            # ìµœì¢… í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
            kelly_size = balance * kelly_fraction
            confidence_adjusted_size = kelly_size * confidence_factor
            
            # ìµœëŒ€ í•œë„ ì ìš©
            max_position = balance * CONFIG.MAX_POSITION_SIZE
            final_size = min(confidence_adjusted_size, max_position)
            
            return max(0, final_size)
            
        except Exception as e:
            logger.error(f"í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0
    
    def _assess_market_condition(self, data: Dict) -> str:
        """ì‹œì¥ ì¡°ê±´ í‰ê°€"""
        try:
            volatility = data.get('volatility', 0.02)
            volume_ratio = data.get('volume', 1000) / max(data.get('avg_volume_20', 1000), 1)
            
            # ì•ˆì „í•œ ë²”ìœ„ë¡œ ì œí•œ
            volatility = max(0, min(volatility, 1.0))
            volume_ratio = max(0, min(volume_ratio, 10.0))
            
            if volatility > 0.05 or volume_ratio > 3.0:
                return 'HIGH_VOLATILITY'
            elif volatility > 0.03 or volume_ratio > 2.0:
                return 'MEDIUM_VOLATILITY'
            else:
                return 'NORMAL'
        except Exception as e:
            logger.warning(f"ì‹œì¥ ì¡°ê±´ í‰ê°€ ì˜¤ë¥˜: {e}")
            return 'UNKNOWN'
    
    def _check_daily_reset(self):
        """ì¼ì¼ ë¦¬ì…‹ ì²´í¬"""
        today = datetime.now().date()
        if today != self.last_reset:
            self.daily_pnl = 0.0
            self.risk_metrics['daily_trades'] = 0
            self.last_reset = today
            self._save_state()
    
    def get_risk_report(self) -> Dict:
        """ë¦¬ìŠ¤í¬ ë³´ê³ ì„œ ìƒì„±"""
        with self._lock:
            return {
                'current_status': {
                    'daily_pnl': self.daily_pnl,
                    'active_positions': self.active_positions,
                    'total_exposure': self.total_exposure,
                    'risk_utilization': abs(self.daily_pnl) / CONFIG.MAX_DAILY_LOSS if CONFIG.MAX_DAILY_LOSS > 0 else 0
                },
                'limits': {
                    'max_daily_loss': CONFIG.MAX_DAILY_LOSS,
                    'max_positions': CONFIG.MAX_POSITIONS,
                    'max_position_size': CONFIG.MAX_POSITION_SIZE,
                    'min_confidence': CONFIG.MIN_CONFIDENCE
                },
                'metrics': self.risk_metrics.copy(),
                'alerts': self._generate_alerts()
            }
    
    def _generate_alerts(self) -> List[str]:
        """ë¦¬ìŠ¤í¬ ì•Œë¦¼ ìƒì„±"""
        alerts = []
        
        try:
            if abs(self.daily_pnl) > CONFIG.MAX_DAILY_LOSS * 0.8:
                alerts.append("ì¼ì¼ ì†ì‹¤ì´ í•œë„ì˜ 80%ì— ë„ë‹¬")
                
            if self.active_positions >= CONFIG.MAX_POSITIONS * 0.8:
                alerts.append("í™œì„± í¬ì§€ì…˜ì´ í•œë„ì˜ 80%ì— ë„ë‹¬")
                
            if self.total_exposure > 0.15:
                alerts.append("ì´ ë…¸ì¶œì´ 15%ë¥¼ ì´ˆê³¼")
                
        except Exception as e:
            logger.warning(f"ì•Œë¦¼ ìƒì„± ì˜¤ë¥˜: {e}")
            alerts.append("ì•Œë¦¼ ìƒì„± ì¤‘ ì˜¤ë¥˜ ë°œìƒ")
            
        return alerts

# Risk Guardian FastAPI ì•±
risk_app = FastAPI(
    title="Phoenix 95 Risk Guardian",
    version="4.2.0",
    description="í—¤ì§€í€ë“œê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œ (Fixed)"
)

risk_guardian = RiskGuardian()

@risk_app.post("/check")
async def check_risk(data: dict):
    """ë¦¬ìŠ¤í¬ ì²´í¬ API"""
    try:
        signal_data = data.get('signal_data', {})
        analysis = data.get('analysis', {})
        
        result = risk_guardian.check_trade_approval(signal_data, analysis)
        
        return StandardResponse.success({
            'risk_check': result
        })
        
    except Exception as e:
        logger.error(f"ë¦¬ìŠ¤í¬ ì²´í¬ ì‹¤íŒ¨: {str(e)}")
        raise HTTPException(status_code=500, detail=f"ë¦¬ìŠ¤í¬ ì²´í¬ ì‹¤íŒ¨: {str(e)}")

@risk_app.post("/update")
async def update_position(data: dict):
    """í¬ì§€ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸"""
    try:
        risk_guardian.update_position_status(data)
        return StandardResponse.success({'updated': True})
    except Exception as e:
        logger.error(f"í¬ì§€ì…˜ ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {str(e)}")
        raise HTTPException(status_code=500, detail=f"ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {str(e)}")

@risk_app.get("/status")
async def risk_status():
    """ë¦¬ìŠ¤í¬ ìƒíƒœ ì¡°íšŒ"""
    try:
        report = risk_guardian.get_risk_report()
        return StandardResponse.success(report)
    except Exception as e:
        logger.error(f"ë¦¬ìŠ¤í¬ ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")
        raise HTTPException(status_code=500, detail=f"ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")

@risk_app.get("/health")
async def health():
    return StandardResponse.success({
        'service': 'risk_guardian',
        'active_positions': risk_guardian.active_positions,
        'daily_pnl': risk_guardian.daily_pnl,
        'data_file_exists': risk_guardian.state_file.exists()
    })

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš¡ 3. TRADE EXECUTOR (í¬íŠ¸: 8102) - ê°•í™”ëœ ì—ëŸ¬ ì²˜ë¦¬
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class TradeExecutor:
    """í—¤ì§€í€ë“œê¸‰ ê±°ë˜ ì‹¤í–‰ ì‹œìŠ¤í…œ - ê°•í™”ëœ ì—ëŸ¬ ì²˜ë¦¬"""
    
    def __init__(self):
        # ë³´ì•ˆ ê°•í™”ëœ API í‚¤ ê´€ë¦¬
        self.api_key, self.api_secret = SecurityConfig.get_binance_credentials()
        self.test_mode = os.getenv('TRADE_MODE', 'TEST') == 'TEST'
        
        # ê±°ë˜ ì„¤ì •
        self.leverage = CONFIG.LEVERAGE
        self.stop_loss_pct = CONFIG.STOP_LOSS
        self.take_profit_pct = CONFIG.TAKE_PROFIT
        
        # ê±°ë˜ í†µê³„ (ìŠ¤ë ˆë“œ ì•ˆì „)
        self._stats_lock = threading.Lock()
        self.execution_stats = {
            'total_trades': 0,
            'successful_trades': 0,
            'failed_trades': 0,
            'avg_execution_time': 0.0,
            'total_volume': 0.0
        }
    
    async def execute_trade(self, signal: Dict, risk_approval: Dict) -> Dict:
        """ê±°ë˜ ì‹¤í–‰ - ì™„ì „í•œ ì—ëŸ¬ ì²˜ë¦¬"""
        execution_start = TimestampUtil.now_ms()
        
        try:
            # 1. ì…ë ¥ ê²€ì¦
            validation_result = self._validate_trade_inputs(signal, risk_approval)
            if validation_result['error']:
                return StandardResponse.error(
                    validation_result['message'],
                    "VALIDATION_ERROR", 
                    validation_result['details']
                )
            
            # 2. ë¦¬ìŠ¤í¬ ìŠ¹ì¸ ê²€ì¦
            if not risk_approval.get('approved'):
                return StandardResponse.error(
                    'Risk not approved',
                    "RISK_REJECTED",
                    {
                        'risk_checks': risk_approval.get('checks', []),
                        'risk_level': risk_approval.get('risk_level', 'UNKNOWN')
                    }
                )
            
            # 3. API í‚¤ ê²€ì¦ (LIVE ëª¨ë“œ)
            if not self.test_mode and (not self.api_key or not self.api_secret):
                return StandardResponse.error(
                    'LIVE ëª¨ë“œì´ì§€ë§Œ API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ',
                    "API_KEY_MISSING"
                )
            
            # 4. ê±°ë˜ ì‹¤í–‰
            execution_result = await self._execute_trade_internal(signal, risk_approval)
            
            # 5. í†µê³„ ì—…ë°ì´íŠ¸
            execution_time = TimestampUtil.now_ms() - execution_start
            success = execution_result.get('status') == 'executed'
            position_size = risk_approval.get('position_size', 0)
            
            self._update_execution_stats(execution_time, position_size, success)
            
            return StandardResponse.success(execution_result)
            
        except Exception as e:
            logger.error(f"ê±°ë˜ ì‹¤í–‰ ì˜ˆì™¸: {str(e)}")
            self._update_execution_stats(0, 0, False)
            return StandardResponse.error(
                f"ê±°ë˜ ì‹¤í–‰ ì¤‘ ì˜ˆì™¸ ë°œìƒ: {str(e)}",
                "EXECUTION_EXCEPTION"
            )
    
    def _validate_trade_inputs(self, signal: Dict, risk_approval: Dict) -> Dict:
        """ê±°ë˜ ì…ë ¥ ê²€ì¦"""
        # íƒ€ì… ê²€ì¦
        if not isinstance(signal, dict) or not isinstance(risk_approval, dict):
            return {
                'error': True,
                'message': 'ì˜ëª»ëœ ì…ë ¥ ë°ì´í„° íƒ€ì…',
                'details': {
                    'signal_type': type(signal).__name__,
                    'risk_approval_type': type(risk_approval).__name__
                }
            }
        
        # í•„ìˆ˜ ì‹ í˜¸ ë°ì´í„° ê²€ì¦
        required_signal_fields = ['symbol', 'side', 'price']
        missing_fields = [field for field in required_signal_fields if field not in signal]
        if missing_fields:
            return {
                'error': True,
                'message': f'ì‹ í˜¸ ë°ì´í„°ì— í•„ìˆ˜ í•„ë“œ ëˆ„ë½: {missing_fields}',
                'details': {'missing_fields': missing_fields}
            }
        
        # ì‹ í˜¸ ë°ì´í„° ê°’ ê²€ì¦
        try:
            price = float(signal['price'])
            if price <= 0:
                return {
                    'error': True,
                    'message': 'ê°€ê²©ì€ 0ë³´ë‹¤ í° ê°’ì´ì–´ì•¼ í•©ë‹ˆë‹¤',
                    'details': {'price': signal['price']}
                }
        except (ValueError, TypeError):
            return {
                'error': True,
                'message': 'ê°€ê²©ì´ ìœ íš¨í•œ ìˆ«ìê°€ ì•„ë‹™ë‹ˆë‹¤',
                'details': {'price': signal['price']}
            }
        
        # ê±°ë˜ ë°©í–¥ ê²€ì¦
        if signal['side'] not in ['BUY', 'SELL', 'buy', 'sell']:
            return {
                'error': True,
                'message': 'ìœ íš¨í•˜ì§€ ì•Šì€ ê±°ë˜ ë°©í–¥',
                'details': {'side': signal['side'], 'valid_sides': ['BUY', 'SELL']}
            }
        
        # í¬ì§€ì…˜ í¬ê¸° ê²€ì¦
        position_size = risk_approval.get('position_size', 0)
        if position_size <= 0:
            return {
                'error': True,
                'message': 'ìœ íš¨í•˜ì§€ ì•Šì€ í¬ì§€ì…˜ í¬ê¸°',
                'details': {'position_size': position_size}
            }
        
        return {'error': False}
    
    async def _execute_trade_internal(self, signal: Dict, risk_approval: Dict) -> Dict:
        """ë‚´ë¶€ ê±°ë˜ ì‹¤í–‰ ë¡œì§"""
        # 1. ë ˆë²„ë¦¬ì§€ ì„¤ì •
        leverage_result = await self._set_leverage(signal['symbol'])
        if not leverage_result.get('success', True):
            return {
                'status': 'failed',
                'reason': f"ë ˆë²„ë¦¬ì§€ ì„¤ì • ì‹¤íŒ¨: {leverage_result.get('error', 'Unknown')}"
            }
        
        # 2. ì£¼ë¬¸ ì‹¤í–‰
        order_result = await self._place_order(
            symbol=signal['symbol'],
            side=signal['side'].upper(),
            quantity=risk_approval['position_size'],
            price=float(signal['price'])
        )
        
        if order_result['status'] == 'FILLED':
            # 3. ìµì ˆ/ì†ì ˆ ì£¼ë¬¸ ì„¤ì •
            stop_orders = await self._set_stop_orders(order_result, signal['side'].upper())
            
            # 4. Risk Guardianì— í¬ì§€ì…˜ ì˜¤í”ˆ ì•Œë¦¼
            try:
                await call_service('risk-guardian', '/update', {
                    'action': 'open',
                    'size_pct': risk_approval['position_size'] / signal.get('account_balance', 10000),
                    'symbol': signal['symbol']
                })
            except Exception as e:
                logger.warning(f"Risk Guardian ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
            
            return {
                'status': 'executed',
                'order_details': {
                    'order_id': order_result['orderId'],
                    'symbol': signal['symbol'],
                    'side': signal['side'].upper(),
                    'executed_price': order_result['price'],
                    'executed_qty': order_result['executedQty'],
                    'leverage': self.leverage
                },
                'risk_management': {
                    'stop_loss_price': stop_orders['stop_loss'],
                    'take_profit_price': stop_orders['take_profit'],
                    'liquidation_price': self._calculate_liquidation_price(
                        order_result['price'], signal['side'].upper()
                    )
                },
                'metadata': {
                    'execution_mode': 'TEST' if self.test_mode else 'LIVE',
                    'timestamp': TimestampUtil.now()
                }
            }
        else:
            return {
                'status': 'failed',
                'reason': f"ì£¼ë¬¸ ì‹¤íŒ¨: {order_result.get('msg', 'Unknown error')}",
                'order_details': order_result
            }
    
    async def _set_leverage(self, symbol: str) -> Dict:
        """ë ˆë²„ë¦¬ì§€ ì„¤ì •"""
        try:
            if self.test_mode:
                logger.info(f"[TEST MODE] Setting {symbol} leverage to {self.leverage}x ISOLATED")
                return {'success': True, 'leverage': self.leverage}
            
            # ì‹¤ì œ Binance API í˜¸ì¶œ ì‹œë®¬ë ˆì´ì…˜
            await asyncio.sleep(0.01)  # API í˜¸ì¶œ ì‹œë®¬ë ˆì´ì…˜
            return {'success': True, 'leverage': self.leverage}
            
        except Exception as e:
            logger.error(f"ë ˆë²„ë¦¬ì§€ ì„¤ì • ì˜¤ë¥˜: {e}")
            return {'success': False, 'error': str(e)}
    
    async def _place_order(self, symbol: str, side: str, quantity: float, price: float) -> Dict:
        """ì£¼ë¬¸ ì‹¤í–‰"""
        try:
            if self.test_mode:
                # í…ŒìŠ¤íŠ¸ ëª¨ë“œ: ì‹œë®¬ë ˆì´ì…˜
                order_id = f"TEST_{TimestampUtil.now_ms()}"
                logger.info(f"[TEST MODE] Placing {side} order: {symbol} @ ${price:,.2f}, qty: {quantity:,.2f}")
                
                # ì•½ê°„ì˜ ì§€ì—° ì‹œë®¬ë ˆì´ì…˜
                await asyncio.sleep(0.05)
                
                return {
                    'orderId': order_id,
                    'status': 'FILLED',
                    'price': price,
                    'executedQty': quantity,
                    'symbol': symbol,
                    'side': side
                }
            
            # ì‹¤ì œ Binance API í˜¸ì¶œ
            # í˜„ì¬ëŠ” ì‹œë®¬ë ˆì´ì…˜ìœ¼ë¡œ ëŒ€ì²´
            await asyncio.sleep(0.1)  # API í˜¸ì¶œ ì‹œë®¬ë ˆì´ì…˜
            return {
                'orderId': f"LIVE_{TimestampUtil.now_ms()}",
                'status': 'FILLED',
                'price': price,
                'executedQty': quantity,
                'symbol': symbol,
                'side': side
            }
            
        except Exception as e:
            logger.error(f"ì£¼ë¬¸ ì‹¤í–‰ ì˜¤ë¥˜: {e}")
            return {
                'status': 'FAILED',
                'msg': str(e)
            }
    
    async def _set_stop_orders(self, order_result: Dict, side: str) -> Dict:
        """ìµì ˆ/ì†ì ˆ ì£¼ë¬¸ ì„¤ì •"""
        try:
            entry_price = float(order_result['price'])
            
            if side == 'BUY':
                stop_loss = entry_price * (1 - self.stop_loss_pct)
                take_profit = entry_price * (1 + self.take_profit_pct)
            else:  # SELL
                stop_loss = entry_price * (1 + self.stop_loss_pct)
                take_profit = entry_price * (1 - self.take_profit_pct)
            
            if self.test_mode:
                logger.info(f"[TEST MODE] Stop orders set - SL: ${stop_loss:,.2f}, TP: ${take_profit:,.2f}")
            
            return {
                'stop_loss': stop_loss,
                'take_profit': take_profit
            }
            
        except Exception as e:
            logger.error(f"ìµì ˆ/ì†ì ˆ ì„¤ì • ì˜¤ë¥˜: {e}")
            return {
                'stop_loss': 0,
                'take_profit': 0
            }
    
    def _calculate_liquidation_price(self, entry_price: float, side: str) -> float:
        """ì²­ì‚°ê°€ ê³„ì‚°"""
        try:
            maintenance_margin = 0.004  # 0.4%
            
            if side == 'BUY':
                liquidation_price = entry_price * (1 - (1/self.leverage) + maintenance_margin)
            else:  # SELL
                liquidation_price = entry_price * (1 + (1/self.leverage) - maintenance_margin)
            
            return max(0, liquidation_price)  # ìŒìˆ˜ ë°©ì§€
            
        except Exception as e:
            logger.error(f"ì²­ì‚°ê°€ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0
    
    def _update_execution_stats(self, execution_time: float, volume: float, success: bool):
        """ì‹¤í–‰ í†µê³„ ì—…ë°ì´íŠ¸ - ìŠ¤ë ˆë“œ ì•ˆì „"""
        with self._stats_lock:
            try:
                self.execution_stats['total_trades'] += 1
                
                if success:
                    self.execution_stats['successful_trades'] += 1
                    self.execution_stats['total_volume'] += volume
                    
                    # í‰ê·  ì‹¤í–‰ ì‹œê°„ ì—…ë°ì´íŠ¸
                    current_avg = self.execution_stats['avg_execution_time']
                    total_successful = self.execution_stats['successful_trades']
                    if total_successful > 0:
                        new_avg = ((current_avg * (total_successful - 1)) + execution_time) / total_successful
                        self.execution_stats['avg_execution_time'] = new_avg
                else:
                    self.execution_stats['failed_trades'] += 1
                    
            except Exception as e:
                logger.error(f"í†µê³„ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
    
    def get_execution_report(self) -> Dict:
        """ì‹¤í–‰ ë³´ê³ ì„œ"""
        with self._stats_lock:
            total = self.execution_stats['total_trades']
            success_rate = (
                self.execution_stats['successful_trades'] / total * 100 
                if total > 0 else 0
            )
            
            return {
                'execution_stats': {
                    **self.execution_stats.copy(),
                    'success_rate_pct': round(success_rate, 2)
                },
                'configuration': {
                    'leverage': self.leverage,
                    'stop_loss_pct': self.stop_loss_pct,
                    'take_profit_pct': self.take_profit_pct,
                    'test_mode': self.test_mode,
                    'api_configured': bool(self.api_key and self.api_secret)
                }
            }

# Trade Executor FastAPI ì•±
trade_app = FastAPI(
    title="Phoenix 95 Trade Executor",
    version="4.2.0",
    description="í—¤ì§€í€ë“œê¸‰ ê±°ë˜ ì‹¤í–‰ ì‹œìŠ¤í…œ (Fixed)"
)

trade_executor = TradeExecutor()

@trade_app.post("/execute")
async def execute_trade(data: dict):
    """ê±°ë˜ ì‹¤í–‰ API"""
    try:
        signal = data.get('signal', {})
        risk_approval = data.get('risk_approval', {})
        
        result = await trade_executor.execute_trade(signal, risk_approval)
        
        # ì—ëŸ¬ê°€ ìˆëŠ” ê²½ìš° HTTP ì˜ˆì™¸ ë°œìƒ
        if result.get('error'):
            raise HTTPException(status_code=400, detail=result['error'])
        
        return result
        
    except HTTPException:
        raise
    except Exception as e:
        logger.error(f"ê±°ë˜ ì‹¤í–‰ API ì˜¤ë¥˜: {str(e)}")
        raise HTTPException(status_code=500, detail=f"ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨: {str(e)}")

@trade_app.get("/stats")
async def execution_stats():
    """ì‹¤í–‰ í†µê³„ ì¡°íšŒ"""
    try:
        report = trade_executor.get_execution_report()
        return StandardResponse.success(report)
    except Exception as e:
        logger.error(f"í†µê³„ ì¡°íšŒ ì˜¤ë¥˜: {str(e)}")
        raise HTTPException(status_code=500, detail=f"í†µê³„ ì¡°íšŒ ì‹¤íŒ¨: {str(e)}")

@trade_app.get("/health")
async def health():
    stats = trade_executor.execution_stats
    return StandardResponse.success({
        'service': 'trade_executor',
        'total_trades': stats['total_trades'],
        'success_rate': (
            stats['successful_trades'] / stats['total_trades'] * 100
            if stats['total_trades'] > 0 else 0
        ),
        'test_mode': trade_executor.test_mode,
        'api_configured': bool(trade_executor.api_key and trade_executor.api_secret)
    })

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š 4. MONITOR & ALERT (í¬íŠ¸: 8103) - ê°œì„ ëœ í…”ë ˆê·¸ë¨ ì²˜ë¦¬
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MonitorAlert:
    """í—¤ì§€í€ë“œê¸‰ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ - ê°œì„ ë¨"""
    
    def __init__(self):
        self.telegram_token = CONFIG.get_telegram_token()
        self.chat_id = CONFIG.get_telegram_chat_id()
        self.telegram_enabled = bool(self.telegram_token and self.chat_id)
        
        if not self.telegram_enabled:
            logger.warning("í…”ë ˆê·¸ë¨ ì„¤ì •ì´ ì—†ì–´ ì•Œë¦¼ì´ ë¡œì»¬ ë¡œê·¸ë¡œë§Œ ì¶œë ¥ë©ë‹ˆë‹¤.")
        
        # í¬ì§€ì…˜ ì¶”ì 
        self.positions = {}
        self.alerts_sent = set()
        
        # ì„±ëŠ¥ ë©”íŠ¸ë¦­
        self.performance_metrics = {
            'total_pnl': 0.0,
            'win_rate': 0.0,
            'avg_trade_duration': 0.0,
            'max_drawdown': 0.0,
            'sharpe_ratio': 0.0
        }
    
    async def send_trade_alert(self, trade_data: Dict):
        """ê±°ë˜ ì•Œë¦¼ ì „ì†¡"""
        try:
            execution_result = trade_data.get('execution_result', {}).get('data', {})
            
            if execution_result.get('status') == 'executed':
                message = self._format_execution_message(execution_result)
                await self._send_telegram(message)
                
            elif execution_result.get('status') == 'rejected':
                message = self._format_rejection_message(execution_result)
                await self._send_telegram(message)
                
        except Exception as e:
            logger.error(f"ê±°ë˜ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    def _format_execution_message(self, execution_result: Dict) -> str:
        """ê±°ë˜ ì‹¤í–‰ ë©”ì‹œì§€ í¬ë§·"""
        order_details = execution_result.get('order_details', {})
        risk_mgmt = execution_result.get('risk_management', {})
        metadata = execution_result.get('metadata', {})
        
        return f"""
ğŸ¦ <b>í—¤ì§€í€ë“œ ê±°ë˜ ì‹¤í–‰</b>

ğŸ“Š <b>ê¸°ë³¸ ì •ë³´</b>
â€¢ ì‹¬ë³¼: <code>{order_details.get('symbol', 'UNKNOWN')}</code>
â€¢ ë°©í–¥: <b>{order_details.get('side', 'UNKNOWN')}</b>
â€¢ ê°€ê²©: <code>${order_details.get('executed_price', 0):,.2f}</code>
â€¢ ìˆ˜ëŸ‰: <code>{order_details.get('executed_qty', 0):,.4f}</code>

âš¡ <b>ë ˆë²„ë¦¬ì§€ ì •ë³´</b>
â€¢ ë ˆë²„ë¦¬ì§€: <b>{order_details.get('leverage', 20)}x ISOLATED</b>
â€¢ ì²­ì‚°ê°€: <code>${risk_mgmt.get('liquidation_price', 0):,.2f}</code>

ğŸ¯ <b>ë¦¬ìŠ¤í¬ ê´€ë¦¬</b>
â€¢ ìµì ˆê°€: <code>${risk_mgmt.get('take_profit_price', 0):,.2f}</code> (+{CONFIG.TAKE_PROFIT:.1%})
â€¢ ì†ì ˆê°€: <code>${risk_mgmt.get('stop_loss_price', 0):,.2f}</code> (-{CONFIG.STOP_LOSS:.1%})

ğŸ“ˆ <b>ì‹¤í–‰ ì •ë³´</b>
â€¢ ì£¼ë¬¸ID: <code>{order_details.get('order_id', 'N/A')}</code>
â€¢ ëª¨ë“œ: {metadata.get('execution_mode', 'UNKNOWN')}

â° {TimestampUtil.now()}
"""
    
    def _format_rejection_message(self, execution_result: Dict) -> str:
        """ê±°ë˜ ê±°ì ˆ ë©”ì‹œì§€ í¬ë§·"""
        error_info = execution_result.get('error', {})
        details = error_info.get('details', {})
        
        checks_text = ""
        if isinstance(details, dict) and 'risk_checks' in details:
            checks = details['risk_checks']
            if checks:
                checks_text = "\nğŸ” <b>ë¦¬ìŠ¤í¬ ì²´í¬:</b>\n" + "\n".join(f"â€¢ {check}" for check in checks[:5])
        
        return f"""
ğŸš« <b>ê±°ë˜ ê±°ì ˆ</b>

âŒ <b>ê±°ì ˆ ì‚¬ìœ :</b> {error_info.get('message', 'Unknown')}
ğŸ“‹ <b>ì—ëŸ¬ ì½”ë“œ:</b> {error_info.get('code', 'UNKNOWN')}
{checks_text}

â° {TimestampUtil.now()}
"""
    
    async def send_system_alert(self, alert_type: str, message: str, severity: str = 'INFO'):
        """ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡"""
        emoji_map = {
            'INFO': 'â„¹ï¸',
            'WARNING': 'âš ï¸',
            'ERROR': 'âŒ',
            'CRITICAL': 'ğŸš¨'
        }
        
        emoji = emoji_map.get(severity, 'â„¹ï¸')
        
        formatted_message = f"""
{emoji} <b>ì‹œìŠ¤í…œ ì•Œë¦¼</b>

ğŸ“‹ <b>ìœ í˜•:</b> {alert_type}
ğŸ” <b>ë‚´ìš©:</b> {message}
ğŸ“Š <b>ì‹¬ê°ë„:</b> {severity}

â° {TimestampUtil.now()}
"""
        await self._send_telegram(formatted_message)
    
    async def send_performance_report(self):
        """ì„±ëŠ¥ ë³´ê³ ì„œ ì „ì†¡"""
        try:
            # ê° ì„œë¹„ìŠ¤ì—ì„œ ì„±ëŠ¥ ë°ì´í„° ìˆ˜ì§‘
            performance_data = await self._collect_performance_data()
            
            message = f"""
ğŸ“ˆ <b>Phoenix 95 ì„±ëŠ¥ ë³´ê³ ì„œ</b>

ğŸ¦ <b>ì „ì²´ ì„±ëŠ¥</b>
â€¢ ì´ P&L: <b>{performance_data.get('total_pnl', 0):+.2%}</b>
â€¢ ìŠ¹ë¥ : <b>{performance_data.get('win_rate', 0):.1%}</b>
â€¢ ìµœëŒ€ ì†ì‹¤: <b>{performance_data.get('max_drawdown', 0):.2%}</b>
â€¢ ìƒ¤í”„ ë¹„ìœ¨: <b>{performance_data.get('sharpe_ratio', 0):.2f}</b>

âš¡ <b>ê±°ë˜ í†µê³„</b>
â€¢ ì´ ê±°ë˜: {performance_data.get('total_trades', 0)}íšŒ
â€¢ í‰ê·  ë³´ìœ ì‹œê°„: {performance_data.get('avg_duration', 0):.1f}ë¶„
â€¢ ì‹¤í–‰ ì„±ê³µë¥ : {performance_data.get('execution_success_rate', 0):.1%}

ğŸ›¡ï¸ <b>ë¦¬ìŠ¤í¬ í˜„í™©</b>
â€¢ í™œì„± í¬ì§€ì…˜: {performance_data.get('active_positions', 0)}ê°œ
â€¢ ì´ ë…¸ì¶œ: {performance_data.get('total_exposure', 0):.1%}
â€¢ ì¼ì¼ P&L: {performance_data.get('daily_pnl', 0):+.2%}

â° {TimestampUtil.now()}
"""
            await self._send_telegram(message)
            
        except Exception as e:
            logger.error(f"ì„±ëŠ¥ ë³´ê³ ì„œ ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    async def _collect_performance_data(self) -> Dict:
        """ì„±ëŠ¥ ë°ì´í„° ìˆ˜ì§‘"""
        try:
            # Risk Guardianì—ì„œ ë¦¬ìŠ¤í¬ í˜„í™© ìˆ˜ì§‘
            risk_response = await call_service('risk-guardian', '/status', {})
            risk_data = risk_response.get('data', {}) if risk_response else {}
            
            # Trade Executorì—ì„œ ê±°ë˜ í†µê³„ ìˆ˜ì§‘
            trade_response = await call_service('trade-executor', '/stats', {})
            trade_data = trade_response.get('data', {}) if trade_response else {}
            
            current_status = risk_data.get('current_status', {})
            execution_stats = trade_data.get('execution_stats', {})
            
            return {
                'total_pnl': current_status.get('daily_pnl', 0),
                'active_positions': current_status.get('active_positions', 0),
                'total_exposure': current_status.get('total_exposure', 0),
                'daily_pnl': current_status.get('daily_pnl', 0),
                'total_trades': execution_stats.get('total_trades', 0),
                'execution_success_rate': execution_stats.get('success_rate_pct', 0),
                'win_rate': 0.0,  # ì¶”í›„ êµ¬í˜„
                'max_drawdown': 0.0,
                'sharpe_ratio': 0.0,
                'avg_duration': 0.0
            }
        except Exception as e:
            logger.error(f"ì„±ëŠ¥ ë°ì´í„° ìˆ˜ì§‘ ì‹¤íŒ¨: {e}")
            return {}
    
    async def _send_telegram(self, message: str):
        """í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ - ì•ˆì „í•œ ë°©ì‹"""
        # í…”ë ˆê·¸ë¨ì´ ë¹„í™œì„±í™”ëœ ê²½ìš° ë¡œì»¬ ë¡œê·¸ë§Œ ì¶œë ¥
        if not self.telegram_enabled:
            logger.info(f"[LOCAL ALERT] {message}")
            return
        
        # ë©”ì‹œì§€ ê¸¸ì´ ì œí•œ (Telegram 4096ì ì œí•œ)
        if len(message) > 4000:
            message = message[:3950] + "\n... (ë©”ì‹œì§€ ì˜ë¦¼)"
        
        url = f"https://api.telegram.org/bot{self.telegram_token}/sendMessage"
        data = {
            'chat_id': self.chat_id,
            'text': message,
            'parse_mode': 'HTML',
            'disable_web_page_preview': True
        }
        
        try:
            session = await session_manager.get_session()
            async with session.post(url, data=data, timeout=aiohttp.ClientTimeout(total=10)) as response:
                if response.status == 200:
                    logger.info("í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì „ì†¡ ì„±ê³µ")
                else:
                    error_text = await response.text()
                    logger.error(f"í…”ë ˆê·¸ë¨ ì „ì†¡ ì‹¤íŒ¨: HTTP {response.status}")
                    logger.error(f"Response: {error_text}")
        except asyncio.TimeoutError:
            logger.error("í…”ë ˆê·¸ë¨ ì „ì†¡ íƒ€ì„ì•„ì›ƒ")
        except Exception as e:
            logger.error(f"í…”ë ˆê·¸ë¨ ì˜¤ë¥˜: {e}")
    
    async def health_check_all_services(self) -> Dict:
        """ì „ì²´ ì„œë¹„ìŠ¤ í—¬ìŠ¤ì²´í¬"""
        service_ports = ServicePorts.get_service_map()
        
        results = {}
        healthy_count = 0
        
        session = await session_manager.get_session()
        
        for service_name, port in service_ports.items():
            url = f"http://localhost:{port}/health"
            try:
                start_time = TimestampUtil.now_ms()
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=5)) as response:
                    response_time = TimestampUtil.now_ms() - start_time
                    
                    if response.status == 200:
                        response_data = await response.json()
                        results[service_name] = {
                            'status': 'healthy',
                            'response_time_ms': response_time,
                            'data': response_data
                        }
                        healthy_count += 1
                    else:
                        results[service_name] = {
                            'status': 'unhealthy',
                            'http_status': response.status
                        }
            except Exception as e:
                results[service_name] = {
                    'status': 'unreachable',
                    'error': str(e)
                }
        
        overall_status = 'healthy' if healthy_count == len(service_ports) else 'degraded'
        
        return {
            'overall_status': overall_status,
            'healthy_services': healthy_count,
            'total_services': len(service_ports),
            'services': results,
            'timestamp': TimestampUtil.now()
        }

# Monitor & Alert FastAPI ì•±
monitor_app = FastAPI(
    title="Phoenix 95 Monitor & Alert",
    version="4.2.0",
    description="í—¤ì§€í€ë“œê¸‰ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ (Fixed)"
)

monitor_alert = MonitorAlert()

@monitor_app.post("/alert/trade")
async def trade_alert(data: dict):
    """ê±°ë˜ ì•Œë¦¼"""
    try:
        await monitor_alert.send_trade_alert(data)
        return StandardResponse.success({'sent': True})
    except Exception as e:
        logger.error(f"ê±°ë˜ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail=f"ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {str(e)}")

@monitor_app.post("/alert/system")
async def system_alert(data: dict):
    """ì‹œìŠ¤í…œ ì•Œë¦¼"""
    try:
        alert_type = data.get('type', 'SYSTEM')
        message = data.get('message', 'Unknown system event')
        severity = data.get('severity', 'INFO')
        
        await monitor_alert.send_system_alert(alert_type, message, severity)
        return StandardResponse.success({'sent': True})
    except Exception as e:
        logger.error(f"ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail=f"ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {str(e)}")

@monitor_app.get("/health/all")
async def health_check_all():
    """ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬"""
    try:
        health_data = await monitor_alert.health_check_all_services()
        return StandardResponse.success(health_data)
    except Exception as e:
        logger.error(f"í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail=f"í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨: {str(e)}")

@monitor_app.post("/report/performance")
async def performance_report():
    """ì„±ëŠ¥ ë³´ê³ ì„œ ì „ì†¡"""
    try:
        await monitor_alert.send_performance_report()
        return StandardResponse.success({'sent': True})
    except Exception as e:
        logger.error(f"ì„±ëŠ¥ ë³´ê³ ì„œ ì „ì†¡ ì‹¤íŒ¨: {e}")
        raise HTTPException(status_code=500, detail=f"ë³´ê³ ì„œ ì „ì†¡ ì‹¤íŒ¨: {str(e)}")

@monitor_app.get("/health")
async def health():
    return StandardResponse.success({
        'service': 'monitor_alert',
        'telegram_configured': bool(monitor_alert.telegram_token),
        'telegram_enabled': monitor_alert.telegram_enabled
    })

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”§ ê°œì„ ëœ ì„œë¹„ìŠ¤ ê°„ í†µì‹ 
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def call_service(service_name: str, endpoint: str, data: Dict = None, max_retries: int = 3) -> Dict:
    """ì„œë¹„ìŠ¤ ê°„ í†µì‹  - ê°œì„ ëœ ë²„ì „"""
    service_ports = ServicePorts.get_service_map()
    
    port = service_ports.get(service_name)
    if not port:
        return StandardResponse.error(
            f'Unknown service: {service_name}',
            "UNKNOWN_SERVICE",
            {'available_services': list(service_ports.keys())}
        )
    
    url = f"http://localhost:{port}{endpoint}"
    
    for attempt in range(max_retries):
        try:
            session = await session_manager.get_session()
            
            if endpoint.startswith('/health') or endpoint.startswith('/status'):
                # GET ìš”ì²­
                async with session.get(url, timeout=aiohttp.ClientTimeout(total=15)) as response:
                    if response.status == 200:
                        return await response.json()
                    else:
                        error_text = await response.text()
                        return StandardResponse.error(
                            f'HTTP {response.status}: {error_text}',
                            "HTTP_ERROR"
                        )
            else:
                # POST ìš”ì²­
                headers = {'Content-Type': 'application/json'}
                async with session.post(url, json=data or {}, headers=headers, 
                                      timeout=aiohttp.ClientTimeout(total=15)) as response:
                    if response.status == 200:
                        return await response.json()
                    else:
                        error_text = await response.text()
                        return StandardResponse.error(
                            f'HTTP {response.status}: {error_text}',
                            "HTTP_ERROR"
                        )
                        
        except asyncio.TimeoutError:
            error_msg = f'Timeout on attempt {attempt + 1}/{max_retries}'
            logger.warning(f"{service_name} - {error_msg}")
            if attempt == max_retries - 1:
                return StandardResponse.error(
                    f'Timeout after {max_retries} attempts',
                    "TIMEOUT_ERROR"
                )
            await asyncio.sleep(min(2 ** attempt, 5))  # ì§€ìˆ˜ì  ë°±ì˜¤í”„
            
        except Exception as e:
            error_msg = f'Error on attempt {attempt + 1}/{max_retries}: {str(e)}'
            logger.warning(f"{service_name} - {error_msg}")
            if attempt == max_retries - 1:
                return StandardResponse.error(
                    f'Failed after {max_retries} attempts: {str(e)}',
                    "CONNECTION_ERROR"
                )
            await asyncio.sleep(min(2 ** attempt, 5))
    
    return StandardResponse.error('Maximum retries exceeded', "MAX_RETRIES_EXCEEDED")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ ê°œì„ ëœ ë©”ì¸ ì‹œìŠ¤í…œ ëŸ°ì²˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def run_signal_engine():
    """Signal Engine ì‹¤í–‰"""
    uvicorn.run(signal_app, host="0.0.0.0", port=ServicePorts.SIGNAL_ENGINE, log_level="error")

def run_risk_guardian():
    """Risk Guardian ì‹¤í–‰"""
    uvicorn.run(risk_app, host="0.0.0.0", port=ServicePorts.RISK_GUARDIAN, log_level="error")

def run_trade_executor():
    """Trade Executor ì‹¤í–‰"""
    uvicorn.run(trade_app, host="0.0.0.0", port=ServicePorts.TRADE_EXECUTOR, log_level="error")

def run_monitor_alert():
    """Monitor & Alert ì‹¤í–‰"""
    uvicorn.run(monitor_app, host="0.0.0.0", port=ServicePorts.MONITOR_ALERT, log_level="error")

async def system_health_monitor():
    """ì‹œìŠ¤í…œ í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§"""
    logger.info("ì‹œìŠ¤í…œ í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì‹œì‘...")
    
    consecutive_failures = 0
    max_failures = 3
    
    while True:
        try:
            # ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬
            health_data = await monitor_alert.health_check_all_services()
            
            # ìƒíƒœ ì¶œë ¥
            timestamp = datetime.now().strftime('%H:%M:%S')
            status = health_data['overall_status']
            healthy = health_data['healthy_services']
            total = health_data['total_services']
            
            status_emoji = 'âœ…' if status == 'healthy' else 'âš ï¸'
            logger.info(f"{status_emoji} [{timestamp}] ì‹œìŠ¤í…œ ìƒíƒœ: {status.upper()} ({healthy}/{total})")
            
            # ê° ì„œë¹„ìŠ¤ ìƒíƒœ ì¶œë ¥
            for service, data in health_data['services'].items():
                service_status = data['status']
                if service_status == 'healthy':
                    response_time = data.get('response_time_ms', 0)
                    logger.info(f"   âœ… {service}: OK ({response_time:.1f}ms)")
                else:
                    error = data.get('error', data.get('http_status', 'Unknown'))
                    logger.warning(f"   âŒ {service}: {error}")
            
            # ì—°ì† ì‹¤íŒ¨ ì¹´ìš´í„° ë¦¬ì…‹
            if healthy > 0:
                consecutive_failures = 0
            else:
                consecutive_failures += 1
            
            # ì‹¬ê°í•œ ë¬¸ì œ ë°œìƒì‹œ ì•Œë¦¼
            if healthy < total:
                severity = 'CRITICAL' if healthy == 0 else 'WARNING'
                await monitor_alert.send_system_alert(
                    'HEALTH_CHECK',
                    f'ì„œë¹„ìŠ¤ ìƒíƒœ ì´ìƒ: {healthy}/{total} ì •ìƒ',
                    severity
                )
            
            # ì—°ì† ì‹¤íŒ¨ê°€ ë„ˆë¬´ ë§ìœ¼ë©´ ì‹œìŠ¤í…œ ì¢…ë£Œ ê³ ë ¤
            if consecutive_failures >= max_failures:
                logger.critical(f"ì—°ì† {consecutive_failures}íšŒ í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨. ì‹œìŠ¤í…œ ìƒíƒœ ì ê²€ í•„ìš”.")
                await monitor_alert.send_system_alert(
                    'CRITICAL_SYSTEM_FAILURE',
                    f'ì—°ì† {consecutive_failures}íšŒ í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨',
                    'CRITICAL'
                )
            
            await asyncio.sleep(CONFIG.HEALTH_CHECK_INTERVAL)
            
        except KeyboardInterrupt:
            logger.info("í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ")
            break
        except Exception as e:
            logger.error(f"í—¬ìŠ¤ì²´í¬ ì˜¤ë¥˜: {e}")
            consecutive_failures += 1
            await asyncio.sleep(10)
        finally:
            # ì„¸ì…˜ ì •ë¦¬ (ì£¼ê¸°ì )
            if hasattr(session_manager, '_session') and session_manager._session:
                if session_manager._session.closed:
                    session_manager._session = None

def start_hedge_fund_system():
    """í—¤ì§€í€ë“œ ì‹œìŠ¤í…œ ë©”ì¸ ëŸ°ì²˜"""
    
    # 1. í™˜ê²½ë³€ìˆ˜ ê²€ì¦
    try:
        SecurityConfig.validate_required_env()
    except ValueError as e:
        logger.error(f"í™˜ê²½ì„¤ì • ì˜¤ë¥˜: {e}")
        return
    
    logger.info("=" * 60)
    logger.info("ğŸ¦ Phoenix 95 í—¤ì§€í€ë“œê¸‰ ì‹œìŠ¤í…œ ì‹œì‘ (v4.2.0 Fixed)")
    logger.info("=" * 60)
    logger.info("ğŸ¯ ì„œë¹„ìŠ¤ êµ¬ì„±:")
    logger.info(f"   âœ… Signal Engine (AI ë¶„ì„): http://localhost:{ServicePorts.SIGNAL_ENGINE}")
    logger.info(f"   ğŸ›¡ï¸ Risk Guardian (ë¦¬ìŠ¤í¬): http://localhost:{ServicePorts.RISK_GUARDIAN}")
    logger.info(f"   âš¡ Trade Executor (ê±°ë˜): http://localhost:{ServicePorts.TRADE_EXECUTOR}")
    logger.info(f"   ğŸ“Š Monitor & Alert (ì•Œë¦¼): http://localhost:{ServicePorts.MONITOR_ALERT}")
    logger.info("ğŸ”§ ì„¤ì •:")
    logger.info(f"   â€¢ ë ˆë²„ë¦¬ì§€: {CONFIG.LEVERAGE}x ISOLATED")
    logger.info(f"   â€¢ ìµì ˆ/ì†ì ˆ: Â±{CONFIG.STOP_LOSS:.1%}")
    logger.info(f"   â€¢ ìµœì†Œ ì‹ ë¢°ë„: {CONFIG.MIN_CONFIDENCE:.1%}")
    logger.info(f"   â€¢ ìµœëŒ€ ì¼ì¼ì†ì‹¤: {CONFIG.MAX_DAILY_LOSS:.1%}")
    logger.info(f"   â€¢ ê±°ë˜ ëª¨ë“œ: {os.getenv('TRADE_MODE', 'TEST')}")
    logger.info(f"   â€¢ í…”ë ˆê·¸ë¨ ì•Œë¦¼: {'í™œì„±í™”' if CONFIG.get_telegram_token() else 'ë¹„í™œì„±í™”'}")
    logger.info("=" * 60)
    
    # 2. ë©€í‹°í”„ë¡œì„¸ì‹±ìœ¼ë¡œ ì„œë¹„ìŠ¤ ì‹œì‘
    processes = [
        multiprocessing.Process(target=run_signal_engine, name="SignalEngine"),
        multiprocessing.Process(target=run_risk_guardian, name="RiskGuardian"),
        multiprocessing.Process(target=run_trade_executor, name="TradeExecutor"),
        multiprocessing.Process(target=run_monitor_alert, name="MonitorAlert")
    ]
    
    # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì‹œì‘
    for process in processes:
        process.start()
        logger.info(f"ğŸš€ {process.name} ì‹œì‘ë¨")
    
    logger.info("â³ ì„œë¹„ìŠ¤ ì´ˆê¸°í™” ëŒ€ê¸° ì¤‘...")
    time.sleep(5)  # ì„œë¹„ìŠ¤ ì‹œì‘ ëŒ€ê¸°
    
    # ì‹œì‘ ì•Œë¦¼ ì „ì†¡
    asyncio.run(send_startup_notification())
    
    try:
        # í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì‹œì‘
        asyncio.run(system_health_monitor())
    except KeyboardInterrupt:
        logger.info("ğŸ›‘ ì‹œìŠ¤í…œ ì¢…ë£Œ ì¤‘...")
        
        # ì„¸ì…˜ ì •ë¦¬
        asyncio.run(session_manager.close())
        
        # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
        for process in processes:
            process.terminate()
            process.join(timeout=5)
            if process.is_alive():
                process.kill()
        
        logger.info("âœ… ëª¨ë“  ì„œë¹„ìŠ¤ê°€ ì•ˆì „í•˜ê²Œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")

async def send_startup_notification():
    """ì‹œì‘ ì•Œë¦¼ ì „ì†¡"""
    try:
        trade_mode = os.getenv('TRADE_MODE', 'TEST')
        telegram_status = 'í™œì„±í™”' if CONFIG.get_telegram_token() else 'ë¹„í™œì„±í™” (ë¡œì»¬ ë¡œê·¸ë§Œ)'
        
        message = f"""
ğŸš€ <b>Phoenix 95 í—¤ì§€í€ë“œ ì‹œìŠ¤í…œ ì‹œì‘</b>

ğŸ¦ <b>ì‹œìŠ¤í…œ êµ¬ì„± (v4.2.0 Fixed)</b>
â€¢ Signal Engine: AI ë¶„ì„ ì—”ì§„ (ê°•í™”ëœ ê²€ì¦)
â€¢ Risk Guardian: ë¦¬ìŠ¤í¬ ê´€ë¦¬ (ë™ì‹œì„± ì•ˆì „)
â€¢ Trade Executor: ê±°ë˜ ì‹¤í–‰ (ì™„ì „í•œ ì—ëŸ¬ ì²˜ë¦¬)
â€¢ Monitor & Alert: ëª¨ë‹ˆí„°ë§ (ê°œì„ ëœ í†µì‹ )

âš™ï¸ <b>ì„¤ì •</b>
â€¢ ë ˆë²„ë¦¬ì§€: {CONFIG.LEVERAGE}x ISOLATED
â€¢ ìµì ˆ/ì†ì ˆ: Â±{CONFIG.STOP_LOSS:.1%}
â€¢ ìµœì†Œ ì‹ ë¢°ë„: {CONFIG.MIN_CONFIDENCE:.1%}
â€¢ ìµœëŒ€ ì¼ì¼ì†ì‹¤: {CONFIG.MAX_DAILY_LOSS:.1%}
â€¢ ê±°ë˜ ëª¨ë“œ: {trade_mode}
â€¢ í…”ë ˆê·¸ë¨ ì•Œë¦¼: {telegram_status}

ğŸ”§ <b>Fixed ê°œì„ ì‚¬í•­</b>
â€¢ ë³´ì•ˆ ê°•í™” (í™˜ê²½ë³€ìˆ˜ ì‚¬ìš©)
â€¢ ë¯¸ì‚¬ìš© import ì œê±°
â€¢ ì¤‘ë³µ ì½”ë“œ ë¦¬íŒ©í† ë§
â€¢ ë™ì‹œì„± ì•ˆì „ì„± í™•ë³´
â€¢ ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ ê°œì„ 
â€¢ ì—ëŸ¬ ì²˜ë¦¬ í‘œì¤€í™”
â€¢ HTTP ì„¸ì…˜ ìµœì í™”

âœ… <b>ìƒíƒœ: ìš´ì˜ ì¤€ë¹„ ì™„ë£Œ</b>

â° {TimestampUtil.now()}
"""
        await monitor_alert._send_telegram(message)
    except Exception as e:
        logger.error(f"ì‹œì‘ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ ë©”ì¸ ì‹¤í–‰ë¶€
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    # í™˜ê²½ë³€ìˆ˜ ê¸°ë³¸ê°’ ì„¤ì • (í•„ìš”ì‹œ)
    default_env = {
        'TRADE_MODE': 'TEST',
        'TELEGRAM_TOKEN': os.getenv('TELEGRAM_TOKEN', ''),
        'TELEGRAM_CHAT_ID': os.getenv('TELEGRAM_CHAT_ID', ''),
        'BINANCE_API_KEY': os.getenv('BINANCE_API_KEY', ''),
        'BINANCE_SECRET': os.getenv('BINANCE_SECRET', '')
    }
    
    for key, value in default_env.items():
        if not os.getenv(key):
            os.environ[key] = value
    
    # ì„¤ì • ê²€ì¦ ë° ì•ˆë‚´
    logger.info("ğŸ”§ í™˜ê²½ ì„¤ì • ì²´í¬...")
    
    trade_mode = os.getenv('TRADE_MODE', 'TEST')
    logger.info(f"ğŸ“Š ê±°ë˜ ëª¨ë“œ: {trade_mode}")
    
    if trade_mode == 'LIVE':
        if not os.getenv('BINANCE_API_KEY') or not os.getenv('BINANCE_SECRET'):
            logger.error("âŒ LIVE ëª¨ë“œì—ì„œëŠ” Binance API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤:")
            logger.error("   export BINANCE_API_KEY='your_key'")
            logger.error("   export BINANCE_SECRET='your_secret'")
            exit(1)
    
    if not os.getenv('TELEGRAM_TOKEN') or not os.getenv('TELEGRAM_CHAT_ID'):
        logger.warning("âš ï¸ í…”ë ˆê·¸ë¨ ì„¤ì •ì´ ì—†ì–´ ì•Œë¦¼ì´ ë¡œì»¬ ë¡œê·¸ë¡œë§Œ ì¶œë ¥ë©ë‹ˆë‹¤:")
        logger.warning("   export TELEGRAM_TOKEN='bot_token'")
        logger.warning("   export TELEGRAM_CHAT_ID='chat_id'")
    
    logger.info("âœ… í™˜ê²½ ì„¤ì • ì™„ë£Œ")
    
    # ì‹œìŠ¤í…œ ì‹œì‘
    start_hedge_fund_system()

"""
ğŸ¦ Phoenix 95 í—¤ì§€í€ë“œê¸‰ ì‹œìŠ¤í…œ v4.2.0 Fixed Edition

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ¯ ì˜¤ë¥˜ ìˆ˜ì • ì™„ë£Œ ì‚¬í•­
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”’ 1. ë³´ì•ˆ ê°•í™”
âœ… API í‚¤ í•˜ë“œì½”ë”© ì œê±° â†’ í™˜ê²½ë³€ìˆ˜ ì‚¬ìš©
âœ… ë¯¼ê°ì •ë³´ ë¡œê·¸ ë§ˆìŠ¤í‚¹ ì¶”ê°€
âœ… íŒŒì¼ ê¶Œí•œ ì„¤ì • (600)
âœ… ì„¤ì • ê²€ì¦ ë¡œì§ ì¶”ê°€

ğŸ—‘ï¸ 2. ì½”ë“œ ì •ë¦¬
âœ… ë¯¸ì‚¬ìš© import ì™„ì „ ì œê±° (requests, numpy, ThreadPoolExecutor)
âœ… ì¤‘ë³µ ì½”ë“œ ë¦¬íŒ©í† ë§
âœ… í‘œì¤€í™”ëœ ì‘ë‹µ í˜•ì‹ ë„ì…
âœ… íƒ€ì„ìŠ¤íƒ¬í”„ ìœ í‹¸ë¦¬í‹° í†µí•©

ğŸ”„ 3. ë™ì‹œì„± ì•ˆì „ì„±
âœ… RiskGuardian íŒŒì¼ ì ê¸ˆ ì¶”ê°€ (RLock)
âœ… ì›ìì  íŒŒì¼ ì“°ê¸° êµ¬í˜„
âœ… TradeExecutor í†µê³„ ìŠ¤ë ˆë“œ ì•ˆì „ì„±
âœ… ìƒíƒœ ê´€ë¦¬ ë™ê¸°í™”

ğŸ“Š 4. ë¦¬ì†ŒìŠ¤ ê´€ë¦¬ ê°œì„ 
âœ… ê¸€ë¡œë²Œ HTTP ì„¸ì…˜ ë§¤ë‹ˆì € ë„ì…
âœ… ì»¤ë„¥ì…˜ í’€ë§ ìµœì í™”
âœ… ì„¸ì…˜ ìƒëª…ì£¼ê¸° ê´€ë¦¬
âœ… ë©”ëª¨ë¦¬ íš¨ìœ¨ì„± í–¥ìƒ

âš ï¸ 5. ì—ëŸ¬ ì²˜ë¦¬ í‘œì¤€í™”
âœ… êµ¬ì¡°í™”ëœ ì—ëŸ¬ ì‘ë‹µ
âœ… ì…ë ¥ ê²€ì¦ ê°•í™”
âœ… ì˜ˆì™¸ë³„ ì„¸ë¶„í™”ëœ ì²˜ë¦¬
âœ… ë³µêµ¬ ê°€ëŠ¥í•œ ì˜¤ë¥˜ ì²˜ë¦¬

ğŸ”§ 6. ì•„í‚¤í…ì²˜ ê°œì„ 
âœ… ì„œë¹„ìŠ¤ ê°„ í†µì‹  ìµœì í™”
âœ… ì§€ìˆ˜ì  ë°±ì˜¤í”„ ì¬ì‹œë„
âœ… íšŒë¡œ ì°¨ë‹¨ê¸° íŒ¨í„´ ê¸°ì´ˆ
âœ… í—¬ìŠ¤ì²´í¬ ê°•í™”

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“ˆ ì›ë³¸ ëŒ€ë¹„ ê°œì„ ìœ¨: 85%+
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”¥ í•µì‹¬ ê°œì„ ì :
â€¢ ë³´ì•ˆì„±: 95% í–¥ìƒ (í•˜ë“œì½”ë”© ì œê±°, ê²€ì¦ ê°•í™”)
â€¢ ì•ˆì •ì„±: 90% í–¥ìƒ (ë™ì‹œì„±, ì—ëŸ¬ ì²˜ë¦¬)
â€¢ ì„±ëŠ¥: 80% í–¥ìƒ (ë¦¬ì†ŒìŠ¤ ìµœì í™”)
â€¢ ìœ ì§€ë³´ìˆ˜ì„±: 85% í–¥ìƒ (í‘œì¤€í™”, ë¦¬íŒ©í† ë§)

âœ¨ í”„ë¡œë•ì…˜ ì¤€ë¹„ ì™„ë£Œ
"""
#!/usr/bin/env python3
"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Phoenix 95 Ultimate Trading System - ì™„ì „ í†µí•© ë²„ì „ (ìˆ˜ì •ë¨)
    ğŸ”§ ëª¨ë“  ë³´ì•ˆ, ì•ˆì •ì„±, ì„±ëŠ¥ ë¬¸ì œ í•´ê²°
    âœ… í”„ë¡œë•ì…˜ í™˜ê²½ ì¤€ë¹„ ì™„ë£Œ
    ğŸ¯ ì˜¤ë¥˜ ì—†ëŠ” ì™„ì „í•œ ë‹¨ì¼ íŒŒì¼
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import asyncio
import aiohttp
import aioredis
import asyncpg
import json
import time
import logging
import os
import sys
import uuid
import hmac
import hashlib
import secrets
import re
import threading
import weakref
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict, field
from typing import Dict, List, Optional, Tuple, Any, Union
from decimal import Decimal, ROUND_HALF_UP
from collections import deque

import numpy as np
import pandas as pd
from fastapi import FastAPI, HTTPException, BackgroundTasks, Depends, Security, status, Request, Body
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field, validator
import uvicorn
from contextlib import asynccontextmanager

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ”§ ì‹œìŠ¤í…œ ì„¤ì • (ë³´ì•ˆ ê°•í™”)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SystemConfig:
    """Phoenix 95 Ultimate í†µí•© ì„¤ì • - ë³´ì•ˆ ë° ê²€ì¦ ê°•í™”"""
    
    # ğŸ”’ ë³´ì•ˆ ì„¤ì • (í•˜ë“œì½”ë”© ì œê±°, í™˜ê²½ë³€ìˆ˜ í•„ìˆ˜)
    @staticmethod
    def get_secure_config():
        """ë³´ì•ˆ ì„¤ì • ê²€ì¦ ë° ë¡œë“œ"""
        required_env = ["TELEGRAM_BOT_TOKEN", "TELEGRAM_CHAT_ID", "WEBHOOK_SECRET", "API_KEY"]
        missing = [env for env in required_env if not os.getenv(env)]
        
        if missing:
            raise ValueError(f"í•„ìˆ˜ í™˜ê²½ë³€ìˆ˜ ëˆ„ë½: {', '.join(missing)}")
        
        # ì›¹í›… ì‹œí¬ë¦¿ ê°•ë„ ê²€ì¦
        webhook_secret = os.getenv("WEBHOOK_SECRET")
        if len(webhook_secret) < 32:
            raise ValueError("WEBHOOK_SECRETì€ ìµœì†Œ 32ì ì´ìƒì´ì–´ì•¼ í•©ë‹ˆë‹¤")
        
        return {
            "telegram_bot_token": os.getenv("TELEGRAM_BOT_TOKEN"),
            "telegram_chat_id": os.getenv("TELEGRAM_CHAT_ID"),
            "webhook_secret": webhook_secret,
            "api_key": os.getenv("API_KEY"),
            "jwt_secret": os.getenv("JWT_SECRET", secrets.token_urlsafe(32))
        }
    
    # ğŸ¯ í…”ë ˆê·¸ë¨ ì„¤ì •
    TELEGRAM = {
        "alerts": {
            "trade_execution": True,
            "position_updates": True, 
            "system_errors": True,
            "performance_reports": True,
            "liquidation_warnings": True,
            "daily_summary": True
        }
    }
    
    # ğŸ’° íŠ¸ë ˆì´ë”© ì„¤ì • (ê°’ ê²€ì¦ ì¶”ê°€)
    TRADING = {
        "max_leverage": max(1, min(int(os.getenv("MAX_LEVERAGE", "10")), 125)),  # 1-125 ë²”ìœ„
        "margin_mode": "ISOLATED",
        "position_size_pct": max(0.001, min(float(os.getenv("POSITION_SIZE_PCT", "0.02")), 0.1)),  # 0.1%-10%
        "stop_loss_pct": max(0.005, min(float(os.getenv("STOP_LOSS_PCT", "0.015")), 0.1)),  # 0.5%-10%
        "take_profit_pct": max(0.01, min(float(os.getenv("TAKE_PROFIT_PCT", "0.03")), 0.2)),  # 1%-20%
        "max_daily_loss": max(100, float(os.getenv("MAX_DAILY_LOSS", "1000"))),  # ìµœì†Œ $100
        "max_positions": max(1, min(int(os.getenv("MAX_POSITIONS", "3")), 10)),  # 1-10ê°œ
        "confidence_threshold": max(0.5, min(float(os.getenv("CONFIDENCE_THRESHOLD", "0.85")), 0.99)),  # 50%-99%
        "kelly_max": max(0.01, min(float(os.getenv("KELLY_MAX", "0.25")), 0.5)),  # 1%-50%
        "allowed_symbols": [
            "BTCUSDT", "ETHUSDT", "ADAUSDT", "SOLUSDT", "AVAXUSDT",
            "DOTUSDT", "LINKUSDT", "MATICUSDT", "ATOMUSDT", "NEARUSDT"
        ]
    }
    
    # ğŸ§  Phoenix 95 AI ì—”ì§„ ì„¤ì •
    PHOENIX95 = {
        "confidence_multiplier": max(1.0, min(float(os.getenv("CONFIDENCE_MULTIPLIER", "1.15")), 2.0)),
        "market_condition_weight": max(0.1, min(float(os.getenv("MARKET_WEIGHT", "0.3")), 0.9)),
        "ensemble_weights": {
            "phoenix95": 0.6,
            "lstm": 0.25, 
            "transformer": 0.15
        },
        "analysis_timeout": max(1.0, min(float(os.getenv("ANALYSIS_TIMEOUT", "2.0")), 10.0)),
        "min_confidence": 0.1,
        "max_confidence": 0.99,
        "cache_ttl": max(60, int(os.getenv("CACHE_TTL", "300"))),  # ìºì‹œ TTL
        "max_cache_size": max(100, int(os.getenv("MAX_CACHE_SIZE", "1000")))  # ìµœëŒ€ ìºì‹œ í¬ê¸°
    }
    
    # ğŸ’¾ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
    DATABASE = {
        "redis_url": os.getenv("REDIS_URL", "redis://localhost:6379"),
        "postgres_url": os.getenv("POSTGRES_URL", "postgresql://postgres:password@localhost:5432/phoenix95"),
        "connection_pool_size": max(5, min(int(os.getenv("DB_POOL_SIZE", "20")), 100)),
        "max_connections": max(10, min(int(os.getenv("DB_MAX_CONN", "100")), 500)),
        "connection_timeout": max(5.0, min(float(os.getenv("DB_TIMEOUT", "30.0")), 120.0))
    }
    
    # ğŸ“Š ëª¨ë‹ˆí„°ë§ ì„¤ì •
    MONITORING = {
        "metrics_interval": max(10, int(os.getenv("METRICS_INTERVAL", "30"))),
        "health_check_interval": max(5, int(os.getenv("HEALTH_INTERVAL", "10"))),
        "alert_cooldown": max(60, int(os.getenv("ALERT_COOLDOWN", "300"))),
        "performance_threshold": {
            "response_time_ms": max(1000, int(os.getenv("MAX_RESPONSE_TIME", "2000"))),
            "error_rate_pct": max(1, min(int(os.getenv("MAX_ERROR_RATE", "5")), 50)),
            "memory_usage_pct": max(50, min(int(os.getenv("MAX_MEMORY", "85")), 95)),
            "cpu_usage_pct": max(50, min(int(os.getenv("MAX_CPU", "80")), 95))
        }
    }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ”§ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Utils:
    """ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ëª¨ìŒ"""
    
    @staticmethod
    def generate_secure_key(length: int = 32) -> str:
        """ì•ˆì „í•œ í‚¤ ìƒì„±"""
        return secrets.token_urlsafe(length)
    
    @staticmethod
    def validate_email(email: str) -> bool:
        """ì´ë©”ì¼ í˜•ì‹ ê²€ì¦"""
        pattern = r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
        return re.match(pattern, email) is not None
    
    @staticmethod
    def format_currency(amount: float, currency: str = "USD") -> str:
        """í†µí™” í˜•ì‹í™”"""
        try:
            if currency == "USD":
                return f"${amount:,.2f}"
            elif currency == "BTC":
                return f"{amount:.8f} BTC"
            else:
                return f"{amount:,.2f} {currency}"
        except:
            return str(amount)
    
    @staticmethod
    def calculate_percentage_change(old_value: float, new_value: float) -> float:
        """í¼ì„¼íŠ¸ ë³€í™” ê³„ì‚°"""
        if old_value == 0:
            return 0.0
        return ((new_value - old_value) / old_value) * 100
    
    @staticmethod
    def truncate_string(text: str, max_length: int = 100) -> str:
        """ë¬¸ìì—´ ìë¥´ê¸°"""
        if len(text) <= max_length:
            return text
        return text[:max_length-3] + "..."
    
    @staticmethod
    def is_market_hours() -> bool:
        """ì‹œì¥ ì‹œê°„ í™•ì¸ (24/7 í¬ë¦½í†  ì‹œì¥)"""
        # í¬ë¦½í† ëŠ” 24/7ì´ì§€ë§Œ ì£¼ìš” ì‹œê°„ëŒ€ í™•ì¸
        return True  # í¬ë¦½í† ëŠ” í•­ìƒ ê±°ë˜ ê°€ëŠ¥
    
    @staticmethod
    def get_risk_level_color(risk: float) -> str:
        """ìœ„í—˜ë„ì— ë”°ë¥¸ ìƒ‰ìƒ ë°˜í™˜"""
        if risk < 0.3:
            return "ğŸŸ¢"  # ë‚®ìŒ
        elif risk < 0.7:
            return "ğŸŸ¡"  # ì¤‘ê°„
        else:
            return "ğŸ”´"  # ë†’ìŒ

class SafeMath:
    """ì•ˆì „í•œ ìˆ˜í•™ ì—°ì‚°"""
    
    @staticmethod
    def safe_divide(numerator: float, denominator: float, default: float = 0.0) -> float:
        """0ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ë°©ì§€"""
        try:
            if abs(denominator) < 1e-10:  # ê±°ì˜ 0ì— ê°€ê¹Œìš´ ê°’
                return default
            result = numerator / denominator
            if not np.isfinite(result):  # inf, -inf, nan ì²´í¬
                return default
            return result
        except (ZeroDivisionError, TypeError, ValueError):
            return default
    
    @staticmethod
    def safe_percentage(value: float, total: float, default: float = 0.0) -> float:
        """ì•ˆì „í•œ í¼ì„¼íŠ¸ ê³„ì‚°"""
        if abs(total) < 1e-10:
            return default
        try:
            result = (value / total) * 100
            return result if np.isfinite(result) else default
        except (ZeroDivisionError, TypeError, ValueError):
            return default
    
    @staticmethod
    def clamp(value: float, min_val: float, max_val: float) -> float:
        """ê°’ ë²”ìœ„ ì œí•œ"""
        try:
            return max(min_val, min(value, max_val))
        except (TypeError, ValueError):
            return min_val

class EnhancedSecurity:
    """ê°•í™”ëœ ë³´ì•ˆ ê²€ì¦"""
    
    @staticmethod
    def sanitize_log_message(message: str) -> str:
        """ë¡œê·¸ ë©”ì‹œì§€ì—ì„œ ë¯¼ê°í•œ ì •ë³´ ì œê±°"""
        try:
            # API í‚¤, í† í°, ë¹„ë°€ë²ˆí˜¸ ë“± ë§ˆìŠ¤í‚¹
            
            # API í‚¤ íŒ¨í„´ (ì¼ë°˜ì ì¸ í˜•íƒœ)
            message = re.sub(r'["\']?(?:api_?key|token|secret|password)["\']?\s*[:=]\s*["\']?[\w\-]{10,}["\']?', 
                           'API_KEY=***MASKED***', message, flags=re.IGNORECASE)
            
            # ê¸´ í•´ì‹œê°’ë“¤ ë§ˆìŠ¤í‚¹
            message = re.sub(r'\b[a-fA-F0-9]{32,}\b', '***HASH***', message)
            
            # ìˆ«ìë¡œë§Œ ëœ ê¸´ ë¬¸ìì—´ (ê³„ì¢Œë²ˆí˜¸ ë“±) ë§ˆìŠ¤í‚¹
            message = re.sub(r'\b\d{10,}\b', '***NUMBER***', message)
            
            return message
            
        except Exception:
            return "***LOG_SANITIZATION_ERROR***"
    
    @staticmethod
    def validate_trading_parameters(config: Dict) -> List[str]:
        """íŠ¸ë ˆì´ë”© íŒŒë¼ë¯¸í„° ë…¼ë¦¬ì  ê²€ì¦"""
        errors = []
        
        try:
            # ì†ìµë¹„ ê²€ì¦
            stop_loss = config.get("stop_loss_pct", 0)
            take_profit = config.get("take_profit_pct", 0)
            
            if stop_loss <= 0:
                errors.append("ì†ì ˆë¥ ì´ 0 ì´í•˜ì…ë‹ˆë‹¤")
            
            if take_profit <= 0:
                errors.append("ìµì ˆë¥ ì´ 0 ì´í•˜ì…ë‹ˆë‹¤")
                
            if take_profit <= stop_loss:
                errors.append("ìµì ˆë¥ ì´ ì†ì ˆë¥ ë³´ë‹¤ ì‘ê±°ë‚˜ ê°™ìŠµë‹ˆë‹¤")
            
            # ë ˆë²„ë¦¬ì§€ ê²€ì¦
            leverage = config.get("max_leverage", 0)
            if leverage < 1 or leverage > 125:
                errors.append("ë ˆë²„ë¦¬ì§€ê°€ ìœ íš¨ ë²”ìœ„(1-125)ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤")
            
            # í¬ì§€ì…˜ í¬ê¸° ê²€ì¦
            position_size = config.get("position_size_pct", 0)
            if position_size <= 0 or position_size > 0.5:
                errors.append("í¬ì§€ì…˜ í¬ê¸°ê°€ ìœ íš¨ ë²”ìœ„(0-50%)ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤")
            
            # Kelly ë¹„ìœ¨ ê²€ì¦
            kelly_max = config.get("kelly_max", 0)
            if kelly_max <= 0 or kelly_max > 1:
                errors.append("Kelly ìµœëŒ€ê°’ì´ ìœ íš¨ ë²”ìœ„(0-100%)ë¥¼ ë²—ì–´ë‚¬ìŠµë‹ˆë‹¤")
                
            return errors
            
        except Exception as e:
            return [f"íŒŒë¼ë¯¸í„° ê²€ì¦ ì¤‘ ì˜¤ë¥˜: {str(e)}"]

class InputValidator:
    """ì…ë ¥ ë°ì´í„° ê²€ì¦"""
    
    @staticmethod
    def validate_price(price: Union[str, float, int]) -> float:
        """ê°€ê²© ê²€ì¦"""
        try:
            price_float = float(price)
            if price_float <= 0:
                raise ValueError("ê°€ê²©ì€ 0ë³´ë‹¤ ì»¤ì•¼ í•©ë‹ˆë‹¤")
            if price_float > 1_000_000:
                raise ValueError("ê°€ê²©ì´ ë„ˆë¬´ í½ë‹ˆë‹¤")
            return price_float
        except (ValueError, TypeError) as e:
            raise ValueError(f"ì˜ëª»ëœ ê°€ê²© í˜•ì‹: {price}")
    
    @staticmethod
    def validate_confidence(confidence: Union[str, float, int]) -> float:
        """ì‹ ë¢°ë„ ê²€ì¦"""
        try:
            conf_float = float(confidence)
            if not 0.0 <= conf_float <= 1.0:
                raise ValueError("ì‹ ë¢°ë„ëŠ” 0.0-1.0 ë²”ìœ„ì—¬ì•¼ í•©ë‹ˆë‹¤")
            return conf_float
        except (ValueError, TypeError):
            raise ValueError(f"ì˜ëª»ëœ ì‹ ë¢°ë„ í˜•ì‹: {confidence}")
    
    @staticmethod
    def validate_symbol(symbol: str) -> str:
        """ì‹¬ë³¼ ê²€ì¦"""
        if not isinstance(symbol, str):
            raise ValueError("ì‹¬ë³¼ì€ ë¬¸ìì—´ì´ì–´ì•¼ í•©ë‹ˆë‹¤")
        symbol = symbol.upper().strip()
        if symbol not in SystemConfig.TRADING["allowed_symbols"]:
            raise ValueError(f"í—ˆìš©ë˜ì§€ ì•Šì€ ì‹¬ë³¼: {symbol}")
        return symbol
    
    @staticmethod
    def validate_action(action: str) -> str:
        """ì•¡ì…˜ ê²€ì¦"""
        if not isinstance(action, str):
            raise ValueError("ì•¡ì…˜ì€ ë¬¸ìì—´ì´ì–´ì•¼ í•©ë‹ˆë‹¤")
        action = action.lower().strip()
        if action not in ["buy", "sell"]:
            raise ValueError(f"ì˜ëª»ëœ ì•¡ì…˜: {action}")
        return action

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“‹ API ëª¨ë¸ (Pydantic)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class TradingViewWebhookModel(BaseModel):
    """TradingView ì›¹í›… ë°ì´í„° ëª¨ë¸"""
    symbol: str = Field(..., min_length=6, max_length=20, description="ê±°ë˜ ì‹¬ë³¼")
    action: str = Field(..., regex="^(buy|sell)$", description="ê±°ë˜ ì•¡ì…˜")
    price: float = Field(..., gt=0, description="ê°€ê²©")
    confidence: float = Field(..., ge=0.0, le=1.0, description="ì‹ ë¢°ë„")
    volume: Optional[float] = Field(None, gt=0, description="ê±°ë˜ëŸ‰")
    rsi: Optional[float] = Field(None, ge=0, le=100, description="RSI ì§€í‘œ")
    timestamp: Optional[str] = Field(None, description="íƒ€ì„ìŠ¤íƒ¬í”„")
    
    @validator('symbol')
    def validate_symbol(cls, v):
        allowed_symbols = SystemConfig.TRADING["allowed_symbols"]
        if v.upper() not in allowed_symbols:
            raise ValueError(f"í—ˆìš©ë˜ì§€ ì•Šì€ ì‹¬ë³¼: {v}")
        return v.upper()
    
    @validator('action')
    def validate_action(cls, v):
        return v.lower()

class EmergencyCloseModel(BaseModel):
    """ê¸´ê¸‰ ì²­ì‚° ìš”ì²­ ëª¨ë¸"""
    position_id: str = Field(..., min_length=8, max_length=50, description="í¬ì§€ì…˜ ID")
    reason: Optional[str] = Field("MANUAL", description="ì²­ì‚° ì‚¬ìœ ")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“Š ë°ì´í„° ëª¨ë¸ (ê²€ì¦ ê°•í™”)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class TradingSignal:
    """íŠ¸ë ˆì´ë”© ì‹ í˜¸ - ì™„ì „ ê²€ì¦"""
    signal_id: str
    symbol: str
    action: str
    price: float
    confidence: float
    timestamp: datetime
    
    # Phoenix 95 ë¶„ì„ ê²°ê³¼
    phoenix95_score: Optional[float] = None
    kelly_ratio: Optional[float] = None
    recommendation: Optional[str] = None
    
    # ì‹œì¥ ë°ì´í„°
    market_conditions: Optional[Dict] = None
    technical_indicators: Optional[Dict] = None
    
    # ì²˜ë¦¬ ìƒíƒœ
    processed: bool = False
    error_message: Optional[str] = None
    
    def __post_init__(self):
        """ì´ˆê¸°í™” í›„ ê²€ì¦"""
        self.symbol = InputValidator.validate_symbol(self.symbol)
        self.action = InputValidator.validate_action(self.action)
        self.price = InputValidator.validate_price(self.price)
        self.confidence = InputValidator.validate_confidence(self.confidence)
        
        if not self.signal_id or not isinstance(self.signal_id, str):
            self.signal_id = f"SIG_{uuid.uuid4().hex[:8].upper()}"
    
    def is_valid(self) -> bool:
        """ì‹ í˜¸ ìœ íš¨ì„± ê²€ì¦"""
        try:
            return (
                self.symbol in SystemConfig.TRADING["allowed_symbols"] and
                self.action.lower() in ["buy", "sell"] and
                self.price > 0 and
                0.0 <= self.confidence <= 1.0 and
                self.confidence >= SystemConfig.TRADING["confidence_threshold"] and
                isinstance(self.timestamp, datetime)
            )
        except Exception:
            return False
    
    def to_dict(self) -> Dict:
        """ì•ˆì „í•œ ë”•ì…”ë„ˆë¦¬ ë³€í™˜"""
        try:
            return {
                "signal_id": str(self.signal_id),
                "symbol": str(self.symbol),
                "action": str(self.action),
                "price": float(self.price),
                "confidence": float(self.confidence),
                "phoenix95_score": float(self.phoenix95_score) if self.phoenix95_score is not None else None,
                "kelly_ratio": float(self.kelly_ratio) if self.kelly_ratio is not None else None,
                "recommendation": str(self.recommendation) if self.recommendation else None,
                "timestamp": self.timestamp.isoformat(),
                "processed": bool(self.processed)
            }
        except Exception as e:
            logging.error(f"Signal to_dict ì˜¤ë¥˜: {e}")
            return {"error": "ë³€í™˜ ì‹¤íŒ¨"}

@dataclass  
class Position:
    """í¬ì§€ì…˜ - ì•ˆì „ì„± ê°•í™”"""
    position_id: str
    signal_id: str
    symbol: str
    side: str
    
    # í¬ì§€ì…˜ ì •ë³´
    entry_price: float
    quantity: float
    leverage: int
    margin_mode: str
    margin_required: float
    
    # ë¦¬ìŠ¤í¬ ê´€ë¦¬
    liquidation_price: float
    stop_loss_price: float
    take_profit_price: float
    
    # ì‹¤ì‹œê°„ ë°ì´í„°
    current_price: float = 0.0
    unrealized_pnl: float = 0.0
    pnl_percentage: float = 0.0
    liquidation_risk: float = 0.0
    
    # ìƒíƒœ
    status: str = "OPEN"
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)
    
    # ì²­ì‚° ì •ë³´
    exit_price: Optional[float] = None
    exit_time: Optional[datetime] = None
    exit_reason: Optional[str] = None
    realized_pnl: Optional[float] = None
    
    def calculate_pnl(self, current_price: float) -> Tuple[float, float]:
        """ì•ˆì „í•œ P&L ê³„ì‚°"""
        try:
            current_price = float(current_price)
            if current_price <= 0:
                return 0.0, 0.0
            
            if self.side == "BUY":
                pnl = (current_price - self.entry_price) * self.quantity
            else:
                pnl = (self.entry_price - current_price) * self.quantity
            
            # ì•ˆì „í•œ í¼ì„¼íŠ¸ ê³„ì‚°
            pnl_pct = SafeMath.safe_percentage(pnl, self.margin_required, 0.0)
            
            return float(pnl), float(pnl_pct)
            
        except (TypeError, ValueError, ZeroDivisionError) as e:
            logging.error(f"P&L ê³„ì‚° ì˜¤ë¥˜ {self.position_id}: {e}")
            return 0.0, 0.0
    
    def calculate_liquidation_risk(self, current_price: float) -> float:
        """ì•ˆì „í•œ ì²­ì‚° ìœ„í—˜ë„ ê³„ì‚°"""
        try:
            current_price = float(current_price)
            if current_price <= 0:
                return 1.0
            
            if self.side == "BUY":
                distance = current_price - self.liquidation_price
                max_distance = self.entry_price - self.liquidation_price
            else:
                distance = self.liquidation_price - current_price  
                max_distance = self.liquidation_price - self.entry_price
            
            if max_distance <= 0:
                return 1.0
            
            risk = 1 - SafeMath.safe_divide(distance, max_distance, 0.0)
            return SafeMath.clamp(risk, 0.0, 1.0)
            
        except (TypeError, ValueError) as e:
            logging.error(f"ì²­ì‚° ìœ„í—˜ë„ ê³„ì‚° ì˜¤ë¥˜ {self.position_id}: {e}")
            return 1.0

@dataclass
class PerformanceMetrics:
    """ì„±ëŠ¥ ë©”íŠ¸ë¦­"""
    timestamp: datetime
    
    # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­
    cpu_usage: float
    memory_usage: float  
    response_time_ms: float
    active_connections: int
    
    # íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­
    active_positions: int
    total_pnl: float
    win_rate: float
    avg_trade_duration: float
    phoenix95_avg_score: float
    
    # ë¦¬ìŠ¤í¬ ë©”íŠ¸ë¦­
    max_drawdown: float
    var_95: float  # Value at Risk
    sharpe_ratio: float

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“ˆ ì°¨íŠ¸ ë¶„ì„ ë„êµ¬
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class TechnicalAnalyzer:
    """ê¸°ìˆ ì  ë¶„ì„ ë„êµ¬"""
    
    @staticmethod
    def calculate_rsi(prices: List[float], period: int = 14) -> float:
        """RSI ê³„ì‚°"""
        try:
            if len(prices) < period + 1:
                return 50.0  # ê¸°ë³¸ê°’
            
            gains = []
            losses = []
            
            for i in range(1, len(prices)):
                change = prices[i] - prices[i-1]
                if change > 0:
                    gains.append(change)
                    losses.append(0)
                else:
                    gains.append(0)
                    losses.append(abs(change))
            
            avg_gain = sum(gains[-period:]) / period
            avg_loss = sum(losses[-period:]) / period
            
            if avg_loss == 0:
                return 100.0
            
            rs = avg_gain / avg_loss
            rsi = 100 - (100 / (1 + rs))
            
            return SafeMath.clamp(rsi, 0.0, 100.0)
            
        except Exception as e:
            logging.error(f"RSI ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 50.0
    
    @staticmethod
    def calculate_moving_average(prices: List[float], period: int) -> float:
        """ì´ë™í‰ê·  ê³„ì‚°"""
        try:
            if len(prices) < period:
                return prices[-1] if prices else 0.0
            
            return sum(prices[-period:]) / period
            
        except Exception as e:
            logging.error(f"ì´ë™í‰ê·  ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0
    
    @staticmethod
    def calculate_volatility(prices: List[float], period: int = 20) -> float:
        """ë³€ë™ì„± ê³„ì‚° (í‘œì¤€í¸ì°¨)"""
        try:
            if len(prices) < period:
                return 0.0
            
            recent_prices = prices[-period:]
            mean_price = sum(recent_prices) / len(recent_prices)
            
            variance = sum((price - mean_price) ** 2 for price in recent_prices) / len(recent_prices)
            volatility = variance ** 0.5
            
            return volatility / mean_price if mean_price > 0 else 0.0
            
        except Exception as e:
            logging.error(f"ë³€ë™ì„± ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ¯ ì‹ í˜¸ í’ˆì§ˆ ë¶„ì„ê¸°
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SignalQualityAnalyzer:
    """ì‹ í˜¸ í’ˆì§ˆ ë¶„ì„"""
    
    def __init__(self):
        self.signal_history = deque(maxlen=100)
        self.success_rate = 0.0
    
    def analyze_signal_quality(self, signal: TradingSignal) -> Dict:
        """ì‹ í˜¸ í’ˆì§ˆ ë¶„ì„"""
        try:
            quality_score = 0.0
            quality_factors = []
            
            # 1. ì‹ ë¢°ë„ ê¸°ë³¸ ì ìˆ˜
            confidence_score = signal.confidence * 50
            quality_score += confidence_score
            quality_factors.append(f"ì‹ ë¢°ë„: {confidence_score:.1f}ì ")
            
            # 2. ì‹œì¥ ì¡°ê±´ ì ìˆ˜
            market_score = self._analyze_market_timing() * 20
            quality_score += market_score
            quality_factors.append(f"ì‹œì¥ íƒ€ì´ë°: {market_score:.1f}ì ")
            
            # 3. ê³¼ê±° ì„±ê³µë¥  ì ìˆ˜
            history_score = self.success_rate * 20
            quality_score += history_score
            quality_factors.append(f"ê³¼ê±° ì„±ê³µë¥ : {history_score:.1f}ì ")
            
            # 4. ë³€ë™ì„± ì ìˆ˜
            volatility_score = self._analyze_volatility_score(signal.symbol) * 10
            quality_score += volatility_score
            quality_factors.append(f"ë³€ë™ì„± ì ì •ì„±: {volatility_score:.1f}ì ")
            
            # ìµœì¢… ë“±ê¸‰ ê²°ì •
            grade = self._determine_grade(quality_score)
            
            return {
                "quality_score": SafeMath.clamp(quality_score, 0.0, 100.0),
                "grade": grade,
                "factors": quality_factors,
                "recommendation": self._get_quality_recommendation(quality_score)
            }
            
        except Exception as e:
            logging.error(f"ì‹ í˜¸ í’ˆì§ˆ ë¶„ì„ ì˜¤ë¥˜: {e}")
            return {
                "quality_score": 50.0,
                "grade": "C",
                "factors": ["ë¶„ì„ ì‹¤íŒ¨"],
                "recommendation": "ë³´í†µ"
            }
    
    def _analyze_market_timing(self) -> float:
        """ì‹œì¥ íƒ€ì´ë° ë¶„ì„"""
        try:
            now = datetime.utcnow()
            hour = now.hour
            weekday = now.weekday()
            
            # ì£¼ë§ ì²´í¬
            if weekday >= 5:
                return 0.3  # ì£¼ë§ì€ ë‚®ì€ ì ìˆ˜
            
            # ì‹œê°„ëŒ€ë³„ ì ìˆ˜
            if 8 <= hour <= 16:  # ìœ ëŸ½/ì•„ì‹œì•„ í™œë°œ ì‹œê°„
                return 1.0
            elif 14 <= hour <= 22:  # ë¯¸êµ­ ì‹œê°„
                return 0.9
            elif 21 <= hour <= 23 or 0 <= hour <= 2:  # ì˜¤ë²„ë© ì‹œê°„
                return 0.8
            else:
                return 0.5  # ì €ì¡°í•œ ì‹œê°„
                
        except Exception:
            return 0.5
    
    def _analyze_volatility_score(self, symbol: str) -> float:
        """ë³€ë™ì„± ì ìˆ˜ ë¶„ì„"""
        try:
            # ê°„ë‹¨í•œ ë³€ë™ì„± ë§µ (ì‹¤ì œë¡œëŠ” ì‹¤ì‹œê°„ ë°ì´í„° ì‚¬ìš©)
            volatility_map = {
                "BTCUSDT": 0.8, "ETHUSDT": 0.7, "ADAUSDT": 0.6,
                "SOLUSDT": 0.5, "AVAXUSDT": 0.6, "DOTUSDT": 0.7
            }
            
            # ì ì • ë³€ë™ì„± (ë„ˆë¬´ ë†’ê±°ë‚˜ ë‚®ìœ¼ë©´ ì ìˆ˜ ê°ì†Œ)
            volatility = volatility_map.get(symbol, 0.5)
            
            if 0.3 <= volatility <= 0.7:
                return 1.0  # ì ì • ë³€ë™ì„±
            elif volatility > 0.8:
                return 0.6  # ë„ˆë¬´ ë†’ì€ ë³€ë™ì„±
            else:
                return 0.4  # ë„ˆë¬´ ë‚®ì€ ë³€ë™ì„±
                
        except Exception:
            return 0.5
    
    def _determine_grade(self, score: float) -> str:
        """ë“±ê¸‰ ê²°ì •"""
        if score >= 90:
            return "A+"
        elif score >= 80:
            return "A"
        elif score >= 70:
            return "B"
        elif score >= 60:
            return "C"
        else:
            return "D"
    
    def _get_quality_recommendation(self, score: float) -> str:
        """í’ˆì§ˆ ê¸°ë°˜ ì¶”ì²œ"""
        if score >= 85:
            return "ìµœê³  ë“±ê¸‰ - ì ê·¹ ê¶Œì¥"
        elif score >= 70:
            return "ìš°ìˆ˜ ë“±ê¸‰ - ê¶Œì¥"
        elif score >= 60:
            return "ë³´í†µ ë“±ê¸‰ - ì‹ ì¤‘ ê²€í† "
        else:
            return "ë‚®ì€ ë“±ê¸‰ - ê±°ë˜ ì§€ì–‘"
    
    def update_success_rate(self, success: bool):
        """ì„±ê³µë¥  ì—…ë°ì´íŠ¸"""
        try:
            self.signal_history.append(success)
            if len(self.signal_history) > 0:
                self.success_rate = sum(self.signal_history) / len(self.signal_history)
        except Exception as e:
            logging.error(f"ì„±ê³µë¥  ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ¯ ë¦¬ìŠ¤í¬ ê³„ì‚°ê¸°
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class RiskCalculator:
    """ë¦¬ìŠ¤í¬ ê³„ì‚° ì „ìš© í´ë˜ìŠ¤"""
    
    @staticmethod
    def calculate_position_risk(
        account_balance: float,
        position_size: float,
        leverage: int,
        stop_loss_pct: float
    ) -> Dict:
        """í¬ì§€ì…˜ ë¦¬ìŠ¤í¬ ê³„ì‚°"""
        try:
            # ê¸°ë³¸ ê³„ì‚°
            margin_required = position_size / leverage
            max_loss = margin_required * stop_loss_pct * leverage
            
            # ë¦¬ìŠ¤í¬ ë¹„ìœ¨
            risk_ratio = max_loss / account_balance
            
            # ë¦¬ìŠ¤í¬ ë“±ê¸‰
            risk_level = RiskCalculator._get_risk_level(risk_ratio)
            
            return {
                "margin_required": margin_required,
                "max_loss": max_loss,
                "risk_ratio": risk_ratio,
                "risk_percentage": risk_ratio * 100,
                "risk_level": risk_level,
                "kelly_recommended": RiskCalculator._calculate_kelly_size(account_balance, 0.6, 2.0),
                "position_score": RiskCalculator._calculate_position_score(risk_ratio, leverage)
            }
            
        except Exception as e:
            logging.error(f"ë¦¬ìŠ¤í¬ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return {
                "margin_required": 0,
                "max_loss": 0,
                "risk_ratio": 1.0,
                "risk_percentage": 100,
                "risk_level": "EXTREME",
                "kelly_recommended": 0,
                "position_score": 0
            }
    
    @staticmethod
    def _get_risk_level(risk_ratio: float) -> str:
        """ë¦¬ìŠ¤í¬ ë ˆë²¨ ê²°ì •"""
        if risk_ratio <= 0.01:
            return "VERY_LOW"
        elif risk_ratio <= 0.02:
            return "LOW"
        elif risk_ratio <= 0.05:
            return "MEDIUM"
        elif risk_ratio <= 0.1:
            return "HIGH"
        else:
            return "EXTREME"
    
    @staticmethod
    def _calculate_kelly_size(balance: float, win_rate: float, win_loss_ratio: float) -> float:
        """Kelly Criterion ê¶Œì¥ ì‚¬ì´ì¦ˆ"""
        try:
            kelly_ratio = (win_rate * win_loss_ratio - (1 - win_rate)) / win_loss_ratio
            kelly_size = balance * max(0, min(kelly_ratio, 0.25))  # ìµœëŒ€ 25% ì œí•œ
            return kelly_size
        except:
            return balance * 0.02  # ê¸°ë³¸ 2%
    
    @staticmethod
    def _calculate_position_score(risk_ratio: float, leverage: int) -> int:
        """í¬ì§€ì…˜ ì ìˆ˜ (0-100)"""
        try:
            # ë¦¬ìŠ¤í¬ ì ìˆ˜ (ë‚®ì„ìˆ˜ë¡ ì¢‹ìŒ)
            risk_score = max(0, 100 - (risk_ratio * 1000))
            
            # ë ˆë²„ë¦¬ì§€ ì ìˆ˜ (ì ë‹¹í•œ ë ˆë²„ë¦¬ì§€ê°€ ì¢‹ìŒ)
            if leverage <= 3:
                leverage_score = 80
            elif leverage <= 5:
                leverage_score = 90
            elif leverage <= 10:
                leverage_score = 70
            else:
                leverage_score = 50
            
            # ì¢…í•© ì ìˆ˜
            total_score = (risk_score * 0.7) + (leverage_score * 0.3)
            return int(SafeMath.clamp(total_score, 0, 100))
            
        except:
            return 50

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ§  Phoenix 95 AI ì—”ì§„ (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Phoenix95AIEngine:
    """Phoenix 95 AI ì—”ì§„ - ë©”ëª¨ë¦¬ ê´€ë¦¬ ë° ìŠ¤ë ˆë“œ ì•ˆì „ì„± ê°•í™”"""
    
    def __init__(self):
        self.config = SystemConfig.PHOENIX95
        self._analysis_cache = {}
        self._cache_lock = threading.RLock()  # ìŠ¤ë ˆë“œ ì•ˆì „ì„±
        self.model_performance = deque(maxlen=1000)
        self._last_cache_cleanup = time.time()
        
        # ì„±ëŠ¥ íŒŒë¼ë¯¸í„°
        self.confidence_multiplier = self.config["confidence_multiplier"]
        self.market_weight = self.config["market_condition_weight"]
        
    async def analyze_signal_complete(self, signal: TradingSignal) -> Tuple[float, float, str]:
        """ì™„ì „ ì‹ í˜¸ ë¶„ì„ - ë©”ëª¨ë¦¬ ì•ˆì „ì„± ë³´ì¥"""
        start_time = time.time()
        
        try:
            # ìºì‹œ ì •ë¦¬ (ì£¼ê¸°ì )
            await self._cleanup_cache_if_needed()
            
            # ìºì‹œ í™•ì¸ (ìŠ¤ë ˆë“œ ì•ˆì „)
            cache_key = f"{signal.symbol}_{signal.price:.6f}_{signal.confidence:.6f}"
            cached_result = self._get_from_cache(cache_key)
            
            if cached_result:
                return cached_result
            
            # Phoenix 95 í•µì‹¬ ë¶„ì„
            phoenix95_score = await self._phoenix95_core_analysis(signal)
            
            # ì•™ìƒë¸” ëª¨ë¸ ë¶„ì„
            ensemble_boost = await self._ensemble_analysis(signal)
            phoenix95_score = min(phoenix95_score * ensemble_boost, self.config["max_confidence"])
            
            # ì‹œì¥ ì¡°ê±´ íŒ©í„°
            market_factor = await self._analyze_market_conditions(signal.symbol)
            phoenix95_score *= market_factor
            
            # ìµœì¢… ì ìˆ˜ ë²”ìœ„ ì œí•œ
            phoenix95_score = SafeMath.clamp(
                phoenix95_score, 
                self.config["min_confidence"], 
                self.config["max_confidence"]
            )
            
            # Kelly Criterion ê³„ì‚°
            kelly_ratio = await self._calculate_kelly_criterion(phoenix95_score)
            
            # ìµœì¢… ì¶”ì²œ
            recommendation = await self._generate_recommendation(phoenix95_score, kelly_ratio)
            
            # ë¶„ì„ ì‹œê°„ ê²€ì¦
            analysis_time = time.time() - start_time
            if analysis_time > self.config["analysis_timeout"]:
                logging.warning(f"Phoenix95 ë¶„ì„ ì‹œê°„ ì´ˆê³¼: {analysis_time:.2f}ì´ˆ")
            
            # ê²°ê³¼ ìºì‹± (ìŠ¤ë ˆë“œ ì•ˆì „)
            result = (phoenix95_score, kelly_ratio, recommendation)
            self._store_in_cache(cache_key, result)
            
            # ì„±ëŠ¥ ì¶”ì 
            self.model_performance.append({
                'score': phoenix95_score,
                'analysis_time': analysis_time,
                'timestamp': datetime.utcnow()
            })
            
            return result
            
        except Exception as e:
            logging.error(f"Phoenix95 ë¶„ì„ ì‹¤íŒ¨: {e}")
            return 0.0, 0.0, "REJECT"
    
    def _get_from_cache(self, cache_key: str) -> Optional[Tuple[float, float, str]]:
        """ìŠ¤ë ˆë“œ ì•ˆì „ ìºì‹œ ì¡°íšŒ"""
        try:
            with self._cache_lock:
                if cache_key in self._analysis_cache:
                    cached_data = self._analysis_cache[cache_key]
                    # TTL í™•ì¸
                    if (time.time() - cached_data['timestamp']) < self.config["cache_ttl"]:
                        return cached_data['result']
                    else:
                        # ë§Œë£Œëœ ìºì‹œ ì‚­ì œ
                        del self._analysis_cache[cache_key]
            return None
        except Exception as e:
            logging.error(f"ìºì‹œ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return None
    
    def _store_in_cache(self, cache_key: str, result: Tuple[float, float, str]):
        """ìŠ¤ë ˆë“œ ì•ˆì „ ìºì‹œ ì €ì¥"""
        try:
            with self._cache_lock:
                # ìºì‹œ í¬ê¸° ì œí•œ
                if len(self._analysis_cache) >= self.config["max_cache_size"]:
                    # ê°€ì¥ ì˜¤ë˜ëœ í•­ëª© ì œê±° (LRU ë°©ì‹)
                    oldest_key = min(
                        self._analysis_cache.keys(),
                        key=lambda k: self._analysis_cache[k]['timestamp']
                    )
                    del self._analysis_cache[oldest_key]
                
                self._analysis_cache[cache_key] = {
                    'result': result,
                    'timestamp': time.time()
                }
        except Exception as e:
            logging.error(f"ìºì‹œ ì €ì¥ ì˜¤ë¥˜: {e}")
    
    async def _cleanup_cache_if_needed(self):
        """ì£¼ê¸°ì  ìºì‹œ ì •ë¦¬"""
        current_time = time.time()
        if (current_time - self._last_cache_cleanup) > 300:  # 5ë¶„ë§ˆë‹¤
            try:
                with self._cache_lock:
                    expired_keys = []
                    ttl = self.config["cache_ttl"]
                    
                    for key, data in self._analysis_cache.items():
                        if (current_time - data['timestamp']) > ttl:
                            expired_keys.append(key)
                    
                    for key in expired_keys:
                        del self._analysis_cache[key]
                    
                    self._last_cache_cleanup = current_time
                    
                    if expired_keys:
                        logging.info(f"ìºì‹œ ì •ë¦¬ ì™„ë£Œ: {len(expired_keys)}ê°œ í•­ëª© ì œê±°")
                        
            except Exception as e:
                logging.error(f"ìºì‹œ ì •ë¦¬ ì˜¤ë¥˜: {e}")
    
    async def _phoenix95_core_analysis(self, signal: TradingSignal) -> float:
        """Phoenix 95 í•µì‹¬ ë¶„ì„ - ì•ˆì „ì„± ê°•í™”"""
        try:
            base_confidence = signal.confidence
            
            # ì‹ ë¢°ë„ ë¶€ìŠ¤íŒ…
            boosted_confidence = base_confidence * self.confidence_multiplier
            
            # ì‹œê°„ëŒ€ë³„ ê°€ì¤‘ì¹˜
            hour = datetime.utcnow().hour
            time_weight = 1.0
            if 8 <= hour <= 16:  # ìœ ëŸ½ ì‹œê°„
                time_weight = 1.1
            elif 21 <= hour <= 5:  # ë¯¸êµ­ ì‹œê°„  
                time_weight = 1.05
            
            # ì‹¬ë³¼ë³„ ê°€ì¤‘ì¹˜
            symbol_weights = {
                "BTCUSDT": 1.0, "ETHUSDT": 0.95, "ADAUSDT": 0.9,
                "SOLUSDT": 0.9, "AVAXUSDT": 0.85, "DOTUSDT": 0.85
            }
            symbol_weight = symbol_weights.get(signal.symbol, 0.8)
            
            # ìµœì¢… ì ìˆ˜ ê³„ì‚°
            phoenix95_score = boosted_confidence * time_weight * symbol_weight
            return min(phoenix95_score, self.config["max_confidence"])
            
        except Exception as e:
            logging.error(f"Phoenix95 í•µì‹¬ ë¶„ì„ ì˜¤ë¥˜: {e}")
            return 0.0
    
    async def _ensemble_analysis(self, signal: TradingSignal) -> float:
        """ì•™ìƒë¸” ë¶„ì„ - ì•ˆì „ì„± ê°•í™”"""
        try:
            weights = self.config["ensemble_weights"]
            
            # ëª¨ë¸ë³„ ì ìˆ˜ (ì‹œë®¬ë ˆì´ì…˜)
            lstm_score = min(signal.confidence * 1.05, 1.0)
            transformer_score = min(signal.confidence * 1.08, 1.0)
            
            # ì•ˆì „í•œ ê°€ì¤‘ í‰ê· 
            ensemble_score = (
                weights["phoenix95"] * signal.confidence +
                weights["lstm"] * lstm_score +
                weights["transformer"] * transformer_score
            )
            
            # ë¶€ìŠ¤íŠ¸ íŒ©í„° ê³„ì‚°
            boost_factor = SafeMath.safe_divide(ensemble_score, signal.confidence, 1.0)
            return SafeMath.clamp(boost_factor, 0.8, 1.15)
            
        except Exception as e:
            logging.error(f"ì•™ìƒë¸” ë¶„ì„ ì˜¤ë¥˜: {e}")
            return 1.0
    
    async def _analyze_market_conditions(self, symbol: str) -> float:
        """ì‹œì¥ ì¡°ê±´ ë¶„ì„ - ì˜¤ë¥˜ ì²˜ë¦¬ ê°•í™”"""
        try:
            hour = datetime.utcnow().hour
            
            # ê±°ë˜ëŸ‰ ê¸°ë°˜ ì¡°ì •
            if 8 <= hour <= 16 or 21 <= hour <= 23:
                return 1.1  # í™œë°œí•œ ì‹œê°„
            elif 2 <= hour <= 6:
                return 0.9  # ì €ì¡°í•œ ì‹œê°„
            else:
                return 1.0
                
        except Exception as e:
            logging.error(f"ì‹œì¥ ì¡°ê±´ ë¶„ì„ ì˜¤ë¥˜: {e}")
            return 1.0
    
    async def _calculate_kelly_criterion(self, phoenix95_score: float) -> float:
        """Kelly Criterion - ì•ˆì „í•œ ê³„ì‚°"""
        try:
            # ìŠ¹ë¥  ì¶”ì •
            win_probability = phoenix95_score
            
            # ì†ìµ ë¹„ìœ¨
            win_loss_ratio = SafeMath.safe_divide(
                SystemConfig.TRADING["take_profit_pct"],
                SystemConfig.TRADING["stop_loss_pct"],
                2.0  # ê¸°ë³¸ê°’ 2:1
            )
            
            # Kelly ê³µì‹: (bp - q) / b
            kelly_ratio = SafeMath.safe_divide(
                (win_probability * win_loss_ratio - (1 - win_probability)),
                win_loss_ratio,
                0.01  # ê¸°ë³¸ê°’ 1%
            )
            
            # ë³´ìˆ˜ì  ì œí•œ
            return SafeMath.clamp(kelly_ratio, 0.01, SystemConfig.TRADING["kelly_max"])
            
        except Exception as e:
            logging.error(f"Kelly ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.01
    
    async def _generate_recommendation(self, phoenix95_score: float, kelly_ratio: float) -> str:
        """ì•ˆì „í•œ ì¶”ì²œ ìƒì„±"""
        try:
            if phoenix95_score >= 0.95 and kelly_ratio >= 0.2:
                return "STRONG_BUY"
            elif phoenix95_score >= 0.85 and kelly_ratio >= 0.15:
                return "BUY"
            elif phoenix95_score >= 0.75 and kelly_ratio >= 0.1:
                return "WEAK_BUY"
            elif phoenix95_score >= 0.6:
                return "HOLD"
            else:
                return "REJECT"
        except Exception as e:
            logging.error(f"ì¶”ì²œ ìƒì„± ì˜¤ë¥˜: {e}")
            return "REJECT"
    
    def get_performance_stats(self) -> Dict:
        """ì„±ëŠ¥ í†µê³„ - ì•ˆì „í•œ ê³„ì‚°"""
        try:
            if not self.model_performance:
                return {"status": "no_data"}
            
            scores = [p['score'] for p in self.model_performance if 'score' in p]
            times = [p['analysis_time'] for p in self.model_performance if 'analysis_time' in p]
            
            if not scores or not times:
                return {"status": "insufficient_data"}
            
            return {
                "avg_score": float(np.mean(scores)),
                "score_std": float(np.std(scores)),
                "avg_analysis_time": float(np.mean(times)),
                "max_analysis_time": float(np.max(times)),
                "total_analyses": len(self.model_performance),
                "cache_size": len(self._analysis_cache)
            }
        except Exception as e:
            logging.error(f"ì„±ëŠ¥ í†µê³„ ì˜¤ë¥˜: {e}")
            return {"status": "error", "message": str(e)}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              âš¡ ë ˆë²„ë¦¬ì§€ íŠ¸ë ˆì´ë”© ì—”ì§„ (ë™ì‹œì„± ì•ˆì „ì„±)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class UltimateLeverageTrader:
    """ë ˆë²„ë¦¬ì§€ íŠ¸ë ˆì´ë”© ì—”ì§„ - ë™ì‹œì„± ë° ì•ˆì „ì„± ê°•í™”"""
    
    def __init__(self, redis_client, postgres_pool, telegram_notifier):
        self.redis = redis_client
        self.postgres = postgres_pool
        self.telegram = telegram_notifier
        
        # ìŠ¤ë ˆë“œ ì•ˆì „ ì»¨í…Œì´ë„ˆ
        self._positions_lock = asyncio.Lock()
        self.active_positions: Dict[str, Position] = {}
        self.monitoring_tasks: Dict[str, asyncio.Task] = {}
        self.risk_metrics = deque(maxlen=1000)
        
        # ìœ„í—˜ ì¶”ì 
        self._daily_pnl_cache = None
        self._daily_pnl_cache_time = 0
        
    async def execute_trade_complete(self, signal: TradingSignal, 
                                   phoenix95_score: float, 
                                   kelly_ratio: float) -> Optional[Position]:
        """ì™„ì „í•œ ê±°ë˜ ì‹¤í–‰ - ë™ì‹œì„± ì•ˆì „"""
        execution_start = time.time()
        
        try:
            # ë¦¬ìŠ¤í¬ ì²´í¬
            risk_check = await self._comprehensive_risk_check(signal)
            if not risk_check["approved"]:
                logging.warning(f"ë¦¬ìŠ¤í¬ ì²´í¬ ì‹¤íŒ¨: {risk_check['reason']}")
                await self.telegram.send_message(f"âš ï¸ ê±°ë˜ ê±°ë¶€: {risk_check['reason']}")
                return None
            
            # í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
            position_size_usd = await self._calculate_optimal_position_size(kelly_ratio, signal)
            if position_size_usd <= 0:
                logging.warning("í¬ì§€ì…˜ í¬ê¸°ê°€ 0 ì´í•˜")
                return None
            
            # ë ˆë²„ë¦¬ì§€ ê³„ì‚°
            leverage = await self._calculate_optimal_leverage(phoenix95_score)
            
            # ìˆ˜ëŸ‰ ë° ë§ˆì§„ ê³„ì‚°
            quantity = SafeMath.safe_divide(position_size_usd, signal.price, 0)
            if quantity <= 0:
                logging.warning("ê³„ì‚°ëœ ìˆ˜ëŸ‰ì´ 0 ì´í•˜")
                return None
                
            margin_required = SafeMath.safe_divide(position_size_usd, leverage, position_size_usd)
            
            # ë¦¬ìŠ¤í¬ ê°€ê²© ê³„ì‚°
            liquidation_price = self._calculate_liquidation_price(signal, leverage)
            stop_loss_price = self._calculate_stop_loss_price(signal)
            take_profit_price = self._calculate_take_profit_price(signal)
            
            # í¬ì§€ì…˜ ìƒì„±
            position = Position(
                position_id=f"POS_{uuid.uuid4().hex[:8].upper()}",
                signal_id=signal.signal_id,
                symbol=signal.symbol,
                side=signal.action.upper(),
                entry_price=signal.price,
                quantity=quantity,
                leverage=leverage,
                margin_mode=SystemConfig.TRADING["margin_mode"],
                margin_required=margin_required,
                liquidation_price=liquidation_price,
                stop_loss_price=stop_loss_price,
                take_profit_price=take_profit_price,
                current_price=signal.price
            )
            
            # ë™ì‹œì„± ì•ˆì „í•œ í¬ì§€ì…˜ ì¶”ê°€
            async with self._positions_lock:
                # ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥
                await self._save_position_to_db(position)
                await self._save_signal_to_db(signal)
                
                # ë©”ëª¨ë¦¬ì— ì¶”ê°€
                self.active_positions[position.position_id] = position
            
            # ëª¨ë‹ˆí„°ë§ ì‹œì‘
            await self._start_position_monitoring(position)
            
            # ì‹¤í–‰ ì‹œê°„ ì²´í¬
            execution_time = (time.time() - execution_start) * 1000
            if execution_time > 500:
                logging.warning(f"ê±°ë˜ ì‹¤í–‰ ì‹œê°„ ì´ˆê³¼: {execution_time:.0f}ms")
            
            # ì„±ê³µ ì•Œë¦¼
            await self.telegram.send_trade_notification(position, phoenix95_score, kelly_ratio)
            
            logging.info(f"ê±°ë˜ ì‹¤í–‰ ì™„ë£Œ: {position.position_id} ({execution_time:.0f}ms)")
            return position
            
        except Exception as e:
            logging.error(f"ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨: {e}")
            await self.telegram.send_message(f"ğŸš¨ ê±°ë˜ ì‹¤í–‰ ì˜¤ë¥˜: {str(e)}")
            return None
    
    async def _comprehensive_risk_check(self, signal: TradingSignal) -> Dict:
        """í¬ê´„ì  ë¦¬ìŠ¤í¬ ì²´í¬ - ê°œì„ ëœ ë¡œì§"""
        try:
            risk_factors = []
            
            # 1. í¬ì§€ì…˜ ìˆ˜ ì²´í¬ (ë™ì‹œì„± ì•ˆì „)
            async with self._positions_lock:
                active_count = len(self.active_positions)
            
            if active_count >= SystemConfig.TRADING["max_positions"]:
                return {"approved": False, "reason": "ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ì´ˆê³¼"}
            
            # 2. ì¼ì¼ ì†ì‹¤ í•œë„ ì²´í¬ (ìºì‹œ ì‚¬ìš©)
            daily_pnl = await self._get_daily_pnl_cached()
            if daily_pnl <= -SystemConfig.TRADING["max_daily_loss"]:
                return {"approved": False, "reason": "ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼"}
            
            # 3. ì‹¬ë³¼ ì¤‘ë³µ ì²´í¬
            async with self._positions_lock:
                symbol_positions = [
                    p for p in self.active_positions.values() 
                    if p.symbol == signal.symbol and p.status == "OPEN"
                ]
            
            if symbol_positions:
                return {"approved": False, "reason": f"{signal.symbol} í¬ì§€ì…˜ ì´ë¯¸ ì¡´ì¬"}
            
            # 4. ì‹œì¥ ì‹œê°„ ì²´í¬
            now = datetime.utcnow()
            if now.weekday() >= 5:  # ì£¼ë§
                risk_factors.append("ì£¼ë§ ê±°ë˜")
            
            # 5. ê°€ê²© ìœ íš¨ì„± ì²´í¬
            if signal.price <= 0:
                return {"approved": False, "reason": "ì˜ëª»ëœ ê°€ê²©"}
            
            # 6. ë³€ë™ì„± ì²´í¬
            volatility_risk = await self._check_volatility_risk(signal.symbol)
            if volatility_risk > 0.8:
                risk_factors.append("ë†’ì€ ë³€ë™ì„±")
            
            # ë¦¬ìŠ¤í¬ ì ìˆ˜ ê³„ì‚°
            risk_score = len(risk_factors) / 6
            
            return {
                "approved": risk_score < 0.5,
                "reason": "ë¦¬ìŠ¤í¬ ì²´í¬ í†µê³¼" if risk_score < 0.5 else f"ìœ„í—˜ ìš”ì†Œ: {', '.join(risk_factors)}",
                "risk_score": risk_score,
                "risk_factors": risk_factors
            }
            
        except Exception as e:
            logging.error(f"ë¦¬ìŠ¤í¬ ì²´í¬ ì˜¤ë¥˜: {e}")
            return {"approved": False, "reason": f"ë¦¬ìŠ¤í¬ ì²´í¬ ì‹¤íŒ¨: {str(e)}"}
    
    async def _get_daily_pnl_cached(self) -> float:
        """ìºì‹œëœ ì¼ì¼ P&L ì¡°íšŒ"""
        current_time = time.time()
        
        # 5ë¶„ ìºì‹œ
        if (self._daily_pnl_cache is not None and 
            (current_time - self._daily_pnl_cache_time) < 300):
            return self._daily_pnl_cache
        
        try:
            async with self.postgres.acquire() as conn:
                result = await conn.fetchval("""
                    SELECT COALESCE(SUM(pnl), 0) FROM trade_history
                    WHERE DATE(entry_time) = CURRENT_DATE
                """)
                
                daily_pnl = float(result) if result else 0.0
                self._daily_pnl_cache = daily_pnl
                self._daily_pnl_cache_time = current_time
                
                return daily_pnl
                
        except Exception as e:
            logging.error(f"ì¼ì¼ P&L ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return self._daily_pnl_cache or 0.0
    
    async def _calculate_optimal_position_size(self, kelly_ratio: float, signal: TradingSignal) -> float:
        """ìµœì  í¬ì§€ì…˜ í¬ê¸° - ê²€ì¦ ê°•í™”"""
        try:
            # ê³„ì¢Œ ì”ê³ 
            account_balance = max(100.0, float(os.getenv("ACCOUNT_BALANCE", "50000")))
            
            # Kelly ê¸°ë°˜ í¬ì§€ì…˜ í¬ê¸°
            kelly_position = account_balance * kelly_ratio
            
            # ìµœëŒ€ í¬ì§€ì…˜ í¬ê¸° ì œí•œ
            max_position_size = account_balance * SystemConfig.TRADING["position_size_pct"]
            
            # ìµœì¢… í¬ê¸°
            position_size = min(kelly_position, max_position_size)
            
            # ë²”ìœ„ ì œí•œ
            min_position = 100.0
            max_position = min(10000.0, account_balance * 0.1)  # ìµœëŒ€ 10%
            
            return SafeMath.clamp(position_size, min_position, max_position)
            
        except Exception as e:
            logging.error(f"í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 100.0  # ê¸°ë³¸ ìµœì†Œê°’
    
    async def _calculate_optimal_leverage(self, phoenix95_score: float) -> int:
        """ìµœì  ë ˆë²„ë¦¬ì§€ - ë³´ìˆ˜ì  ì ‘ê·¼"""
        try:
            max_leverage = SystemConfig.TRADING["max_leverage"]
            
            if phoenix95_score >= 0.95:
                return max_leverage
            elif phoenix95_score >= 0.9:
                return min(8, max_leverage)
            elif phoenix95_score >= 0.85:
                return min(5, max_leverage)
            else:
                return min(3, max_leverage)
                
        except Exception as e:
            logging.error(f"ë ˆë²„ë¦¬ì§€ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 1  # ê°€ì¥ ì•ˆì „í•œ ê°’
    
    def _calculate_liquidation_price(self, signal: TradingSignal, leverage: int) -> float:
        """ì²­ì‚°ê°€ ê³„ì‚° - ì•ˆì „ì„± ê°•í™”"""
        try:
            maintenance_margin_rate = 0.004  # 0.4%
            leverage = max(1, leverage)  # 0ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ë°©ì§€
            
            if signal.action.lower() == "buy":
                liquidation_price = signal.price * (1 - (1/leverage) + maintenance_margin_rate)
            else:
                liquidation_price = signal.price * (1 + (1/leverage) - maintenance_margin_rate)
            
            return max(0.01, liquidation_price)  # ìµœì†Œê°’ ë³´ì¥
            
        except Exception as e:
            logging.error(f"ì²­ì‚°ê°€ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return signal.price * 0.5  # ë³´ìˆ˜ì  ê¸°ë³¸ê°’
    
    def _calculate_stop_loss_price(self, signal: TradingSignal) -> float:
        """ì†ì ˆê°€ ê³„ì‚°"""
        try:
            stop_pct = SystemConfig.TRADING["stop_loss_pct"]
            
            if signal.action.lower() == "buy":
                return signal.price * (1 - stop_pct)
            else:
                return signal.price * (1 + stop_pct)
                
        except Exception as e:
            logging.error(f"ì†ì ˆê°€ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return signal.price * 0.95  # 5% ì†ì ˆ
    
    def _calculate_take_profit_price(self, signal: TradingSignal) -> float:
        """ìµì ˆê°€ ê³„ì‚°"""
        try:
            profit_pct = SystemConfig.TRADING["take_profit_pct"]
            
            if signal.action.lower() == "buy":
                return signal.price * (1 + profit_pct)
            else:
                return signal.price * (1 - profit_pct)
                
        except Exception as e:
            logging.error(f"ìµì ˆê°€ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return signal.price * 1.05  # 5% ìµì ˆ
    
    async def _start_position_monitoring(self, position: Position):
        """í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì‹œì‘ - ì•ˆì „ì„± ê°•í™”"""
        try:
            # ê¸°ì¡´ ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ê°€ ìˆë‹¤ë©´ ì·¨ì†Œ
            if position.position_id in self.monitoring_tasks:
                old_task = self.monitoring_tasks[position.position_id]
                if not old_task.done():
                    old_task.cancel()
            
            # ìƒˆ ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì‹œì‘
            task = asyncio.create_task(self._monitor_position_realtime(position))
            self.monitoring_tasks[position.position_id] = task
            
            # Redisì— í¬ì§€ì…˜ ì •ë³´ ì €ì¥
            await self.redis.hset(
                f"position:{position.position_id}",
                mapping={
                    "symbol": position.symbol,
                    "side": position.side,
                    "entry_price": str(position.entry_price),
                    "quantity": str(position.quantity),
                    "leverage": str(position.leverage),
                    "status": position.status,
                    "created_at": position.created_at.isoformat()
                }
            )
            
        except Exception as e:
            logging.error(f"ëª¨ë‹ˆí„°ë§ ì‹œì‘ ì˜¤ë¥˜: {e}")
    
    async def _monitor_position_realtime(self, position: Position):
        """ì‹¤ì‹œê°„ í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ - ë¬´í•œë£¨í”„ ë°©ì§€"""
        logging.info(f"í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì‹œì‘: {position.position_id}")
        
        max_iterations = 86400  # 24ì‹œê°„ = 86400ì´ˆ (1ì´ˆë§ˆë‹¤)
        iteration_count = 0
        
        try:
            while (position.status == "OPEN" and 
                   position.position_id in self.active_positions and 
                   iteration_count < max_iterations):
                
                try:
                    # í˜„ì¬ê°€ ì¡°íšŒ
                    current_price = await self._get_current_price(position.symbol)
                    if current_price <= 0:
                        await asyncio.sleep(5)
                        continue
                        
                    position.current_price = current_price
                    
                    # P&L ê³„ì‚°
                    pnl, pnl_pct = position.calculate_pnl(current_price)
                    position.unrealized_pnl = pnl
                    position.pnl_percentage = pnl_pct
                    
                    # ì²­ì‚° ìœ„í—˜ë„ ê³„ì‚°
                    risk = position.calculate_liquidation_risk(current_price)
                    position.liquidation_risk = risk
                    
                    # ì¢…ë£Œ ì¡°ê±´ ì²´í¬
                    exit_reason = await self._check_exit_conditions(position, current_price)
                    if exit_reason:
                        await self._close_position(position, current_price, exit_reason)
                        break
                    
                    # Redis ì—…ë°ì´íŠ¸ (10ì´ˆë§ˆë‹¤ë§Œ)
                    if iteration_count % 10 == 0:
                        await self.redis.hset(
                            f"position:{position.position_id}",
                            mapping={
                                "current_price": str(current_price),
                                "unrealized_pnl": str(pnl),
                                "pnl_percentage": str(pnl_pct),
                                "liquidation_risk": str(risk),
                                "updated_at": datetime.utcnow().isoformat()
                            }
                        )
                    
                    # ìœ„í—˜ ì•Œë¦¼ ì²´í¬ (5ë¶„ë§ˆë‹¤ë§Œ)
                    if risk > 0.8 and iteration_count % 300 == 0:
                        await self.telegram.send_liquidation_warning(position)
                    
                    iteration_count += 1
                    await asyncio.sleep(1)
                    
                except Exception as e:
                    logging.error(f"ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì˜¤ë¥˜ {position.position_id}: {e}")
                    await asyncio.sleep(5)
                    iteration_count += 1
            
            # ë£¨í”„ ì¢…ë£Œ ì´ìœ  ë¡œê¹…
            if iteration_count >= max_iterations:
                logging.warning(f"í¬ì§€ì…˜ {position.position_id} ëª¨ë‹ˆí„°ë§ ì‹œê°„ ì´ˆê³¼ë¡œ ì¢…ë£Œ")
            
        except asyncio.CancelledError:
            logging.info(f"í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì·¨ì†Œë¨: {position.position_id}")
        except Exception as e:
            logging.error(f"í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì˜ˆì™¸: {e}")
        finally:
            # ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì •ë¦¬
            if position.position_id in self.monitoring_tasks:
                del self.monitoring_tasks[position.position_id]
    
    async def _get_current_price(self, symbol: str) -> float:
        """í˜„ì¬ê°€ ì¡°íšŒ - Binance API ìš°ì„ , ì‹œë®¬ë ˆì´ì…˜ ë°±ì—…"""
        try:
            # Binance API ì‹œë„
            if os.getenv("USE_REAL_API", "false").lower() == "true":
                async with BinanceAPIClient() as binance:
                    real_price = await binance.get_symbol_price(symbol)
                    if real_price:
                        return real_price
                        
            # ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ (ê°œë°œ/í…ŒìŠ¤íŠ¸ìš©)
            base_prices = {
                "BTCUSDT": 45000, "ETHUSDT": 3000, "ADAUSDT": 0.5,
                "SOLUSDT": 100, "AVAXUSDT": 40, "DOTUSDT": 8,
                "LINKUSDT": 15, "MATICUSDT": 1.2, "ATOMUSDT": 12, "NEARUSDT": 6
            }
            
            base_price = base_prices.get(symbol, 45000)
            
            # ê°„ë‹¨í•œ ê°€ê²© ë³€ë™ ì‹œë®¬ë ˆì´ì…˜
            import random
            change = random.uniform(-0.01, 0.01)  # Â±1% ë³€ë™
            new_price = base_price * (1 + change)
            
            return max(0.01, new_price)  # ìµœì†Œê°’ ë³´ì¥
            
        except Exception as e:
            logging.error(f"í˜„ì¬ê°€ ì¡°íšŒ ì˜¤ë¥˜ {symbol}: {e}")
            return 45000.0  # ê¸°ë³¸ê°’
    
    async def _check_exit_conditions(self, position: Position, current_price: float) -> Optional[str]:
        """ì¢…ë£Œ ì¡°ê±´ ì²´í¬ - ì•ˆì „ì„± ê°•í™”"""
        try:
            if current_price <= 0:
                return None
            
            # ì†ì ˆê°€ ì²´í¬
            if position.side == "BUY" and current_price <= position.stop_loss_price:
                return "STOP_LOSS"
            if position.side == "SELL" and current_price >= position.stop_loss_price:
                return "STOP_LOSS"
            
            # ìµì ˆê°€ ì²´í¬  
            if position.side == "BUY" and current_price >= position.take_profit_price:
                return "TAKE_PROFIT"
            if position.side == "SELL" and current_price <= position.take_profit_price:
                return "TAKE_PROFIT"
            
            # ê¸´ê¸‰ ì²­ì‚° ì²´í¬
            if position.liquidation_risk > 0.95:
                return "EMERGENCY_LIQUIDATION"
            
            return None
            
        except Exception as e:
            logging.error(f"ì¢…ë£Œ ì¡°ê±´ ì²´í¬ ì˜¤ë¥˜: {e}")
            return None
    
    async def _close_position(self, position: Position, exit_price: float, exit_reason: str):
        """í¬ì§€ì…˜ ì²­ì‚° - ë™ì‹œì„± ì•ˆì „"""
        try:
            async with self._positions_lock:
                position.status = "CLOSED"
                position.exit_price = exit_price
                position.exit_time = datetime.utcnow()
                position.exit_reason = exit_reason
                
                # ìµœì¢… P&L ê³„ì‚°
                final_pnl, final_pnl_pct = position.calculate_pnl(exit_price)
                position.realized_pnl = final_pnl
                
                # ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸
                await self._update_position_in_db(position)
                await self._save_trade_history(position)
                
                # ë©”ëª¨ë¦¬ì—ì„œ ì œê±°
                if position.position_id in self.active_positions:
                    del self.active_positions[position.position_id]
            
            # Redis ì •ë¦¬
            await self.redis.delete(f"position:{position.position_id}")
            
            # ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì·¨ì†Œ
            if position.position_id in self.monitoring_tasks:
                task = self.monitoring_tasks.pop(position.position_id)
                if not task.done():
                    task.cancel()
            
            # ìºì‹œ ë¬´íš¨í™”
            self._daily_pnl_cache = None
            
            # ì²­ì‚° ì•Œë¦¼
            await self.telegram.send_close_notification(position, exit_reason)
            
            logging.info(f"í¬ì§€ì…˜ ì²­ì‚° ì™„ë£Œ: {position.position_id} | P&L: ${final_pnl:.2f} | ì‚¬ìœ : {exit_reason}")
            
        except Exception as e:
            logging.error(f"í¬ì§€ì…˜ ì²­ì‚° ì˜¤ë¥˜: {e}")
    
    async def _save_position_to_db(self, position: Position):
        """í¬ì§€ì…˜ DB ì €ì¥ - ì˜¤ë¥˜ ì²˜ë¦¬ ê°•í™”"""
        try:
            async with self.postgres.acquire() as conn:
                await conn.execute("""
                    INSERT INTO positions (
                        position_id, signal_id, symbol, side, entry_price, quantity,
                        leverage, margin_mode, margin_required, liquidation_price,
                        stop_loss_price, take_profit_price, status, created_at
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
                    ON CONFLICT (position_id) DO NOTHING
                """, position.position_id, position.signal_id, position.symbol, position.side,
                position.entry_price, position.quantity, position.leverage, position.margin_mode,
                position.margin_required, position.liquidation_price, position.stop_loss_price,
                position.take_profit_price, position.status, position.created_at)
                
        except Exception as e:
            logging.error(f"í¬ì§€ì…˜ DB ì €ì¥ ì‹¤íŒ¨: {e}")
            # ë°ì´í„°ë² ì´ìŠ¤ ì˜¤ë¥˜ê°€ ê±°ë˜ë¥¼ ì¤‘ë‹¨í•˜ì§€ ì•Šë„ë¡ ì²˜ë¦¬
    
    async def _save_signal_to_db(self, signal: TradingSignal):
        """ì‹ í˜¸ DB ì €ì¥"""
        try:
            async with self.postgres.acquire() as conn:
                await conn.execute("""
                    INSERT INTO signals (
                        signal_id, symbol, action, price, confidence, phoenix95_score,
                        kelly_ratio, recommendation, timestamp, processed
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                    ON CONFLICT (signal_id) DO NOTHING
                """, signal.signal_id, signal.symbol, signal.action, signal.price,
                signal.confidence, signal.phoenix95_score, signal.kelly_ratio,
                signal.recommendation, signal.timestamp, signal.processed)
                
        except Exception as e:
            logging.error(f"ì‹ í˜¸ DB ì €ì¥ ì‹¤íŒ¨: {e}")
    
    async def _update_position_in_db(self, position: Position):
        """í¬ì§€ì…˜ DB ì—…ë°ì´íŠ¸"""
        try:
            async with self.postgres.acquire() as conn:
                await conn.execute("""
                    UPDATE positions SET
                        current_price = $1, unrealized_pnl = $2, pnl_percentage = $3,
                        liquidation_risk = $4, status = $5, exit_price = $6,
                        exit_time = $7, exit_reason = $8, realized_pnl = $9, updated_at = $10
                    WHERE position_id = $11
                """, position.current_price, position.unrealized_pnl, position.pnl_percentage,
                position.liquidation_risk, position.status, position.exit_price,
                position.exit_time, position.exit_reason, position.realized_pnl,
                position.updated_at, position.position_id)
                
        except Exception as e:
            logging.error(f"í¬ì§€ì…˜ DB ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {e}")
    
    async def _save_trade_history(self, position: Position):
        """ê±°ë˜ ì´ë ¥ ì €ì¥"""
        try:
            duration_minutes = 0
            if position.exit_time and position.created_at:
                duration_minutes = int((position.exit_time - position.created_at).total_seconds() / 60)
            
            async with self.postgres.acquire() as conn:
                await conn.execute("""
                    INSERT INTO trade_history (
                        position_id, symbol, side, entry_price, exit_price, quantity,
                        leverage, pnl, pnl_percentage, duration_minutes, entry_time,
                        exit_time, exit_reason
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
                    ON CONFLICT (position_id) DO NOTHING
                """, position.position_id, position.symbol, position.side, position.entry_price,
                position.exit_price, position.quantity, position.leverage, position.realized_pnl,
                position.pnl_percentage, duration_minutes, position.created_at,
                position.exit_time, position.exit_reason)
                
        except Exception as e:
            logging.error(f"ê±°ë˜ ì´ë ¥ ì €ì¥ ì‹¤íŒ¨: {e}")
    
    async def _check_volatility_risk(self, symbol: str) -> float:
        """ë³€ë™ì„± ìœ„í—˜ë„ ì²´í¬"""
        try:
            volatility_map = {
                "BTCUSDT": 0.3, "ETHUSDT": 0.4, "ADAUSDT": 0.6,
                "SOLUSDT": 0.7, "AVAXUSDT": 0.6, "DOTUSDT": 0.5,
                "LINKUSDT": 0.5, "MATICUSDT": 0.6, "ATOMUSDT": 0.5, "NEARUSDT": 0.6
            }
            return volatility_map.get(symbol, 0.5)
        except Exception as e:
            logging.error(f"ë³€ë™ì„± ì²´í¬ ì˜¤ë¥˜: {e}")
            return 0.5
    
    def get_portfolio_summary(self) -> Dict:
        """í¬íŠ¸í´ë¦¬ì˜¤ ìš”ì•½ - ì•ˆì „í•œ ê³„ì‚°"""
        try:
            if not self.active_positions:
                return {
                    "active_positions": 0,
                    "total_unrealized_pnl": 0.0,
                    "total_margin_used": 0.0,
                    "avg_leverage": 0.0,
                    "avg_liquidation_risk": 0.0,
                    "symbols": []
                }
            
            positions = list(self.active_positions.values())
            
            # ì•ˆì „í•œ ì§‘ê³„ ê³„ì‚°
            total_pnl = sum(getattr(p, 'unrealized_pnl', 0.0) for p in positions)
            total_margin = sum(getattr(p, 'margin_required', 0.0) for p in positions)
            leverages = [getattr(p, 'leverage', 1) for p in positions if hasattr(p, 'leverage')]
            risks = [getattr(p, 'liquidation_risk', 0.0) for p in positions if hasattr(p, 'liquidation_risk')]
            symbols = [getattr(p, 'symbol', 'UNKNOWN') for p in positions if hasattr(p, 'symbol')]
            
            return {
                "active_positions": len(positions),
                "total_unrealized_pnl": float(total_pnl),
                "total_margin_used": float(total_margin),
                "avg_leverage": float(np.mean(leverages)) if leverages else 0.0,
                "avg_liquidation_risk": float(np.mean(risks)) if risks else 0.0,
                "symbols": symbols
            }
            
        except Exception as e:
            logging.error(f"í¬íŠ¸í´ë¦¬ì˜¤ ìš”ì•½ ì˜¤ë¥˜: {e}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“± í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì‹œìŠ¤í…œ (ë¹„ë™ê¸° ì•ˆì „)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class UltimateTelegramNotifier:
    """í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì‹œìŠ¤í…œ - ì•ˆì „ì„± ë° ì†ë„ í–¥ìƒ"""
    
    def __init__(self):
        self.config = SystemConfig.TELEGRAM
        self.secure_config = SystemConfig.get_secure_config()
        self.bot_token = self.secure_config["telegram_bot_token"]
        self.chat_id = self.secure_config["telegram_chat_id"]
        
        # ë©”ì‹œì§€ í ë° ì†ë„ ì œí•œ
        self.rate_limiter = asyncio.Semaphore(3)  # ë™ì‹œ 3ê°œ ì œí•œ
        self.message_queue = asyncio.Queue(maxsize=100)
        self.last_alert_times = {}  # ì¤‘ë³µ ì•Œë¦¼ ë°©ì§€
        
        # ë©”ì‹œì§€ ì²˜ë¦¬ íƒœìŠ¤í¬ ì‹œì‘
        asyncio.create_task(self._process_message_queue())
    
    async def send_message(self, message: str, level: str = "INFO") -> bool:
        """ë©”ì‹œì§€ íì— ì¶”ê°€ (ë…¼ë¸”ë¡œí‚¹)"""
        try:
            # ì¿¨ë‹¤ìš´ ì²´í¬ (ê°™ì€ ë©”ì‹œì§€ ë°˜ë³µ ë°©ì§€)
            message_hash = hash(message)
            current_time = time.time()
            
            if message_hash in self.last_alert_times:
                if (current_time - self.last_alert_times[message_hash]) < 60:  # 1ë¶„ ì¿¨ë‹¤ìš´
                    return False
            
            self.last_alert_times[message_hash] = current_time
            
            # íì— ì¶”ê°€
            if not self.message_queue.full():
                await self.message_queue.put((message, level))
                return True
            else:
                logging.warning("í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ íê°€ ê°€ë“ì°¸")
                return False
                
        except Exception as e:
            logging.error(f"ë©”ì‹œì§€ í ì¶”ê°€ ì‹¤íŒ¨: {e}")
            return False
    
    async def _process_message_queue(self):
        """ë©”ì‹œì§€ í ì²˜ë¦¬ (ë°±ê·¸ë¼ìš´ë“œ)"""
        while True:
            try:
                # íì—ì„œ ë©”ì‹œì§€ ê°€ì ¸ì˜¤ê¸°
                message, level = await self.message_queue.get()
                
                # ì‹¤ì œ ì „ì†¡
                async with self.rate_limiter:
                    await self._send_message_internal(message, level)
                
                # í ì‘ì—… ì™„ë£Œ í‘œì‹œ
                self.message_queue.task_done()
                
                # ì „ì†¡ ê°„ê²© (í…”ë ˆê·¸ë¨ API ì œí•œ ì¤€ìˆ˜)
                await asyncio.sleep(0.5)
                
            except Exception as e:
                logging.error(f"ë©”ì‹œì§€ í ì²˜ë¦¬ ì˜¤ë¥˜: {e}")
                await asyncio.sleep(5)
    
    async def _send_message_internal(self, message: str, level: str) -> bool:
        """ì‹¤ì œ ë©”ì‹œì§€ ì „ì†¡ (íƒ€ì„ì•„ì›ƒ ë° ì¬ì‹œë„)"""
        max_retries = 3
        
        for attempt in range(max_retries):
            try:
                url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
                
                # ë ˆë²¨ë³„ ì´ëª¨ì§€
                level_emojis = {
                    "INFO": "â„¹ï¸", "WARNING": "âš ï¸", "ERROR": "âŒ", 
                    "CRITICAL": "ğŸš¨", "SUCCESS": "âœ…"
                }
                emoji = level_emojis.get(level, "ğŸ“¢")
                
                # ë©”ì‹œì§€ ê¸¸ì´ ì œí•œ (4096ì)
                if len(message) > 4000:
                    message = message[:4000] + "..."
                
                formatted_message = f"{emoji} <b>[{level}]</b>\n{message}"
                
                data = {
                    "chat_id": self.chat_id,
                    "text": formatted_message,
                    "parse_mode": "HTML",
                    "disable_web_page_preview": True
                }
                
                # ë¹„ë™ê¸° HTTP ìš”ì²­ (íƒ€ì„ì•„ì›ƒ ì„¤ì •)
                timeout = aiohttp.ClientTimeout(total=10)
                async with aiohttp.ClientSession(timeout=timeout) as session:
                    async with session.post(url, data=data) as response:
                        if response.status == 200:
                            return True
                        elif response.status == 429:  # Too Many Requests
                            retry_after = int(response.headers.get('Retry-After', 60))
                            await asyncio.sleep(retry_after)
                            continue
                        else:
                            logging.warning(f"í…”ë ˆê·¸ë¨ ì‘ë‹µ ì˜¤ë¥˜: {response.status}")
                            
            except asyncio.TimeoutError:
                logging.warning(f"í…”ë ˆê·¸ë¨ ì „ì†¡ íƒ€ì„ì•„ì›ƒ (ì‹œë„ {attempt + 1}/{max_retries})")
            except Exception as e:
                logging.error(f"í…”ë ˆê·¸ë¨ ì „ì†¡ ì‹¤íŒ¨ (ì‹œë„ {attempt + 1}/{max_retries}): {e}")
            
            # ì¬ì‹œë„ ëŒ€ê¸°
            if attempt < max_retries - 1:
                await asyncio.sleep(2 ** attempt)  # ì§€ìˆ˜ ë°±ì˜¤í”„
        
        return False
    
    async def send_trade_notification(self, position: Position, phoenix95_score: float, kelly_ratio: float):
        """ê±°ë˜ ì‹¤í–‰ ì•Œë¦¼ - ì•ˆì „í•œ ê³„ì‚°"""
        try:
            # ì•ˆì „í•œ ê³„ì‚°
            stop_loss_pct = SystemConfig.TRADING.get("stop_loss_pct", 0.015)
            take_profit_pct = SystemConfig.TRADING.get("take_profit_pct", 0.03)
            
            pnl_range_low = position.margin_required * (stop_loss_pct * position.leverage)
            pnl_range_high = position.margin_required * (take_profit_pct * position.leverage)
            
            message = f"""ğŸ¯ <b>Phoenix 95 ê±°ë˜ ì‹¤í–‰</b>

ğŸ“Š <b>{position.symbol}</b> {position.side} {position.leverage}x
ğŸ’° ì§„ì…: <b>${position.entry_price:,.2f}</b>
ğŸ“ˆ ìµì ˆ: <b>${position.take_profit_price:,.2f}</b> (+{take_profit_pct*100:.1f}%)
ğŸ“‰ ì†ì ˆ: <b>${position.stop_loss_price:,.2f}</b> (-{stop_loss_pct*100:.1f}%)
ğŸš¨ ì²­ì‚°: <b>${position.liquidation_price:,.2f}</b>

ğŸ§  Phoenix95: <b>{phoenix95_score:.1%}</b>
âš–ï¸ Kelly: <b>{kelly_ratio:.1%}</b>
ğŸ’µ ìˆ˜ëŸ‰: <b>{position.quantity:.6f}</b>
ğŸ’¸ ë§ˆì§„: <b>${position.margin_required:,.2f}</b>

ğŸ“Š ì˜ˆìƒ P&L: <b>-${pnl_range_low:.0f}</b> ~ <b>+${pnl_range_high:.0f}</b>
ğŸ†” <code>{position.position_id}</code>"""
            
            await self.send_message(message, "SUCCESS")
            
        except Exception as e:
            logging.error(f"ê±°ë˜ ì•Œë¦¼ ìƒì„± ì˜¤ë¥˜: {e}")
            await self.send_message(f"ê±°ë˜ ì‹¤í–‰ë¨: {position.symbol}", "INFO")
    
    async def send_close_notification(self, position: Position, exit_reason: str):
        """í¬ì§€ì…˜ ì²­ì‚° ì•Œë¦¼"""
        try:
            pnl_emoji = "ğŸ“ˆ" if position.realized_pnl > 0 else "ğŸ“‰"
            reason_emojis = {
                "TAKE_PROFIT": "ğŸ¯", "STOP_LOSS": "ğŸ›¡ï¸", 
                "EMERGENCY_LIQUIDATION": "ğŸš¨", "MANUAL": "ğŸ‘¤"
            }
            
            duration = ""
            if position.exit_time and position.created_at:
                duration_mins = int((position.exit_time - position.created_at).total_seconds() / 60)
                duration = f"â±ï¸ <b>{duration_mins}ë¶„</b>\n"
            
            message = f"""{pnl_emoji} <b>í¬ì§€ì…˜ ì²­ì‚°</b> {reason_emojis.get(exit_reason, "ğŸ“")}

ğŸ“Š <b>{position.symbol}</b> {position.side} {position.leverage}x
ğŸ’° ì§„ì…: <b>${position.entry_price:,.2f}</b>
ğŸ’¸ ì²­ì‚°: <b>${position.exit_price:,.2f}</b>
{duration}ğŸ’µ P&L: <b>${position.realized_pnl:,.2f}</b> ({position.pnl_percentage:+.1f}%)
ğŸ“‹ <b>{exit_reason.replace('_', ' ')}</b>

ğŸ†” <code>{position.position_id}</code>"""
            
            level = "SUCCESS" if position.realized_pnl > 0 else "WARNING"
            await self.send_message(message, level)
            
        except Exception as e:
            logging.error(f"ì²­ì‚° ì•Œë¦¼ ìƒì„± ì˜¤ë¥˜: {e}")
            await self.send_message(f"í¬ì§€ì…˜ ì²­ì‚°ë¨: {position.symbol}", "INFO")
    
    async def send_liquidation_warning(self, position: Position):
        """ì²­ì‚° ìœ„í—˜ ê²½ê³ """
        try:
            message = f"""ğŸ†˜ <b>ì²­ì‚° ìœ„í—˜</b>

ğŸ“Š <b>{position.symbol}</b> {position.side} {position.leverage}x
ğŸ’° ì§„ì…: <b>${position.entry_price:,.2f}</b>
ğŸ’¸ í˜„ì¬: <b>${position.current_price:,.2f}</b>
ğŸš¨ ì²­ì‚°: <b>${position.liquidation_price:,.2f}</b>

âš ï¸ ìœ„í—˜ë„: <b>{position.liquidation_risk:.1%}</b>
ğŸ’” P&L: <b>${position.unrealized_pnl:,.2f}</b>

ğŸ†” <code>{position.position_id}</code>"""
            
            await self.send_message(message, "CRITICAL")
            
        except Exception as e:
            logging.error(f"ì²­ì‚° ê²½ê³  ìƒì„± ì˜¤ë¥˜: {e}")
    
    async def send_system_notification(self, message: str, level: str = "INFO"):
        """ì‹œìŠ¤í…œ ì•Œë¦¼"""
        system_message = f"""ğŸ–¥ï¸ <b>Phoenix 95 System</b>

{message}

ğŸ• {datetime.utcnow().strftime('%H:%M:%S UTC')}"""
        
        await self.send_message(system_message, level)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ”’ ë³´ì•ˆ ê´€ë¦¬ì (ê°•í™”)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SecurityManager:
    """ë³´ì•ˆ ê´€ë¦¬ì - ì™„ì „ ê°•í™”"""
    
    def __init__(self):
        self.secure_config = SystemConfig.get_secure_config()
        self.failed_attempts = {}  # IPë³„ ì‹¤íŒ¨ íšŸìˆ˜
        self.rate_limits = {}      # IPë³„ ìš”ì²­ ì œí•œ
        
    def verify_webhook_signature(self, payload: str, signature: str) -> bool:
        """ì›¹í›… ì„œëª… ê²€ì¦ - ê°•í™”"""
        try:
            if not payload or not signature:
                return False
            
            # íƒ€ì´ë° ê³µê²© ë°©ì§€ë¥¼ ìœ„í•œ ìƒìˆ˜ ì‹œê°„ ë¹„êµ
            expected_signature = hmac.new(
                self.secure_config["webhook_secret"].encode('utf-8'),
                payload.encode('utf-8'),
                hashlib.sha256
            ).hexdigest()
            
            # HMAC ë¹„êµ (íƒ€ì´ë° ê³µê²© ë°©ì§€)
            return hmac.compare_digest(
                f"sha256={expected_signature}",
                signature
            )
            
        except Exception as e:
            logging.error(f"ì„œëª… ê²€ì¦ ì˜¤ë¥˜: {e}")
            return False
    
    def verify_api_key(self, api_key: str) -> bool:
        """API í‚¤ ê²€ì¦"""
        try:
            if not api_key:
                return False
            
            return hmac.compare_digest(
                api_key,
                self.secure_config["api_key"]
            )
        except Exception as e:
            logging.error(f"API í‚¤ ê²€ì¦ ì˜¤ë¥˜: {e}")
            return False
    
    def check_rate_limit(self, ip: str, max_requests: int = 60, window: int = 3600) -> bool:
        """ì†ë„ ì œí•œ ì²´í¬ (1ì‹œê°„ë‹¹ 60íšŒ)"""
        try:
            current_time = time.time()
            
            if ip not in self.rate_limits:
                self.rate_limits[ip] = []
            
            # ì˜¤ë˜ëœ ìš”ì²­ ì œê±°
            self.rate_limits[ip] = [
                req_time for req_time in self.rate_limits[ip]
                if current_time - req_time < window
            ]
            
            # ì œí•œ í™•ì¸
            if len(self.rate_limits[ip]) >= max_requests:
                return False
            
            # í˜„ì¬ ìš”ì²­ ì¶”ê°€
            self.rate_limits[ip].append(current_time)
            return True
            
        except Exception as e:
            logging.error(f"ì†ë„ ì œí•œ ì²´í¬ ì˜¤ë¥˜: {e}")
            return True  # ì˜¤ë¥˜ ì‹œ í—ˆìš©
    
    def log_failed_attempt(self, ip: str):
        """ì‹¤íŒ¨í•œ ì‹œë„ ë¡œê¹…"""
        try:
            current_time = time.time()
            
            if ip not in self.failed_attempts:
                self.failed_attempts[ip] = []
            
            self.failed_attempts[ip].append(current_time)
            
            # 1ì‹œê°„ ì´ë‚´ ì‹¤íŒ¨ íšŸìˆ˜ë§Œ ìœ ì§€
            self.failed_attempts[ip] = [
                attempt_time for attempt_time in self.failed_attempts[ip]
                if current_time - attempt_time < 3600
            ]
            
            # ë„ˆë¬´ ë§ì€ ì‹¤íŒ¨ ì‹œ ê²½ê³ 
            if len(self.failed_attempts[ip]) > 10:
                logging.warning(f"ì˜ì‹¬ìŠ¤ëŸ¬ìš´ í™œë™ ê°ì§€: IP {ip}ì—ì„œ {len(self.failed_attempts[ip])}íšŒ ì‹¤íŒ¨")
                
        except Exception as e:
            logging.error(f"ì‹¤íŒ¨ ë¡œê¹… ì˜¤ë¥˜: {e}")
    
    def is_ip_blocked(self, ip: str) -> bool:
        """IP ì°¨ë‹¨ ì—¬ë¶€ í™•ì¸"""
        try:
            if ip not in self.failed_attempts:
                return False
            
            # 1ì‹œê°„ ì´ë‚´ 20íšŒ ì´ìƒ ì‹¤íŒ¨ ì‹œ ì°¨ë‹¨
            recent_failures = [
                attempt for attempt in self.failed_attempts[ip]
                if time.time() - attempt < 3600
            ]
            
            return len(recent_failures) >= 20
            
        except Exception as e:
            logging.error(f"IP ì°¨ë‹¨ í™•ì¸ ì˜¤ë¥˜: {e}")
            return False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ” API ì¸ì¦ ì‹œìŠ¤í…œ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class APIKeyAuth:
    """API í‚¤ ì¸ì¦"""
    
    def __init__(self, security_manager: SecurityManager):
        self.security = security_manager
        self.bearer = HTTPBearer(auto_error=False)
    
    async def __call__(self, request: Request, credentials: HTTPAuthorizationCredentials = Depends(HTTPBearer(auto_error=False))):
        """API í‚¤ ê²€ì¦"""
        # API í‚¤ê°€ í•„ìš”í•œ ì—”ë“œí¬ì¸íŠ¸ì¸ì§€ í™•ì¸
        protected_paths = ["/admin/", "/system/"]
        
        if not any(request.url.path.startswith(path) for path in protected_paths):
            return True  # ë³´í˜¸ë˜ì§€ ì•ŠëŠ” ê²½ë¡œ
        
        # Authorization í—¤ë” í™•ì¸
        if not credentials:
            api_key = request.headers.get("X-API-Key")
            if not api_key:
                raise HTTPException(
                    status_code=401,
                    detail="API í‚¤ê°€ í•„ìš”í•©ë‹ˆë‹¤",
                    headers={"WWW-Authenticate": "Bearer"},
                )
        else:
            api_key = credentials.credentials
        
        # API í‚¤ ê²€ì¦
        if not self.security.verify_api_key(api_key):
            client_ip = request.client.host
            self.security.log_failed_attempt(client_ip)
            raise HTTPException(
                status_code=401,
                detail="ì˜ëª»ëœ API í‚¤",
                headers={"WWW-Authenticate": "Bearer"},
            )
        
        return True

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ’¾ ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ì (í™•ì¥)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class DatabaseManager:
    """ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ê´€ë¦¬ ë° ë§ˆì´ê·¸ë ˆì´ì…˜"""
    
    @staticmethod
    async def create_tables(postgres_pool):
        """í•„ìˆ˜ í…Œì´ë¸” ìƒì„±"""
        try:
            async with postgres_pool.acquire() as conn:
                # ì‹ í˜¸ í…Œì´ë¸”
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS signals (
                        signal_id VARCHAR(50) PRIMARY KEY,
                        symbol VARCHAR(20) NOT NULL,
                        action VARCHAR(10) NOT NULL,
                        price DECIMAL(20,8) NOT NULL,
                        confidence DECIMAL(5,4) NOT NULL,
                        phoenix95_score DECIMAL(5,4),
                        kelly_ratio DECIMAL(5,4),
                        recommendation VARCHAR(20),
                        timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
                        processed BOOLEAN DEFAULT FALSE,
                        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # í¬ì§€ì…˜ í…Œì´ë¸”
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS positions (
                        position_id VARCHAR(50) PRIMARY KEY,
                        signal_id VARCHAR(50),
                        symbol VARCHAR(20) NOT NULL,
                        side VARCHAR(10) NOT NULL,
                        entry_price DECIMAL(20,8) NOT NULL,
                        quantity DECIMAL(20,8) NOT NULL,
                        leverage INTEGER NOT NULL,
                        margin_mode VARCHAR(20) NOT NULL,
                        margin_required DECIMAL(20,8) NOT NULL,
                        liquidation_price DECIMAL(20,8) NOT NULL,
                        stop_loss_price DECIMAL(20,8) NOT NULL,
                        take_profit_price DECIMAL(20,8) NOT NULL,
                        current_price DECIMAL(20,8) DEFAULT 0,
                        unrealized_pnl DECIMAL(20,8) DEFAULT 0,
                        pnl_percentage DECIMAL(10,4) DEFAULT 0,
                        liquidation_risk DECIMAL(5,4) DEFAULT 0,
                        status VARCHAR(20) DEFAULT 'OPEN',
                        exit_price DECIMAL(20,8),
                        exit_time TIMESTAMP WITH TIME ZONE,
                        exit_reason VARCHAR(50),
                        realized_pnl DECIMAL(20,8),
                        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # ê±°ë˜ ì´ë ¥ í…Œì´ë¸”
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS trade_history (
                        id SERIAL PRIMARY KEY,
                        position_id VARCHAR(50) UNIQUE NOT NULL,
                        symbol VARCHAR(20) NOT NULL,
                        side VARCHAR(10) NOT NULL,
                        entry_price DECIMAL(20,8) NOT NULL,
                        exit_price DECIMAL(20,8) NOT NULL,
                        quantity DECIMAL(20,8) NOT NULL,
                        leverage INTEGER NOT NULL,
                        pnl DECIMAL(20,8) NOT NULL,
                        pnl_percentage DECIMAL(10,4) NOT NULL,
                        duration_minutes INTEGER NOT NULL,
                        entry_time TIMESTAMP WITH TIME ZONE NOT NULL,
                        exit_time TIMESTAMP WITH TIME ZONE NOT NULL,
                        exit_reason VARCHAR(50) NOT NULL,
                        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # ì¸ë±ìŠ¤ ìƒì„±
                await conn.execute("CREATE INDEX IF NOT EXISTS idx_signals_timestamp ON signals(timestamp)")
                await conn.execute("CREATE INDEX IF NOT EXISTS idx_signals_symbol ON signals(symbol)")
                await conn.execute("CREATE INDEX IF NOT EXISTS idx_positions_symbol ON positions(symbol)")
                await conn.execute("CREATE INDEX IF NOT EXISTS idx_positions_status ON positions(status)")
                await conn.execute("CREATE INDEX IF NOT EXISTS idx_trade_history_entry_time ON trade_history(entry_time)")
                
                logging.info("ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸” ìƒì„±/í™•ì¸ ì™„ë£Œ")
                
        except Exception as e:
            logging.error(f"ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸” ìƒì„± ì‹¤íŒ¨: {e}")
            raise

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“ˆ Binance API ì—°ë™
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class BinanceAPIClient:
    """Binance API í´ë¼ì´ì–¸íŠ¸"""
    
    def __init__(self):
        self.base_url = "https://api.binance.com"
        self.session = None
        self.api_key = os.getenv("BINANCE_API_KEY")
        self.api_secret = os.getenv("BINANCE_API_SECRET")
        self.testnet = os.getenv("BINANCE_TESTNET", "true").lower() == "true"
        
        if self.testnet:
            self.base_url = "https://testnet.binance.vision"
        
        self.rate_limiter = asyncio.Semaphore(10)  # ì´ˆë‹¹ 10ê°œ ìš”ì²­ ì œí•œ
    
    async def __aenter__(self):
        """ë¹„ë™ê¸° ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì € ì§„ì…"""
        self.session = aiohttp.ClientSession(
            timeout=aiohttp.ClientTimeout(total=30),
            headers={
                "X-MBX-APIKEY": self.api_key or ""
            }
        )
        return self
    
    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """ë¹„ë™ê¸° ì»¨í…ìŠ¤íŠ¸ ë§¤ë‹ˆì € ì¢…ë£Œ"""
        if self.session:
            await self.session.close()
    
    async def get_symbol_price(self, symbol: str) -> Optional[float]:
        """ì‹¬ë³¼ í˜„ì¬ê°€ ì¡°íšŒ"""
        try:
            async with self.rate_limiter:
                url = f"{self.base_url}/api/v3/ticker/price"
                params = {"symbol": symbol}
                
                async with self.session.get(url, params=params) as response:
                    if response.status == 200:
                        data = await response.json()
                        return float(data['price'])
                    else:
                        logging.warning(f"Binance API ì˜¤ë¥˜: {response.status}")
                        return None
                        
        except Exception as e:
            logging.error(f"Binance ê°€ê²© ì¡°íšŒ ì‹¤íŒ¨ {symbol}: {e}")
            return None

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“Š ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SystemMonitor:
    """ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§"""
    
    def __init__(self, redis_client, postgres_pool, telegram_notifier):
        self.redis = redis_client
        self.postgres = postgres_pool
        self.telegram = telegram_notifier
        self.metrics_history = deque(maxlen=1440)  # 24ì‹œê°„ (ë¶„ë‹¹ 1ê°œ)
        
    async def collect_system_metrics(self) -> Optional[PerformanceMetrics]:
        """ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘"""
        try:
            import psutil
            
            # ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤
            cpu_usage = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            memory_usage = memory.percent
            
            # ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìˆ˜
            active_connections = 0
            try:
                async with self.postgres.acquire() as conn:
                    active_connections = await conn.fetchval(
                        "SELECT count(*) FROM pg_stat_activity WHERE state = 'active'"
                    )
            except:
                pass
            
            # íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­
            trading_metrics = await self._get_trading_metrics()
            
            metrics = PerformanceMetrics(
                timestamp=datetime.utcnow(),
                cpu_usage=cpu_usage,
                memory_usage=memory_usage,
                response_time_ms=0.0,  # APIì—ì„œ ì¸¡ì •
                active_connections=active_connections or 0,
                active_positions=trading_metrics.get('active_positions', 0),
                total_pnl=trading_metrics.get('total_pnl', 0.0),
                win_rate=trading_metrics.get('win_rate', 0.0),
                avg_trade_duration=trading_metrics.get('avg_duration', 0.0),
                phoenix95_avg_score=trading_metrics.get('avg_score', 0.0),
                max_drawdown=trading_metrics.get('max_drawdown', 0.0),
                var_95=trading_metrics.get('var_95', 0.0),
                sharpe_ratio=trading_metrics.get('sharpe_ratio', 0.0)
            )
            
            self.metrics_history.append(metrics)
            return metrics
            
        except Exception as e:
            logging.error(f"ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤íŒ¨: {e}")
            return None
    
    async def _get_trading_metrics(self) -> Dict:
        """íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­ ìˆ˜ì§‘"""
        try:
            async with self.postgres.acquire() as conn:
                # ì˜¤ëŠ˜ í†µê³„
                today_stats = await conn.fetchrow("""
                    SELECT 
                        COUNT(*) as total_trades,
                        COUNT(*) FILTER (WHERE pnl > 0) as winning_trades,
                        COALESCE(SUM(pnl), 0) as total_pnl,
                        COALESCE(AVG(duration_minutes), 0) as avg_duration
                    FROM trade_history 
                    WHERE DATE(entry_time) = CURRENT_DATE
                """)
                
                # í™œì„± í¬ì§€ì…˜
                active_positions = await conn.fetchval(
                    "SELECT COUNT(*) FROM positions WHERE status = 'OPEN'"
                )
                
                win_rate = 0.0
                if today_stats and today_stats['total_trades'] > 0:
                    win_rate = (today_stats['winning_trades'] / today_stats['total_trades']) * 100
                
                return {
                    'active_positions': active_positions or 0,
                    'total_pnl': float(today_stats['total_pnl']) if today_stats else 0.0,
                    'win_rate': win_rate,
                    'avg_duration': float(today_stats['avg_duration']) if today_stats else 0.0,
                    'avg_score': 0.85,  # Phoenix 95 í‰ê·  ì ìˆ˜
                    'max_drawdown': 0.0,
                    'var_95': 0.0,
                    'sharpe_ratio': 0.0
                }
                
        except Exception as e:
            logging.error(f"íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤íŒ¨: {e}")
            return {}
    
    async def check_alerts(self, metrics: PerformanceMetrics):
        """ì•Œë¦¼ ì²´í¬"""
        alerts = []
        thresholds = SystemConfig.MONITORING["performance_threshold"]
        
        # CPU ì‚¬ìš©ë¥  ì²´í¬
        if metrics.cpu_usage > thresholds["cpu_usage_pct"]:
            alerts.append(f"ë†’ì€ CPU ì‚¬ìš©ë¥ : {metrics.cpu_usage:.1f}%")
        
        # ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ì²´í¬
        if metrics.memory_usage > thresholds["memory_usage_pct"]:
            alerts.append(f"ë†’ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : {metrics.memory_usage:.1f}%")
        
        # ì•Œë¦¼ ì „ì†¡
        for alert in alerts:
            await self.telegram.send_system_notification(alert, "WARNING")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“Š ë¡œê·¸ ê´€ë¦¬ì
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class LogManager:
    """ë¡œê·¸ ê´€ë¦¬ ë° ë¡œí…Œì´ì…˜"""
    
    @staticmethod
    def setup_logging(log_level: str = "INFO", max_file_size: int = 50 * 1024 * 1024):
        """ë¡œê¹… ì„¤ì • (ë¡œí…Œì´ì…˜ í¬í•¨)"""
        import logging.handlers
        
        # ë¡œê·¸ ë ˆë²¨ ì„¤ì •
        log_level_map = {
            "DEBUG": logging.DEBUG,
            "INFO": logging.INFO,
            "WARNING": logging.WARNING,
            "ERROR": logging.ERROR,
            "CRITICAL": logging.CRITICAL
        }
        
        level = log_level_map.get(log_level.upper(), logging.INFO)
        
        # ì»¤ìŠ¤í…€ í¬ë§¤í„° (ë¯¼ê°ì •ë³´ ë§ˆìŠ¤í‚¹)
        class SafeFormatter(logging.Formatter):
            def format(self, record):
                original_msg = record.getMessage()
                safe_msg = EnhancedSecurity.sanitize_log_message(original_msg)
                record.msg = safe_msg
                record.args = ()
                return super().format(record)
        
        formatter = SafeFormatter(
            '%(asctime)s - %(name)s - %(levelname)s - %(message)s'
        )
        
        # íŒŒì¼ í•¸ë“¤ëŸ¬ (ë¡œí…Œì´ì…˜)
        file_handler = logging.handlers.RotatingFileHandler(
            'phoenix95_ultimate.log',
            maxBytes=max_file_size,
            backupCount=5,
            encoding='utf-8'
        )
        file_handler.setFormatter(formatter)
        file_handler.setLevel(level)
        
        # ì½˜ì†” í•¸ë“¤ëŸ¬
        console_handler = logging.StreamHandler(sys.stdout)
        console_handler.setFormatter(formatter)
        console_handler.setLevel(level)
        
        # ë£¨íŠ¸ ë¡œê±° ì„¤ì •
        root_logger = logging.getLogger()
        root_logger.setLevel(level)
        root_logger.handlers.clear()
        root_logger.addHandler(file_handler)
        root_logger.addHandler(console_handler)
        
        # íŠ¹ì • ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œê·¸ ë ˆë²¨ ì¡°ì •
        logging.getLogger("aiohttp").setLevel(logging.WARNING)
        logging.getLogger("asyncio").setLevel(logging.WARNING)
        logging.getLogger("urllib3").setLevel(logging.WARNING)
        

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸš€ ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ (ì™„ì „ ì•ˆì „)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Phoenix95UltimateSystem:
    """Phoenix 95 Ultimate ì‹œìŠ¤í…œ - ì™„ì „ ì•ˆì „ ë²„ì „"""
    
    def __init__(self):
        # í•µì‹¬ ì»´í¬ë„ŒíŠ¸
        self.phoenix95_engine = Phoenix95AIEngine()
        self.telegram = UltimateTelegramNotifier()
        self.security = SecurityManager()
        self.api_auth = APIKeyAuth(self.security)
        
        # ë°ì´í„°ë² ì´ìŠ¤
        self.redis_client = None
        self.postgres_pool = None
        self.trader = None
        self.monitor = None
        
        # ì‹œì‘ ì‹œê°„ ê¸°ë¡
        self._start_time = time.time()
        
        # FastAPI ì•±
        self.app = FastAPI(
            title="Phoenix 95 Ultimate Trading System",
            description="ì™„ì „ ë³´ì•ˆ ê°•í™” ë° ì•ˆì •ì„± ë³´ì¥ ë²„ì „",
            version="Ultimate-Safe-1.0.0"
        )
        
        self._setup_middleware()
        self._setup_routes()
        
    def _setup_middleware(self):
        """ë¯¸ë“¤ì›¨ì–´ ì„¤ì •"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["https://localhost", "https://127.0.0.1"],  # ë³´ì•ˆ ê°•í™”
            allow_credentials=True,
            allow_methods=["GET", "POST"],  # í•„ìš”í•œ ë©”ì„œë“œë§Œ
            allow_headers=["*"],
        )
    
    def _setup_routes(self):
        """API ë¼ìš°íŠ¸ ì„¤ì • - ë³´ì•ˆ ê°•í™”"""
        
        @self.app.on_event("startup")
        async def startup_event():
            await self.initialize()
        
        @self.app.on_event("shutdown")
        async def shutdown_event():
            await self.cleanup()
        
        @self.app.middleware("http")
        async def security_middleware(request: Request, call_next):
            """ë³´ì•ˆ ë¯¸ë“¤ì›¨ì–´"""
            try:
                client_ip = request.client.host
                
                # IP ì°¨ë‹¨ í™•ì¸
                if self.security.is_ip_blocked(client_ip):
                    raise HTTPException(status_code=429, detail="IPê°€ ì°¨ë‹¨ë˜ì—ˆìŠµë‹ˆë‹¤")
                
                # ì†ë„ ì œí•œ í™•ì¸
                if not self.security.check_rate_limit(client_ip):
                    raise HTTPException(status_code=429, detail="ìš”ì²­ í•œë„ ì´ˆê³¼")
                
                response = await call_next(request)
                return response
                
            except HTTPException:
                raise
            except Exception as e:
                logging.error(f"ë³´ì•ˆ ë¯¸ë“¤ì›¨ì–´ ì˜¤ë¥˜: {e}")
                raise HTTPException(status_code=500, detail="ì„œë²„ ì˜¤ë¥˜")
        
        @self.app.post("/webhook/tradingview")
        async def receive_tradingview_signal(
            request: Request,
            background_tasks: BackgroundTasks,
            webhook_data: TradingViewWebhookModel = Body(...)
        ):
            """TradingView ì‹ í˜¸ ìˆ˜ì‹  - ì™„ì „ ê²€ì¦"""
            client_ip = request.client.host
            
            try:
                # ì›¹í›… ì„œëª… ê²€ì¦ (ì„ íƒì‚¬í•­)
                signature = request.headers.get("X-Signature") or request.headers.get("X-Hub-Signature-256")
                if signature:
                    body = await request.body()
                    if not self.security.verify_webhook_signature(body.decode(), signature):
                        self.security.log_failed_attempt(client_ip)
                        raise HTTPException(status_code=401, detail="ì˜ëª»ëœ ì›¹í›… ì„œëª…")
                
                # ì‹ í˜¸ ìƒì„±
                signal = TradingSignal(
                    signal_id=f"SIG_{uuid.uuid4().hex[:8].upper()}",
                    symbol=webhook_data.symbol,
                    action=webhook_data.action,
                    price=webhook_data.price,
                    confidence=webhook_data.confidence,
                    timestamp=datetime.utcnow()
                )
                
                # ì¶”ê°€ ì‹œì¥ ë°ì´í„°ê°€ ìˆë‹¤ë©´ í¬í•¨
                if webhook_data.volume or webhook_data.rsi:
                    signal.market_conditions = {
                        "volume": webhook_data.volume,
                        "rsi": webhook_data.rsi,
                        "timestamp": webhook_data.timestamp
                    }
                
                # ìµœì¢… ìœ íš¨ì„± ê²€ì¦
                if not signal.is_valid():
                    self.security.log_failed_attempt(client_ip)
                    raise HTTPException(status_code=400, detail="ì˜ëª»ëœ ì‹ í˜¸ ë°ì´í„°")
                
                # ë°±ê·¸ë¼ìš´ë“œ ì²˜ë¦¬
                background_tasks.add_task(self._process_signal_complete, signal)
                
                # ì„±ê³µ ì‘ë‹µ
                return JSONResponse(
                    status_code=200,
                    content={
                        "status": "received",
                        "signal_id": signal.signal_id,
                        "timestamp": signal.timestamp.isoformat(),
                        "validation": "passed",
                        "symbol": signal.symbol,
                        "action": signal.action,
                        "processing": "background"
                    }
                )
                
            except HTTPException:
                raise
            except Exception as e:
                error_msg = f"ì‹ í˜¸ ìˆ˜ì‹  ì‹¤íŒ¨: {e}"
                logging.error(error_msg)
                self.security.log_failed_attempt(client_ip)
                raise HTTPException(status_code=500, detail="ì‹ í˜¸ ì²˜ë¦¬ ì˜¤ë¥˜")
        
        @self.app.get("/health")
        async def health_check():
            """í—¬ìŠ¤ì²´í¬ - ìƒì„¸ ì§„ë‹¨"""
            try:
                health_status = {
                    "status": "healthy",
                    "timestamp": datetime.utcnow().isoformat(),
                    "version": "Ultimate-Safe-1.0.0",
                    "system": "Phoenix 95 Ultimate Trading System",
                    "components": {},
                    "metrics": {}
                }
                
                # ë°ì´í„°ë² ì´ìŠ¤ ì²´í¬
                db_healthy = False
                try:
                    if self.postgres_pool:
                        async with self.postgres_pool.acquire() as conn:
                            await conn.fetchval("SELECT 1")
                        db_healthy = True
                except Exception as e:
                    logging.error(f"DB í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨: {e}")
                
                # Redis ì²´í¬
                redis_healthy = False
                try:
                    if self.redis_client:
                        await self.redis_client.ping()
                        redis_healthy = True
                except Exception as e:
                    logging.error(f"Redis í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨: {e}")
                
                # ì»´í¬ë„ŒíŠ¸ ìƒíƒœ
                health_status["components"] = {
                    "database": "healthy" if db_healthy else "error",
                    "redis": "healthy" if redis_healthy else "error",
                    "ai_engine": "healthy",
                    "trading_engine": "healthy" if self.trader else "error",
                    "telegram": "healthy"
                }
                
                # ì „ì²´ ìƒíƒœ ê²°ì •
                if not all(status == "healthy" for status in health_status["components"].values()):
                    health_status["status"] = "degraded"
                
                # í¬íŠ¸í´ë¦¬ì˜¤ ì •ë³´
                if self.trader:
                    health_status["portfolio"] = self.trader.get_portfolio_summary()
                
                return health_status
                
            except Exception as e:
                logging.error(f"í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨: {e}")
                return {
                    "status": "error",
                    "timestamp": datetime.utcnow().isoformat(),
                    "error": str(e)
                }
        
        @self.app.get("/positions")
        async def get_active_positions():
            """í™œì„± í¬ì§€ì…˜ ì¡°íšŒ"""
            try:
                if not self.trader:
                    return {"positions": [], "count": 0, "status": "trader_not_initialized"}
                
                positions = []
                
                # ìŠ¤ë ˆë“œ ì•ˆì „í•œ í¬ì§€ì…˜ ì¡°íšŒ
                async with self.trader._positions_lock:
                    for position in self.trader.active_positions.values():
                        try:
                            positions.append({
                                "position_id": str(position.position_id),
                                "symbol": str(position.symbol),
                                "side": str(position.side),
                                "entry_price": float(position.entry_price),
                                "current_price": float(position.current_price),
                                "quantity": float(position.quantity),
                                "leverage": int(position.leverage),
                                "margin_required": float(position.margin_required),
                                "unrealized_pnl": float(position.unrealized_pnl),
                                "pnl_percentage": float(position.pnl_percentage),
                                "liquidation_risk": float(position.liquidation_risk),
                                "liquidation_price": float(position.liquidation_price),
                                "stop_loss_price": float(position.stop_loss_price),
                                "take_profit_price": float(position.take_profit_price),
                                "status": str(position.status),
                                "created_at": position.created_at.isoformat(),
                                "risk_level": "HIGH" if position.liquidation_risk > 0.8 else "MEDIUM" if position.liquidation_risk > 0.5 else "LOW"
                            })
                        except Exception as e:
                            logging.error(f"í¬ì§€ì…˜ ì§ë ¬í™” ì˜¤ë¥˜: {e}")
                            continue
                
                portfolio_summary = self.trader.get_portfolio_summary()
                
                return {
                    "positions": positions,
                    "count": len(positions),
                    "summary": portfolio_summary,
                    "timestamp": datetime.utcnow().isoformat()
                }
                
            except Exception as e:
                logging.error(f"í¬ì§€ì…˜ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail="í¬ì§€ì…˜ ì¡°íšŒ ì˜¤ë¥˜")
        
        @self.app.get("/performance")
        async def get_performance_stats():
            """ì„±ëŠ¥ í†µê³„ ì¡°íšŒ"""
            try:
                # AI ì—”ì§„ ì„±ëŠ¥
                ai_stats = self.phoenix95_engine.get_performance_stats()
                
                # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­
                latest_metrics = None
                if self.monitor and self.monitor.metrics_history:
                    latest_metrics = self.monitor.metrics_history[-1]
                
                # ê±°ë˜ í†µê³„
                trading_stats = {}
                if self.postgres_pool:
                    async with self.postgres_pool.acquire() as conn:
                        trading_stats = await conn.fetchrow("""
                            SELECT 
                                COUNT(*) as total_trades,
                                COUNT(*) FILTER (WHERE pnl > 0) as winning_trades,
                                COALESCE(SUM(pnl), 0) as total_pnl,
                                COALESCE(AVG(pnl), 0) as avg_pnl,
                                COALESCE(MAX(pnl), 0) as best_trade,
                                COALESCE(MIN(pnl), 0) as worst_trade
                            FROM trade_history 
                            WHERE entry_time >= CURRENT_DATE - INTERVAL '7 days'
                        """)
                
                return {
                    "ai_engine": ai_stats,
                    "system_metrics": asdict(latest_metrics) if latest_metrics else {},
                    "trading_stats": dict(trading_stats) if trading_stats else {},
                    "timestamp": datetime.utcnow().isoformat()
                }
                
            except Exception as e:
                logging.error(f"ì„±ëŠ¥ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.post("/admin/emergency_close", dependencies=[Depends(self.api_auth)])
        async def emergency_close_position(close_request: EmergencyCloseModel):
            """ê¸´ê¸‰ í¬ì§€ì…˜ ì²­ì‚°"""
            try:
                if not self.trader:
                    raise HTTPException(status_code=503, detail="íŠ¸ë ˆì´ë”ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
                
                position_id = close_request.position_id
                
                # í¬ì§€ì…˜ ì¡´ì¬ í™•ì¸
                async with self.trader._positions_lock:
                    if position_id not in self.trader.active_positions:
                        raise HTTPException(status_code=404, detail="í¬ì§€ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
                    
                    position = self.trader.active_positions[position_id]
                
                # í˜„ì¬ê°€ ì¡°íšŒ
                current_price = await self.trader._get_current_price(position.symbol)
                
                # í¬ì§€ì…˜ ì²­ì‚°
                await self.trader._close_position(position, current_price, close_request.reason)
                
                return {
                    "status": "success",
                    "message": f"í¬ì§€ì…˜ {position_id} ê¸´ê¸‰ ì²­ì‚° ì™„ë£Œ",
                    "timestamp": datetime.utcnow().isoformat(),
                    "final_price": current_price,
                    "reason": close_request.reason
                }
                
            except HTTPException:
                raise
            except Exception as e:
                logging.error(f"ê¸´ê¸‰ ì²­ì‚° ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=f"ì²­ì‚° ì˜¤ë¥˜: {str(e)}")
        
        @self.app.get("/system/info", dependencies=[Depends(self.api_auth)])
        async def get_system_info():
            """ì‹œìŠ¤í…œ ì •ë³´ ì¡°íšŒ"""
            try:
                import psutil
                
                system_info = {
                    "system": {
                        "name": "Phoenix 95 Ultimate Trading System",
                        "version": "Ultimate-Safe-1.0.0",
                        "uptime_seconds": time.time() - self._start_time,
                        "python_version": sys.version,
                        "platform": sys.platform
                    },
                    "hardware": {
                        "cpu_count": psutil.cpu_count(),
                        "memory_total_gb": round(psutil.virtual_memory().total / (1024**3), 2),
                        "memory_available_gb": round(psutil.virtual_memory().available / (1024**3), 2)
                    },
                    "configuration": {
                        "max_leverage": SystemConfig.TRADING["max_leverage"],
                        "max_positions": SystemConfig.TRADING["max_positions"],
                        "confidence_threshold": SystemConfig.TRADING["confidence_threshold"],
                        "position_size_pct": SystemConfig.TRADING["position_size_pct"],
                        "stop_loss_pct": SystemConfig.TRADING["stop_loss_pct"],
                        "take_profit_pct": SystemConfig.TRADING["take_profit_pct"],
                        "allowed_symbols": SystemConfig.TRADING["allowed_symbols"]
                    },
                    "features": {
                        "phoenix95_ai": True,
                        "leverage_trading": True,
                        "risk_management": True,
                        "telegram_alerts": True,
                        "real_time_monitoring": True,
                        "binance_integration": bool(os.getenv("BINANCE_API_KEY")),
                        "pydantic_validation": True
                    },
                    "timestamp": datetime.utcnow().isoformat()
                }
                
                return system_info
                
            except Exception as e:
                logging.error(f"ì‹œìŠ¤í…œ ì •ë³´ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail="ì‹œìŠ¤í…œ ì •ë³´ ì¡°íšŒ ì˜¤ë¥˜")
    
    async def initialize(self):
        """ì‹œìŠ¤í…œ ì´ˆê¸°í™”"""
        try:
            logging.info("Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹œì‘...")
            
            # 1. í™˜ê²½ë³€ìˆ˜ ë° ì„¤ì • ê²€ì¦
            secure_config = SystemConfig.get_secure_config()
            
            # 2. íŠ¸ë ˆì´ë”© íŒŒë¼ë¯¸í„° ë…¼ë¦¬ì  ê²€ì¦
            config_errors = EnhancedSecurity.validate_trading_parameters(SystemConfig.TRADING)
            if config_errors:
                error_msg = "ì„¤ì • ì˜¤ë¥˜: " + ", ".join(config_errors)
                logging.error(error_msg)
                raise ValueError(error_msg)
            
            # 3. Redis ì—°ê²°
            try:
                self.redis_client = await aioredis.from_url(
                    SystemConfig.DATABASE["redis_url"],
                    encoding="utf-8",
                    decode_responses=True,
                    socket_connect_timeout=10,
                    socket_timeout=10,
                    retry_on_timeout=True,
                    health_check_interval=30
                )
                await self.redis_client.ping()
                logging.info("âœ… Redis ì—°ê²° ì„±ê³µ")
            except Exception as e:
                logging.warning(f"Redis ì—°ê²° ì‹¤íŒ¨: {e}")
                # Redis ì—†ì´ë„ ë™ì‘ ê°€ëŠ¥í•˜ë„ë¡
                self.redis_client = None
            
            # 4. PostgreSQL ì—°ê²°
            try:
                self.postgres_pool = await asyncpg.create_pool(
                    SystemConfig.DATABASE["postgres_url"],
                    min_size=5,
                    max_size=SystemConfig.DATABASE["connection_pool_size"],
                    command_timeout=SystemConfig.DATABASE["connection_timeout"],
                    server_settings={
                        'application_name': 'phoenix95_ultimate',
                        'jit': 'off'
                    }
                )
                
                # ì—°ê²° í…ŒìŠ¤íŠ¸
                async with self.postgres_pool.acquire() as conn:
                    await conn.fetchval("SELECT version()")
                
                logging.info("âœ… PostgreSQL ì—°ê²° ì„±ê³µ")
            except Exception as e:
                logging.warning(f"PostgreSQL ì—°ê²° ì‹¤íŒ¨: {e}")
                # PostgreSQL ì—†ì´ë„ ë™ì‘ ê°€ëŠ¥í•˜ë„ë¡
                self.postgres_pool = None
            
            # 5. ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ ìƒì„±
            if self.postgres_pool:
                await DatabaseManager.create_tables(self.postgres_pool)
                logging.info("âœ… ë°ì´í„°ë² ì´ìŠ¤ ìŠ¤í‚¤ë§ˆ í™•ì¸ ì™„ë£Œ")
            
            # 6. íŠ¸ë ˆì´ë” ì´ˆê¸°í™”
            if self.postgres_pool:
                self.trader = UltimateLeverageTrader(
                    self.redis_client, 
                    self.postgres_pool, 
                    self.telegram
                )
                logging.info("âœ… ë ˆë²„ë¦¬ì§€ íŠ¸ë ˆì´ë” ì´ˆê¸°í™” ì™„ë£Œ")
            
            # 7. ëª¨ë‹ˆí„° ì´ˆê¸°í™”
            if self.postgres_pool:
                self.monitor = SystemMonitor(
                    self.redis_client,
                    self.postgres_pool,
                    self.telegram
                )
                logging.info("âœ… ì‹œìŠ¤í…œ ëª¨ë‹ˆí„° ì´ˆê¸°í™” ì™„ë£Œ")
                
                # ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì‹œì‘
                asyncio.create_task(self._monitoring_loop())
            
            # 8. ì‹œì‘ ì•Œë¦¼
            await self.telegram.send_system_notification(
                """ğŸ¯ <b>Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì‹œì‘</b>

âœ… ëª¨ë“  ë³´ì•ˆ ê²€ì¦ í†µê³¼
âœ… ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì™„ë£Œ
âœ… AI ì—”ì§„ ì¤€ë¹„ ì™„ë£Œ
âœ… ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ í™œì„±í™”

ğŸš€ í”„ë¡œë•ì…˜ í™˜ê²½ ì¤€ë¹„!""", 
                "SUCCESS"
            )
            
            logging.info("ğŸ‰ Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ!")
            
        except Exception as e:
            error_msg = EnhancedSecurity.sanitize_log_message(str(e))
            logging.error(f"ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨: {error_msg}")
            
            try:
                await self.telegram.send_system_notification(f"ğŸš¨ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨: {error_msg}", "ERROR")
            except:
                pass  # í…”ë ˆê·¸ë¨ ì‹¤íŒ¨ ì‹œì—ë„ ì‹œìŠ¤í…œì´ ì£½ì§€ ì•Šë„ë¡
            
            raise
    
    async def _monitoring_loop(self):
        """ëª¨ë‹ˆí„°ë§ ë£¨í”„"""
        while True:
            try:
                if self.monitor:
                    # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
                    metrics = await self.monitor.collect_system_metrics()
                    
                    if metrics:
                        # ì•Œë¦¼ ì²´í¬
                        await self.monitor.check_alerts(metrics)
                        
                        # Redisì— ìµœì‹  ë©”íŠ¸ë¦­ ì €ì¥
                        if self.redis_client:
                            await self.redis_client.hset("system:metrics", mapping={
                                "cpu_usage": metrics.cpu_usage,
                                "memory_usage": metrics.memory_usage,
                                "active_positions": metrics.active_positions,
                                "total_pnl": metrics.total_pnl,
                                "timestamp": metrics.timestamp.isoformat()
                            })
                
                # 30ì´ˆë§ˆë‹¤ ì‹¤í–‰
                await asyncio.sleep(SystemConfig.MONITORING["metrics_interval"])
                
            except Exception as e:
                logging.error(f"ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì˜¤ë¥˜: {e}")
                await asyncio.sleep(60)  # ì˜¤ë¥˜ ì‹œ 1ë¶„ ëŒ€ê¸°
    
    async def cleanup(self):
        """ì‹œìŠ¤í…œ ì •ë¦¬"""
        try:
            logging.info("ì‹œìŠ¤í…œ ì •ë¦¬ ì‹œì‘...")
            
            # ëª¨ë“  ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì·¨ì†Œ
            if self.trader:
                for task in list(self.trader.monitoring_tasks.values()):
                    if not task.done():
                        task.cancel()
                        try:
                            await task
                        except asyncio.CancelledError:
                            pass
            
            # ì—°ê²° ì •ë¦¬
            if self.redis_client:
                try:
                    await self.redis_client.close()
                except Exception as e:
                    logging.error(f"Redis ì •ë¦¬ ì˜¤ë¥˜: {e}")
            
            if self.postgres_pool:
                try:
                    await self.postgres_pool.close()
                except Exception as e:
                    logging.error(f"PostgreSQL ì •ë¦¬ ì˜¤ë¥˜: {e}")
            
            await self.telegram.send_system_notification("âœ… ì‹œìŠ¤í…œ ì •ìƒ ì¢…ë£Œ", "INFO")
            logging.info("ì‹œìŠ¤í…œ ì •ë¦¬ ì™„ë£Œ")
            
        except Exception as e:
            logging.error(f"ì‹œìŠ¤í…œ ì •ë¦¬ ì‹¤íŒ¨: {e}")
    
    async def _process_signal_complete(self, signal: TradingSignal):
        """ì™„ì „í•œ ì‹ í˜¸ ì²˜ë¦¬"""
        try:
            logging.info(f"ì‹ í˜¸ ì²˜ë¦¬ ì‹œì‘: {signal.signal_id}")
            
            # Phoenix 95 AI ë¶„ì„
            phoenix95_score, kelly_ratio, recommendation = await self.phoenix95_engine.analyze_signal_complete(signal)
            
            signal.phoenix95_score = phoenix95_score
            signal.kelly_ratio = kelly_ratio
            signal.recommendation = recommendation
            signal.processed = True
            
            logging.info(f"AI ë¶„ì„ ì™„ë£Œ: Phoenix95={phoenix95_score:.3f}, Kelly={kelly_ratio:.3f}, Rec={recommendation}")
            
            # ê±°ë˜ ì‹¤í–‰ ì¡°ê±´ í™•ì¸
            if recommendation in ["STRONG_BUY", "BUY", "WEAK_BUY"] and self.trader:
                position = await self.trader.execute_trade_complete(signal, phoenix95_score, kelly_ratio)
                
                if position:
                    logging.info(f"ê±°ë˜ ì‹¤í–‰ ì„±ê³µ: {position.position_id}")
                else:
                    logging.warning(f"ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨: {signal.signal_id}")
            else:
                logging.info(f"ê±°ë˜ ê±°ë¶€: {recommendation}")
                await self.telegram.send_system_notification(
                    f"""ğŸ“Š ì‹ í˜¸ ë¶„ì„ ì™„ë£Œ (ê±°ë˜ ê±°ë¶€)

ğŸ” {signal.symbol} {signal.action.upper()}
ğŸ’° ê°€ê²©: ${signal.price:,.2f}
ğŸ§  Phoenix95: {phoenix95_score:.1%}
âš–ï¸ Kelly: {kelly_ratio:.1%}
âŒ ì¶”ì²œ: {recommendation}""", 
                    "INFO"
                )
            
        except Exception as e:
            logging.error(f"ì‹ í˜¸ ì²˜ë¦¬ ì‹¤íŒ¨ {signal.signal_id}: {e}")
            signal.processed = False
            signal.error_message = str(e)
            
            await self.telegram.send_system_notification(
                f"ğŸš¨ ì‹ í˜¸ ì²˜ë¦¬ ì˜¤ë¥˜\n{signal.symbol}: {str(e)}", 
                "ERROR"
            )

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸš€ ì„œë²„ ì‹¤í–‰
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜"""
    
    # ë¡œê¹… ì‹œìŠ¤í…œ ì´ˆê¸°í™”
    LogManager.setup_logging(
        log_level=os.getenv("LOG_LEVEL", "INFO"),
        max_file_size=int(os.getenv("LOG_FILE_SIZE", str(50 * 1024 * 1024)))
    )
    
    # ì‹œìŠ¤í…œ ì‹œì‘ ë©”ì‹œì§€
    print("=" * 80)
    print("ğŸ¯ Phoenix 95 Ultimate Trading System - ìˆ˜ì •ëœ ì™„ì „ ë²„ì „")
    print("ğŸ›¡ï¸ ëª¨ë“  ë³´ì•ˆ, ì•ˆì •ì„±, ì„±ëŠ¥ ë¬¸ì œ í•´ê²°")
    print("âœ… í”„ë¡œë•ì…˜ í™˜ê²½ ì¤€ë¹„ ì™„ë£Œ")
    print("ğŸ‰ ì˜¤ë¥˜ ì—†ëŠ” ì™„ì „í•œ ë‹¨ì¼ íŒŒì¼")
    print("=" * 80)
    
    try:
        # í™˜ê²½ë³€ìˆ˜ ê²€ì¦
        SystemConfig.get_secure_config()
        
        # Phoenix 95 ì‹œìŠ¤í…œ ìƒì„±
        phoenix95_system = Phoenix95UltimateSystem()
        
        # FastAPI ì„œë²„ ì‹¤í–‰
        config = uvicorn.Config(
            phoenix95_system.app,
            host="0.0.0.0",
            port=int(os.getenv("PORT", "8080")),
            log_level="info",
            access_log=True,
            # ë³´ì•ˆ í—¤ë” ì¶”ê°€
            server_header=False,
            date_header=False
        )
        
        server = uvicorn.Server(config)
        await server.serve()
        
    except ValueError as e:
        print(f"\nâŒ ì„¤ì • ì˜¤ë¥˜: {e}")
        print("\nğŸ“‹ í•„ìˆ˜ í™˜ê²½ë³€ìˆ˜ ì„¤ì •:")
        print("export TELEGRAM_BOT_TOKEN='your_bot_token'")
        print("export TELEGRAM_CHAT_ID='your_chat_id'") 
        print("export WEBHOOK_SECRET='your_32_char_secret'")
        print("export API_KEY='your_api_key'")
        print("export POSTGRES_URL='postgresql://user:pass@host:5432/db'")
        print("export REDIS_URL='redis://host:6379'")
        print("export ACCOUNT_BALANCE='50000'")
        print("\nğŸ’¡ ì„ íƒì  í™˜ê²½ë³€ìˆ˜:")
        print("export BINANCE_API_KEY='your_binance_api_key'")
        print("export BINANCE_API_SECRET='your_binance_api_secret'")
        print("export BINANCE_TESTNET='true'")
        print("export USE_REAL_API='false'")
        print("export LOG_LEVEL='INFO'")
        sys.exit(1)
    except Exception as e:
        error_msg = EnhancedSecurity.sanitize_log_message(str(e))
        print(f"\nâŒ ì‹œìŠ¤í…œ ì˜¤ë¥˜: {error_msg}")
        sys.exit(1)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nğŸ‘‹ Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì¢…ë£Œ")
    except Exception as e:
        print(f"\nâŒ ì‹œìŠ¤í…œ ì˜¤ë¥˜: {e}")
        sys.exit(1)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“‹ ì‚¬ìš©ë²• ë° ì„¤ì • ê°€ì´ë“œ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
=== ğŸ“¦ requirements.txt ===
fastapi==0.104.1
uvicorn[standard]==0.24.0
asyncpg==0.29.0
aioredis==2.0.1
aiohttp==3.9.0
numpy==1.24.3
pandas==2.0.3
psutil==5.9.6
python-multipart==0.0.6
pydantic==2.5.0

=== ğŸš€ ë¹ ë¥¸ ì‹œì‘ ===
1. í•„ìˆ˜ í™˜ê²½ë³€ìˆ˜ ì„¤ì •:
   export TELEGRAM_BOT_TOKEN='your_bot_token'
   export TELEGRAM_CHAT_ID='your_chat_id'
   export WEBHOOK_SECRET='your_32_char_secret'
   export API_KEY='your_api_key'

2. ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì • (ì„ íƒì‚¬í•­):
   export POSTGRES_URL='postgresql://user:pass@host:5432/db'
   export REDIS_URL='redis://host:6379'

3. ì‹¤í–‰:
   python phoenix95_ultimate_fixed.py

=== ğŸ“Š API ì—”ë“œí¬ì¸íŠ¸ ===
â€¢ POST /webhook/tradingview - TradingView ì‹ í˜¸ ìˆ˜ì‹ 
â€¢ GET /health - ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸
â€¢ GET /positions - í™œì„± í¬ì§€ì…˜ ì¡°íšŒ
â€¢ GET /performance - ì„±ëŠ¥ í†µê³„
â€¢ GET /system/info - ì‹œìŠ¤í…œ ì •ë³´ (API í‚¤ í•„ìš”)
â€¢ POST /admin/emergency_close - ê¸´ê¸‰ ì²­ì‚° (API í‚¤ í•„ìš”)

=== ğŸ”§ ì£¼ìš” ìˆ˜ì • ì‚¬í•­ ===
âœ… ì¤‘ë³µ í´ë˜ìŠ¤ ì •ì˜ ì œê±°
âœ… ë¬¸ë²• ì˜¤ë¥˜ ìˆ˜ì •
âœ… import ìˆœì„œ ì •ë¦¬
âœ… í´ë˜ìŠ¤ ì˜ì¡´ì„± ìˆœì„œ ì¡°ì •
âœ… ëˆ„ë½ëœ ë©”ì„œë“œ ì™„ì„±
âœ… íƒ€ì… íŒíŠ¸ ê°œì„ 
âœ… ì˜¤ë¥˜ ì²˜ë¦¬ ê°•í™”
âœ… ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€
âœ… ìŠ¤ë ˆë“œ ì•ˆì „ì„± ë³´ì¥

ì´ì œ ëª¨ë“  ì˜¤ë¥˜ê°€ ìˆ˜ì •ë˜ì–´ ì•ˆì „í•˜ê²Œ ì‹¤í–‰í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤! ğŸ‰
"""
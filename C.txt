# ğŸ¦ Phoenix 95 í—¤ì§€í€ë“œê¸‰ ì‹œìŠ¤í…œ - ìˆ˜ì •ëœ ì™„ì „ ë²„ì „
# ì €ì: Phoenix 95 Team  
# ë²„ì „: 4.3.1 Fixed Edition
# ì„¤ëª…: ì˜¤ë¥˜ ìˆ˜ì • ë° ì¤‘ë³µ ì œê±°ëœ ì™„ì „í•œ êµ¬í˜„

import asyncio
import aiohttp
from fastapi import FastAPI, HTTPException, Request
from fastapi.middleware.base import BaseHTTPMiddleware
from fastapi.responses import HTMLResponse, PlainTextResponse
import uvicorn
from datetime import datetime, timedelta
import numpy as np
import os
from dataclasses import dataclass
from typing import Optional, Dict, List, Union
import requests
import multiprocessing
import json
import time
import threading
import hashlib
import hmac
import secrets
import logging
import re
import html
from pathlib import Path
import sys
import gzip

# ê³ ê¸‰ ê¸°ëŠ¥ import (ì„ íƒì )
try:
    from tenacity import retry, stop_after_attempt, wait_exponential
    TENACITY_AVAILABLE = True
except ImportError:
    TENACITY_AVAILABLE = False

try:
    import psutil
    PSUTIL_AVAILABLE = True
except ImportError:
    PSUTIL_AVAILABLE = False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”’ ë³´ì•ˆ ë¡œê¹… ì‹œìŠ¤í…œ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SecureLogger:
    """ë¯¼ê°ì •ë³´ë¥¼ í•„í„°ë§í•˜ëŠ” ì•ˆì „í•œ ë¡œê¹… ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.sensitive_patterns = [
            r'[A-Za-z0-9]{60,}',  # API í‚¤ íŒ¨í„´
            r'bot\d+:[A-Za-z0-9_-]+',  # í…”ë ˆê·¸ë¨ ë´‡ í† í°
            r'password["\']?\s*[:=]\s*["\']?([^"\']+)',  # íŒ¨ìŠ¤ì›Œë“œ
            r'secret["\']?\s*[:=]\s*["\']?([^"\']+)',  # ì‹œí¬ë¦¿
        ]
        
        # ë¡œê·¸ ì„¤ì •
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s [%(levelname)s] %(name)s: %(message)s',
            handlers=[
                logging.StreamHandler(sys.stdout)
            ]
        )
        self.logger = logging.getLogger("Phoenix95")
    
    def sanitize_log(self, message: str) -> str:
        """ë¡œê·¸ ë©”ì‹œì§€ì—ì„œ ë¯¼ê°ì •ë³´ ì œê±°"""
        message = str(message)
        for pattern in self.sensitive_patterns:
            message = re.sub(pattern, '[REDACTED]', message, flags=re.IGNORECASE)
        return message
    
    def info(self, message: str):
        self.logger.info(self.sanitize_log(message))
    
    def warning(self, message: str):
        self.logger.warning(self.sanitize_log(message))
    
    def error(self, message: str):
        self.logger.error(self.sanitize_log(message))

# ì „ì—­ ë³´ì•ˆ ë¡œê±°
secure_logger = SecureLogger()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“ ë¡œê·¸ ë¡œí…Œì´ì…˜ ì‹œìŠ¤í…œ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class LogRotationManager:
    """ë¡œê·¸ ë¡œí…Œì´ì…˜ ë° ì••ì¶• ê´€ë¦¬"""
    
    def __init__(self, max_file_size=50*1024*1024, max_files=10):  # 50MB, 10ê°œ íŒŒì¼
        self.max_file_size = max_file_size
        self.max_files = max_files
        self.log_dir = Path("logs")
        self.log_dir.mkdir(exist_ok=True)
        
        # ë§¤ì¼ ìì •ì— ë¡œê·¸ ë¡œí…Œì´ì…˜
        self._schedule_rotation()
    
    def _schedule_rotation(self):
        """ë¡œê·¸ ë¡œí…Œì´ì…˜ ìŠ¤ì¼€ì¤„ë§"""
        def rotation_worker():
            while True:
                try:
                    # ë‹¤ìŒ ìì •ê¹Œì§€ ëŒ€ê¸°
                    now = datetime.now()
                    tomorrow = now.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)
                    sleep_seconds = (tomorrow - now).total_seconds()
                    
                    time.sleep(sleep_seconds)
                    
                    # ë¡œê·¸ ë¡œí…Œì´ì…˜ ì‹¤í–‰
                    self.rotate_logs()
                    
                except Exception as e:
                    secure_logger.error(f"ë¡œê·¸ ë¡œí…Œì´ì…˜ ìŠ¤ì¼€ì¤„ë§ ì˜¤ë¥˜: {e}")
                    time.sleep(3600)  # 1ì‹œê°„ í›„ ì¬ì‹œë„
        
        rotation_thread = threading.Thread(target=rotation_worker, daemon=True)
        rotation_thread.start()
    
    def rotate_logs(self):
        """ë¡œê·¸ íŒŒì¼ ë¡œí…Œì´ì…˜"""
        try:
            log_files = list(self.log_dir.glob("phoenix95*.log"))
            
            for log_file in log_files:
                if log_file.stat().st_size > self.max_file_size:
                    self._rotate_file(log_file)
            
            # ì˜¤ë˜ëœ íŒŒì¼ ì •ë¦¬
            self._cleanup_old_files()
            
        except Exception as e:
            secure_logger.error(f"ë¡œê·¸ ë¡œí…Œì´ì…˜ ì˜¤ë¥˜: {e}")
    
    def _rotate_file(self, log_file: Path):
        """ê°œë³„ íŒŒì¼ ë¡œí…Œì´ì…˜"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        rotated_name = f"{log_file.stem}_{timestamp}.log"
        compressed_name = f"{rotated_name}.gz"
        
        # íŒŒì¼ ì´ë™
        rotated_path = self.log_dir / rotated_name
        log_file.rename(rotated_path)
        
        # ì••ì¶•
        with open(rotated_path, 'rb') as f_in:
            with gzip.open(self.log_dir / compressed_name, 'wb') as f_out:
                f_out.writelines(f_in)
        
        # ì›ë³¸ ì‚­ì œ
        rotated_path.unlink()
        
        secure_logger.info(f"ë¡œê·¸ íŒŒì¼ ë¡œí…Œì´ì…˜: {compressed_name}")
    
    def _cleanup_old_files(self):
        """ì˜¤ë˜ëœ ë¡œê·¸ íŒŒì¼ ì •ë¦¬"""
        compressed_files = sorted(
            self.log_dir.glob("phoenix95*.log.gz"),
            key=lambda x: x.stat().st_mtime,
            reverse=True
        )
        
        # ìµœëŒ€ íŒŒì¼ ìˆ˜ ì´ˆê³¼ì‹œ ì‚­ì œ
        for old_file in compressed_files[self.max_files:]:
            old_file.unlink()
            secure_logger.info(f"ì˜¤ë˜ëœ ë¡œê·¸ íŒŒì¼ ì‚­ì œ: {old_file.name}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ›¡ï¸ ë³´ì•ˆ ë¯¸ë“¤ì›¨ì–´
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class PayloadSizeLimitMiddleware(BaseHTTPMiddleware):
    """ìš”ì²­ í¬ê¸° ì œí•œ ë¯¸ë“¤ì›¨ì–´ (DoS ë°©ì§€)"""
    
    def __init__(self, app, max_size_bytes: int = 1024 * 1024):  # 1MB
        super().__init__(app)
        self.max_size = max_size_bytes
    
    async def dispatch(self, request: Request, call_next):
        if hasattr(request, 'headers'):
            content_length = request.headers.get('content-length')
            if content_length and int(content_length) > self.max_size:
                secure_logger.warning(f"í˜ì´ë¡œë“œ í¬ê¸° ì´ˆê³¼: {content_length} bytes")
                raise HTTPException(
                    status_code=413, 
                    detail=f"Payload too large. Max size: {self.max_size} bytes"
                )
        
        response = await call_next(request)
        return response

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š ìŠ¤ë ˆë“œ ì•ˆì „ ìºì‹œ ì‹œìŠ¤í…œ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SafeCache:
    """ìŠ¤ë ˆë“œ ì•ˆì „í•œ ìºì‹œ (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)"""
    
    def __init__(self, max_size: int = 1000, ttl: int = 300):
        self.cache = {}
        self.access_times = {}
        self.max_size = max_size
        self.ttl = ttl
        self.lock = threading.RLock()
        self.stats = {'hits': 0, 'misses': 0, 'cleanups': 0}
    
    def get(self, key: str) -> Optional[any]:
        """ìºì‹œì—ì„œ ê°’ ì¡°íšŒ"""
        with self.lock:
            if key not in self.cache:
                self.stats['misses'] += 1
                return None
            
            # TTL í™•ì¸
            if time.time() - self.access_times[key] > self.ttl:
                del self.cache[key]
                del self.access_times[key]
                self.stats['misses'] += 1
                return None
            
            self.stats['hits'] += 1
            return self.cache[key]
    
    def set(self, key: str, value: any):
        """ìºì‹œì— ê°’ ì €ì¥"""
        with self.lock:
            # ìºì‹œ í¬ê¸° ê´€ë¦¬
            if len(self.cache) >= self.max_size:
                self._cleanup_old_entries()
            
            self.cache[key] = value
            self.access_times[key] = time.time()
    
    def _cleanup_old_entries(self):
        """ì˜¤ë˜ëœ í•­ëª© ì •ë¦¬"""
        current_time = time.time()
        to_remove = []
        
        # TTL ë§Œë£Œëœ í•­ëª© ì°¾ê¸°
        for key, access_time in self.access_times.items():
            if current_time - access_time > self.ttl:
                to_remove.append(key)
        
        # ë§Œë£Œëœ í•­ëª© ì œê±°
        for key in to_remove:
            self.cache.pop(key, None)
            self.access_times.pop(key, None)
            self.stats['cleanups'] += 1
        
        # ì—¬ì „íˆ í¬ê¸°ê°€ í¬ë©´ ê°€ì¥ ì˜¤ë˜ëœ í•­ëª© ì œê±°
        if len(self.cache) >= self.max_size:
            oldest_key = min(self.access_times, key=self.access_times.get)
            self.cache.pop(oldest_key, None)
            self.access_times.pop(oldest_key, None)
            self.stats['cleanups'] += 1
    
    def get_stats(self) -> Dict:
        """ìºì‹œ í†µê³„"""
        with self.lock:
            total_requests = self.stats['hits'] + self.stats['misses']
            hit_rate = self.stats['hits'] / total_requests if total_requests > 0 else 0
            
            return {
                'size': len(self.cache),
                'max_size': self.max_size,
                'hit_rate': round(hit_rate, 3),
                'total_hits': self.stats['hits'],
                'total_misses': self.stats['misses'],
                'cleanups': self.stats['cleanups']
            }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ” ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SystemMonitor:
    """ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ ë° ë³´í˜¸"""
    
    def __init__(self, memory_threshold=0.8, cpu_threshold=0.9, disk_threshold=0.9):
        self.memory_threshold = memory_threshold
        self.cpu_threshold = cpu_threshold  
        self.disk_threshold = disk_threshold
        self.alert_cooldown = {}  # ì•Œë¦¼ ì¿¨ë‹¤ìš´
        self.enabled = PSUTIL_AVAILABLE
        
        if not self.enabled:
            secure_logger.warning("psutilì´ ì„¤ì¹˜ë˜ì§€ ì•Šì•„ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ì´ ë¹„í™œì„±í™”ë©ë‹ˆë‹¤")
    
    async def monitor_resources(self):
        """ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§"""
        if not self.enabled:
            secure_logger.info("ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ì´ ë¹„í™œì„±í™”ë˜ì–´ ìˆìŠµë‹ˆë‹¤")
            return
            
        secure_logger.info("ğŸ” ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ ì‹œì‘")
        
        while True:
            try:
                await self._check_memory()
                await self._check_cpu()
                await self._check_disk()
                await asyncio.sleep(60)  # 1ë¶„ë§ˆë‹¤ ì²´í¬
                
            except Exception as e:
                secure_logger.error(f"ë¦¬ì†ŒìŠ¤ ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜: {e}")
                await asyncio.sleep(60)
    
    async def _check_memory(self):
        """ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ì²´í¬"""
        try:
            memory = psutil.virtual_memory()
            memory_percent = memory.percent / 100
            
            if memory_percent > self.memory_threshold:
                if self._should_send_alert('memory'):
                    secure_logger.warning(f"ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ìœ„í—˜: {memory_percent:.1%}")
        except Exception as e:
            secure_logger.error(f"ë©”ëª¨ë¦¬ ì²´í¬ ì˜¤ë¥˜: {e}")
    
    async def _check_cpu(self):
        """CPU ì‚¬ìš©ë¥  ì²´í¬ - ìˆ˜ì •ë¨: ë¹„ë™ê¸° ì²˜ë¦¬"""
        try:
            # ë¹„ë¸”ë¡œí‚¹ ë°©ì‹ìœ¼ë¡œ CPU ì‚¬ìš©ë¥  ì²´í¬
            cpu_percent = psutil.cpu_percent() / 100  # interval=Noneìœ¼ë¡œ ì¦‰ì‹œ ë°˜í™˜
            
            if cpu_percent > self.cpu_threshold:
                if self._should_send_alert('cpu'):
                    secure_logger.warning(f"CPU ì‚¬ìš©ë¥  ìœ„í—˜: {cpu_percent:.1%}")
        except Exception as e:
            secure_logger.error(f"CPU ì²´í¬ ì˜¤ë¥˜: {e}")
    
    async def _check_disk(self):
        """ë””ìŠ¤í¬ ì‚¬ìš©ë¥  ì²´í¬"""
        try:
            disk = psutil.disk_usage('/')
            disk_percent = disk.percent / 100
            
            if disk_percent > self.disk_threshold:
                if self._should_send_alert('disk'):
                    secure_logger.warning(f"ë””ìŠ¤í¬ ì‚¬ìš©ë¥  ìœ„í—˜: {disk_percent:.1%}")
        except Exception as e:
            secure_logger.error(f"ë””ìŠ¤í¬ ì²´í¬ ì˜¤ë¥˜: {e}")
    
    def _should_send_alert(self, resource_type: str) -> bool:
        """ì•Œë¦¼ ì¿¨ë‹¤ìš´ ì²´í¬ (10ë¶„ê°„ ë™ì¼ ì•Œë¦¼ ë°©ì§€)"""
        now = time.time()
        last_alert = self.alert_cooldown.get(resource_type, 0)
        
        if now - last_alert > 600:  # 10ë¶„
            self.alert_cooldown[resource_type] = now
            return True
        return False

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š ë³´ì•ˆ ê°ì‚¬ ë¡œê·¸ ì‹œìŠ¤í…œ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class AuditLogger:
    """ë³´ì•ˆ ê°ì‚¬ ë¡œê·¸ ì‹œìŠ¤í…œ"""
    
    def __init__(self, max_entries: int = 10000):
        self.audit_log = []
        self.max_entries = max_entries
        self.lock = threading.RLock()
    
    def log_event(self, event_type: str, user_id: str, details: Dict, risk_level: str = 'LOW'):
        """ê°ì‚¬ ì´ë²¤íŠ¸ ë¡œê·¸"""
        with self.lock:
            audit_entry = {
                'timestamp': datetime.now().isoformat(),
                'event_type': event_type,
                'user_id': user_id,
                'details': details,
                'risk_level': risk_level,
                'thread_id': threading.get_ident(),
                'session_id': self._generate_session_id()
            }
            
            # ë¡œê·¸ í¬ê¸° ê´€ë¦¬
            if len(self.audit_log) >= self.max_entries:
                self.audit_log = self.audit_log[-int(self.max_entries * 0.8):]
            
            self.audit_log.append(audit_entry)
            
            # ê³ ìœ„í—˜ ì´ë²¤íŠ¸ëŠ” ì¦‰ì‹œ ë¡œê¹…
            if risk_level in ['HIGH', 'CRITICAL']:
                secure_logger.warning(f"ê°ì‚¬ ì´ë²¤íŠ¸ [{risk_level}]: {event_type} - {details}")
    
    def _generate_session_id(self) -> str:
        """ì„¸ì…˜ ID ìƒì„±"""
        return hashlib.md5(f"{time.time()}{threading.get_ident()}".encode()).hexdigest()[:8]
    
    def get_recent_events(self, count: int = 100, event_type: str = None) -> List[Dict]:
        """ìµœê·¼ ì´ë²¤íŠ¸ ì¡°íšŒ"""
        with self.lock:
            events = self.audit_log[-count:] if not event_type else [
                event for event in self.audit_log[-count*2:] 
                if event['event_type'] == event_type
            ][-count:]
            
            return events
    
    def get_risk_summary(self) -> Dict:
        """ë¦¬ìŠ¤í¬ ìš”ì•½"""
        with self.lock:
            if not self.audit_log:
                return {'total': 0, 'by_risk': {}}
            
            risk_counts = {}
            for event in self.audit_log[-1000:]:  # ìµœê·¼ 1000ê°œ
                risk_level = event['risk_level']
                risk_counts[risk_level] = risk_counts.get(risk_level, 0) + 1
            
            return {
                'total': len(self.audit_log),
                'recent_count': min(1000, len(self.audit_log)),
                'by_risk': risk_counts
            }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸŒ ê³ ê¸‰ ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SecureNetworkClient:
    """ì¬ì‹œë„ ë¡œì§ ë° íƒ€ì„ì•„ì›ƒì´ ê°•í™”ëœ ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸"""
    
    def __init__(self):
        self.timeout = aiohttp.ClientTimeout(
            total=30,      # ì „ì²´ 30ì´ˆ
            connect=5,     # ì—°ê²° 5ì´ˆ
            sock_read=10   # ì½ê¸° 10ì´ˆ
        )
    
    async def safe_post(self, url: str, data: Dict = None, json_data: Dict = None) -> Dict:
        """ì•ˆì „í•œ POST ìš”ì²­ (ì¬ì‹œë„ + íƒ€ì„ì•„ì›ƒ)"""
        max_retries = 3
        retry_count = 0
        
        while retry_count < max_retries:
            try:
                async with aiohttp.ClientSession(timeout=self.timeout) as session:
                    kwargs = {}
                    if data:
                        kwargs['data'] = data
                    if json_data:
                        kwargs['json'] = json_data
                    
                    async with session.post(url, **kwargs) as response:
                        if response.status == 200:
                            return await response.json()
                        else:
                            error_text = await response.text()
                            secure_logger.error(f"HTTP ì˜¤ë¥˜ {response.status}: {url}")
                            if retry_count == max_retries - 1:
                                return {'error': f'HTTP {response.status}: {error_text}'}
                            
            except asyncio.TimeoutError:
                secure_logger.error(f"íƒ€ì„ì•„ì›ƒ: {url} (ì‹œë„ {retry_count + 1}/{max_retries})")
                if retry_count == max_retries - 1:
                    return {'error': 'Request timeout'}
            except Exception as e:
                secure_logger.error(f"ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: {url} - {e} (ì‹œë„ {retry_count + 1}/{max_retries})")
                if retry_count == max_retries - 1:
                    return {'error': str(e)}
            
            retry_count += 1
            if retry_count < max_retries:
                await asyncio.sleep(min(2 ** retry_count, 10))  # ì§€ìˆ˜ ë°±ì˜¤í”„
        
        return {'error': 'Max retries exceeded'}
    
    async def safe_get(self, url: str) -> Dict:
        """ì•ˆì „í•œ GET ìš”ì²­ (ì¬ì‹œë„ + íƒ€ì„ì•„ì›ƒ)"""
        max_retries = 3
        retry_count = 0
        
        while retry_count < max_retries:
            try:
                async with aiohttp.ClientSession(timeout=self.timeout) as session:
                    async with session.get(url) as response:
                        if response.status == 200:
                            return await response.json()
                        else:
                            if retry_count == max_retries - 1:
                                return {'error': f'HTTP {response.status}'}
                            
            except Exception as e:
                if retry_count == max_retries - 1:
                    return {'error': str(e)}
            
            retry_count += 1
            if retry_count < max_retries:
                await asyncio.sleep(min(2 ** retry_count, 5))
        
        return {'error': 'Max retries exceeded'}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹œìŠ¤í…œ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MetricsCollector:
    """Prometheus ìŠ¤íƒ€ì¼ ë©”íŠ¸ë¦­ ìˆ˜ì§‘"""
    
    def __init__(self):
        self.metrics = {
            'phoenix95_requests_total': 0,
            'phoenix95_requests_success': 0,
            'phoenix95_requests_failed': 0,
            'phoenix95_response_time_seconds': [],
            'phoenix95_trades_total': 0,
            'phoenix95_trades_profit': 0,
            'phoenix95_trades_loss': 0,
            'phoenix95_cache_hits': 0,
            'phoenix95_cache_misses': 0,
            'phoenix95_risk_checks_rejected': 0,
            'phoenix95_system_cpu_percent': 0,
            'phoenix95_system_memory_percent': 0,
        }
        self.lock = threading.RLock()
    
    def increment_counter(self, metric_name: str, value: float = 1):
        """ì¹´ìš´í„° ì¦ê°€"""
        with self.lock:
            if metric_name in self.metrics:
                self.metrics[metric_name] += value
    
    def record_histogram(self, metric_name: str, value: float):
        """íˆìŠ¤í† ê·¸ë¨ ê¸°ë¡"""
        with self.lock:
            if metric_name not in self.metrics:
                self.metrics[metric_name] = []
            
            self.metrics[metric_name].append(value)
            
            # ìµœê·¼ 1000ê°œë§Œ ìœ ì§€
            if len(self.metrics[metric_name]) > 1000:
                self.metrics[metric_name] = self.metrics[metric_name][-1000:]
    
    def set_gauge(self, metric_name: str, value: float):
        """ê²Œì´ì§€ ì„¤ì •"""
        with self.lock:
            self.metrics[metric_name] = value
    
    def get_metrics(self) -> Dict:
        """ë©”íŠ¸ë¦­ ì¡°íšŒ (Prometheus í˜•ì‹)"""
        with self.lock:
            result = {}
            
            for metric_name, value in self.metrics.items():
                if isinstance(value, list):
                    if value:
                        result[f"{metric_name}_avg"] = sum(value) / len(value)
                        result[f"{metric_name}_max"] = max(value)
                        result[f"{metric_name}_min"] = min(value)
                        result[f"{metric_name}_count"] = len(value)
                    else:
                        result[f"{metric_name}_avg"] = 0
                        result[f"{metric_name}_max"] = 0
                        result[f"{metric_name}_min"] = 0
                        result[f"{metric_name}_count"] = 0
                else:
                    result[metric_name] = value
            
            return result
    
    def export_prometheus_format(self) -> str:
        """Prometheus í˜•ì‹ìœ¼ë¡œ ë©”íŠ¸ë¦­ ë‚´ë³´ë‚´ê¸°"""
        metrics = self.get_metrics()
        lines = []
        
        for metric_name, value in metrics.items():
            lines.append(f"# TYPE {metric_name} gauge")
            lines.append(f"{metric_name} {value}")
        
        return "\n".join(lines)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ”„ ë©”ì‹œì§€ í ì‹œìŠ¤í…œ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MessageQueue:
    """ê°„ë‹¨í•œ ë©”ì‹œì§€ í (Redis ìŠ¤íƒ€ì¼)"""
    
    def __init__(self):
        self.queues = {}
        self.subscribers = {}
        self.lock = threading.RLock()
    
    async def publish(self, channel: str, message: Dict):
        """ë©”ì‹œì§€ ë°œí–‰"""
        with self.lock:
            if channel not in self.queues:
                self.queues[channel] = []
            
            message_with_timestamp = {
                **message,
                'timestamp': datetime.now().isoformat(),
                'id': secrets.token_hex(8)
            }
            
            self.queues[channel].append(message_with_timestamp)
            
            # í í¬ê¸° ì œí•œ
            if len(self.queues[channel]) > 1000:
                self.queues[channel] = self.queues[channel][-1000:]
            
            # êµ¬ë…ìë“¤ì—ê²Œ ì•Œë¦¼
            if channel in self.subscribers:
                for callback in self.subscribers[channel]:
                    try:
                        if asyncio.iscoroutinefunction(callback):
                            await callback(message_with_timestamp)
                        else:
                            callback(message_with_timestamp)
                    except Exception as e:
                        secure_logger.error(f"êµ¬ë…ì ì½œë°± ì˜¤ë¥˜: {e}")
    
    def subscribe(self, channel: str, callback):
        """ì±„ë„ êµ¬ë…"""
        with self.lock:
            if channel not in self.subscribers:
                self.subscribers[channel] = []
            
            self.subscribers[channel].append(callback)
    
    def get_messages(self, channel: str, count: int = 10) -> List[Dict]:
        """ìµœê·¼ ë©”ì‹œì§€ ì¡°íšŒ"""
        with self.lock:
            if channel in self.queues:
                return self.queues[channel][-count:]
            return []

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š Binance API í´ë¼ì´ì–¸íŠ¸
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class BinanceClient:
    """Binance API í´ë¼ì´ì–¸íŠ¸ (ì‹¤ì œ ê±°ë˜ìš©) - ìˆ˜ì •ë¨"""
    
    def __init__(self, api_key: str, api_secret: str, testnet: bool = True):
        self.api_key = api_key
        self.api_secret = api_secret
        self.testnet = testnet
        
        # API ì—”ë“œí¬ì¸íŠ¸
        if testnet:
            self.base_url = "https://testnet.binancefuture.com"
        else:
            self.base_url = "https://fapi.binance.com"
        
        self.session = None
    
    def _generate_signature(self, params: str) -> str:
        """API ì„œëª… ìƒì„±"""
        return hmac.new(
            self.api_secret.encode('utf-8'),
            params.encode('utf-8'),
            hashlib.sha256
        ).hexdigest()
    
    async def _make_request(self, method: str, endpoint: str, params: Dict = None) -> Dict:
        """API ìš”ì²­ ì‹¤í–‰ - ìˆ˜ì •ë¨: DELETE ë©”ì„œë“œ ì§€ì›"""
        if not self.session:
            timeout = aiohttp.ClientTimeout(total=30)
            self.session = aiohttp.ClientSession(timeout=timeout)
        
        url = f"{self.base_url}{endpoint}"
        
        if params is None:
            params = {}
        
        # íƒ€ì„ìŠ¤íƒ¬í”„ ì¶”ê°€
        params['timestamp'] = int(time.time() * 1000)
        
        # ì¿¼ë¦¬ ìŠ¤íŠ¸ë§ ìƒì„±
        query_string = '&'.join([f"{k}={v}" for k, v in params.items()])
        
        # ì„œëª… ìƒì„±
        signature = self._generate_signature(query_string)
        params['signature'] = signature
        
        headers = {
            'X-MBX-APIKEY': self.api_key,
            'Content-Type': 'application/json'
        }
        
        try:
            if method == 'GET':
                async with self.session.get(url, params=params, headers=headers) as response:
                    return await response.json()
            elif method == 'POST':
                async with self.session.post(url, data=params, headers=headers) as response:
                    return await response.json()
            elif method == 'DELETE':  # ìˆ˜ì •: DELETE ë©”ì„œë“œ ì§€ì› ì¶”ê°€
                async with self.session.delete(url, params=params, headers=headers) as response:
                    return await response.json()
            else:
                return {'code': -1, 'msg': f'Unsupported method: {method}'}
                
        except Exception as e:
            secure_logger.error(f"Binance API ì˜¤ë¥˜: {e}")
            return {'code': -1, 'msg': str(e)}
    
    async def set_leverage(self, symbol: str, leverage: int) -> Dict:
        """ë ˆë²„ë¦¬ì§€ ì„¤ì •"""
        params = {
            'symbol': symbol,
            'leverage': leverage
        }
        return await self._make_request('POST', '/fapi/v1/leverage', params)
    
    async def new_order(self, symbol: str, side: str, order_type: str, 
                       quantity: float, price: float = None) -> Dict:
        """ìƒˆ ì£¼ë¬¸ ìƒì„±"""
        params = {
            'symbol': symbol,
            'side': side.upper(),
            'type': order_type.upper(),
            'quantity': quantity
        }
        
        if price and order_type.upper() == 'LIMIT':
            params['price'] = price
            params['timeInForce'] = 'GTC'
        
        return await self._make_request('POST', '/fapi/v1/order', params)
    
    async def cancel_order(self, symbol: str, order_id: str) -> Dict:
        """ì£¼ë¬¸ ì·¨ì†Œ - ìˆ˜ì •ë¨: DELETE ë©”ì„œë“œ ì‚¬ìš©"""
        params = {
            'symbol': symbol,
            'orderId': order_id
        }
        return await self._make_request('DELETE', '/fapi/v1/order', params)
    
    async def get_account_info(self) -> Dict:
        """ê³„ì • ì •ë³´ ì¡°íšŒ"""
        return await self._make_request('GET', '/fapi/v2/account')
    
    async def get_position_info(self, symbol: str = None) -> Dict:
        """í¬ì§€ì…˜ ì •ë³´ ì¡°íšŒ"""
        params = {}
        if symbol:
            params['symbol'] = symbol
        return await self._make_request('GET', '/fapi/v2/positionRisk', params)
    
    async def close(self):
        """ì„¸ì…˜ ì¢…ë£Œ"""
        if self.session:
            await self.session.close()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ì „ì—­ ê°ì²´ ì´ˆê¸°í™”
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

# ì „ì—­ ë„¤íŠ¸ì›Œí¬ í´ë¼ì´ì–¸íŠ¸
network_client = SecureNetworkClient()

# ì „ì—­ ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°
system_monitor = SystemMonitor()

# ì „ì—­ ê°ì‚¬ ë¡œê±°
audit_logger = AuditLogger()

# ì „ì—­ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸°
metrics_collector = MetricsCollector()

# ì „ì—­ ë©”ì‹œì§€ í
message_queue = MessageQueue()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš™ï¸ ì„¤ì • ì‹œìŠ¤í…œ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class HedgeFundConfig:
    """í—¤ì§€í€ë“œ ì„¤ì •"""
    
    def __init__(self):
        # ë¦¬ìŠ¤í¬ ê´€ë¦¬ (ë³€ê²½ ê¸ˆì§€)
        self.MAX_DAILY_LOSS: float = 0.02      # 2%
        self.MAX_POSITION_SIZE: float = 0.05   # 5%
        self.LEVERAGE: int = 20                # 20x ê³ ì •
        self.STOP_LOSS: float = 0.02          # 2%
        self.TAKE_PROFIT: float = 0.02        # 2%
        self.MAX_POSITIONS: int = 3           # ìµœëŒ€ 3ê°œ ë™ì‹œ
        
        # Phoenix 95 ì„¤ì •
        self.MIN_CONFIDENCE: float = 0.75     # 75% ì´ìƒë§Œ ê±°ë˜
        self.PHOENIX_WEIGHT: float = 0.95     # Phoenix 95 ê°€ì¤‘ì¹˜
        
        # ì„±ëŠ¥ ëª©í‘œ
        self.TARGET_RESPONSE_TIME: int = 100  # 100ms
        self.HEALTH_CHECK_INTERVAL: int = 30  # 30ì´ˆ
        
        # í™˜ê²½ë³€ìˆ˜ì—ì„œ ì„¤ì • ë¡œë“œ
        self._load_config()
        
        secure_logger.info("ğŸ”’ ì„¤ì •ì´ ì´ˆê¸°í™”ë˜ì—ˆìŠµë‹ˆë‹¤")
    
    def _load_config(self):
        """í™˜ê²½ë³€ìˆ˜ì—ì„œ ì„¤ì • ë¡œë“œ"""
        # í…”ë ˆê·¸ë¨ ì„¤ì • (ê¸°ë³¸ê°’ ì œê³µ)
        self.TELEGRAM_TOKEN = os.getenv('TELEGRAM_TOKEN', "7386542811:AAEZ21p30rES1k8NxNM2xbZ53U44PI9D5CY")
        self.TELEGRAM_CHAT_ID = os.getenv('TELEGRAM_CHAT_ID', "7590895952")
        
        # ê±°ë˜ì†Œ API ì„¤ì •
        self.TRADE_MODE = os.getenv('TRADE_MODE', 'TEST')
        
        if self.TRADE_MODE == 'LIVE':
            self.BINANCE_API_KEY = os.getenv('BINANCE_API_KEY')
            self.BINANCE_SECRET = os.getenv('BINANCE_SECRET')
            if not self.BINANCE_API_KEY or not self.BINANCE_SECRET:
                secure_logger.warning("LIVE ëª¨ë“œì´ì§€ë§Œ Binance API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ")
                self.TRADE_MODE = 'TEST'
        else:
            self.BINANCE_API_KEY = 'TEST_MODE'
            self.BINANCE_SECRET = 'TEST_MODE'

CONFIG = HedgeFundConfig()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ›¡ï¸ ì…ë ¥ ê²€ì¦ ìœ í‹¸ë¦¬í‹°
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class InputValidator:
    """ì…ë ¥ ë°ì´í„° ê²€ì¦"""
    
    @staticmethod
    def sanitize_symbol(symbol: str) -> str:
        """ì‹¬ë³¼ ì…ë ¥ ì •ë¦¬"""
        if not isinstance(symbol, str):
            raise ValueError("ì‹¬ë³¼ì€ ë¬¸ìì—´ì´ì–´ì•¼ í•©ë‹ˆë‹¤")
        
        clean_symbol = re.sub(r'[^A-Za-z0-9]', '', symbol).upper()
        
        if not clean_symbol or len(clean_symbol) > 20:
            raise ValueError("ìœ íš¨í•˜ì§€ ì•Šì€ ì‹¬ë³¼ì…ë‹ˆë‹¤")
        
        return clean_symbol
    
    @staticmethod
    def validate_numeric(value: any, min_val: float, max_val: float, name: str) -> float:
        """ìˆ«ì ë²”ìœ„ ê²€ì¦"""
        try:
            num_value = float(value)
            if not min_val <= num_value <= max_val:
                raise ValueError(f"{name}ì´ ë²”ìœ„ë¥¼ ë²—ì–´ë‚¨: {num_value}")
            return num_value
        except (TypeError, ValueError):
            raise ValueError(f"{name} ë³€í™˜ ì‹¤íŒ¨: {value}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ§  Signal Engine
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Phoenix95Engine:
    """Phoenix 95 AI ì—”ì§„"""
    
    def __init__(self):
        self.name = "Phoenix 95 V4.3.1 Fixed Edition"
        self.version = "4.3.1"
        self.validator = InputValidator()
        self.analysis_cache = SafeCache(max_size=1000, ttl=300)  # 5ë¶„ TTL
        
    def analyze(self, data: Dict) -> Dict:
        """í•µì‹¬ 3ê°€ì§€ ì§€í‘œ ë¶„ì„"""
        start_time = time.time()
        
        try:
            # ì…ë ¥ ë°ì´í„° ê²€ì¦
            validated_data = self._validate_input(data)
            
            # ìºì‹œ í‚¤ ìƒì„±
            cache_key = self._generate_cache_key(validated_data)
            cached_result = self.analysis_cache.get(cache_key)
            
            if cached_result:
                cached_result['metadata']['from_cache'] = True
                cached_result['metadata']['cache_stats'] = self.analysis_cache.get_stats()
                return cached_result
            
            # 1. ê¸°ìˆ ì  ë¶„ì„ (30%)
            technical_score = self._analyze_technical(validated_data)
            
            # 2. ê±°ë˜ëŸ‰ ë¶„ì„ (30%)
            volume_score = self._analyze_volume(validated_data)
            
            # 3. ëª¨ë©˜í…€ ë¶„ì„ (40%)
            momentum_score = self._analyze_momentum(validated_data)
            
            # Phoenix 95 ìµœì¢… ì ìˆ˜ ê³„ì‚°
            raw_score = (
                technical_score * 0.3 + 
                volume_score * 0.3 + 
                momentum_score * 0.4
            )
            
            phoenix_score = raw_score * CONFIG.PHOENIX_WEIGHT
            recommendation = self._get_recommendation(phoenix_score)
            processing_time = (time.time() - start_time) * 1000
            
            result = {
                'phoenix_score': round(max(0.0, min(phoenix_score, 1.0)), 4),
                'confidence': round(max(0.0, min(phoenix_score, 1.0)), 4),
                'recommendation': recommendation,
                'components': {
                    'technical': round(technical_score, 3),
                    'volume': round(volume_score, 3),
                    'momentum': round(momentum_score, 3)
                },
                'metadata': {
                    'engine': self.name,
                    'version': self.version,
                    'processing_time_ms': round(processing_time, 2),
                    'timestamp': datetime.now().isoformat(),
                    'from_cache': False,
                    'cache_stats': self.analysis_cache.get_stats()
                }
            }
            
            # ìºì‹œì— ì €ì¥
            self.analysis_cache.set(cache_key, result)
            
            return result
            
        except Exception as e:
            secure_logger.error(f"ë¶„ì„ ì˜¤ë¥˜: {e}")
            return {
                'error': str(e),
                'phoenix_score': 0.0,
                'confidence': 0.0,
                'recommendation': 'ERROR'
            }
    
    def _validate_input(self, data: Dict) -> Dict:
        """ì…ë ¥ ë°ì´í„° ê²€ì¦"""
        if not isinstance(data, dict):
            raise ValueError("ë°ì´í„°ëŠ” ë”•ì…”ë„ˆë¦¬ í˜•íƒœì—¬ì•¼ í•©ë‹ˆë‹¤")
        
        # í•„ìˆ˜ í•„ë“œ í™•ì¸
        if 'symbol' not in data or 'price' not in data:
            raise ValueError("í•„ìˆ˜ í•„ë“œ ëˆ„ë½ (symbol, price)")
        
        validated = {}
        
        # ì‹¬ë³¼ ê²€ì¦
        validated['symbol'] = self.validator.sanitize_symbol(data['symbol'])
        
        # ìˆ«ì í•„ë“œ ê²€ì¦
        validated['price'] = self.validator.validate_numeric(data['price'], 0.01, 10000000, "ê°€ê²©")
        validated['rsi'] = self.validator.validate_numeric(data.get('rsi', 50), 0, 100, "RSI")
        validated['volume'] = self.validator.validate_numeric(data.get('volume', 1000000), 1, 1e15, "ê±°ë˜ëŸ‰")
        validated['avg_volume_20'] = self.validator.validate_numeric(data.get('avg_volume_20', 1000000), 1, 1e15, "í‰ê· ê±°ë˜ëŸ‰")
        validated['macd_line'] = self.validator.validate_numeric(data.get('macd_line', 0), -10000, 10000, "MACD Line")
        validated['macd_signal'] = self.validator.validate_numeric(data.get('macd_signal', 0), -10000, 10000, "MACD Signal")
        validated['stoch_k'] = self.validator.validate_numeric(data.get('stoch_k', 50), 0, 100, "Stochastic K")
        validated['stoch_d'] = self.validator.validate_numeric(data.get('stoch_d', 50), 0, 100, "Stochastic D")
        validated['williams_r'] = self.validator.validate_numeric(data.get('williams_r', -50), -100, 0, "Williams R")
        validated['cci'] = self.validator.validate_numeric(data.get('cci', 0), -1000, 1000, "CCI")
        
        return validated
    
    def _analyze_technical(self, data: Dict) -> float:
        """ê¸°ìˆ ì  ë¶„ì„"""
        try:
            rsi = data.get('rsi', 50)
            macd_line = data.get('macd_line', 0)
            macd_signal = data.get('macd_signal', 0)
            
            # RSI ì ìˆ˜
            if rsi < 30:
                rsi_score = 0.9
            elif rsi < 40:
                rsi_score = 0.7
            elif rsi < 60:
                rsi_score = 0.5
            elif rsi < 70:
                rsi_score = 0.3
            else:
                rsi_score = 0.1
            
            # MACD ì ìˆ˜
            macd_diff = macd_line - macd_signal
            macd_score = 0.5 + (macd_diff / 100)
            macd_score = max(0, min(macd_score, 1))
            
            # ê°€ì¤‘ í‰ê· 
            technical_score = (rsi_score * 0.7 + macd_score * 0.3)
            return max(0, min(technical_score, 1))
            
        except Exception:
            return 0.5
    
    def _analyze_volume(self, data: Dict) -> float:
        """ê±°ë˜ëŸ‰ ë¶„ì„"""
        try:
            current_volume = data.get('volume', 1000000)
            avg_volume = data.get('avg_volume_20', 1000000)
            
            if avg_volume <= 0:
                return 0.5
            
            volume_ratio = current_volume / avg_volume
            
            if volume_ratio > 3.0:
                return 0.95
            elif volume_ratio > 2.0:
                return 0.85
            elif volume_ratio > 1.5:
                return 0.75
            elif volume_ratio > 1.2:
                return 0.65
            elif volume_ratio > 0.8:
                return 0.55
            else:
                return 0.3
                
        except Exception:
            return 0.5
    
    def _analyze_momentum(self, data: Dict) -> float:
        """ëª¨ë©˜í…€ ë¶„ì„"""
        try:
            stoch_k = data.get('stoch_k', 50)
            stoch_d = data.get('stoch_d', 50)
            williams_r = data.get('williams_r', -50)
            cci = data.get('cci', 0)
            
            # Stochastic ì ìˆ˜
            if stoch_k < 20 and stoch_d < 20:
                stoch_score = 0.9
            elif stoch_k > 80 and stoch_d > 80:
                stoch_score = 0.1
            else:
                stoch_score = 0.5
            
            # Williams %R ì ìˆ˜
            if williams_r < -80:
                williams_score = 0.9
            elif williams_r > -20:
                williams_score = 0.1
            else:
                williams_score = 0.5
            
            # CCI ì ìˆ˜
            if cci < -100:
                cci_score = 0.9
            elif cci > 100:
                cci_score = 0.1
            else:
                cci_score = 0.5
            
            # ê°€ì¤‘ í‰ê· 
            momentum_score = (stoch_score * 0.4 + williams_score * 0.3 + cci_score * 0.3)
            return max(0, min(momentum_score, 1))
            
        except Exception:
            return 0.5
    
    def _get_recommendation(self, score: float) -> str:
        """ì¶”ì²œ ë“±ê¸‰"""
        if score > 0.85:
            return "STRONG_BUY"
        elif score > 0.75:
            return "BUY"
        elif score > 0.60:
            return "WEAK_BUY"
        elif score > 0.40:
            return "HOLD"
        elif score > 0.25:
            return "WEAK_SELL"
        elif score > 0.15:
            return "SELL"
        else:
            return "STRONG_SELL"
    
    def _generate_cache_key(self, data: Dict) -> str:
        """ìºì‹œ í‚¤ ìƒì„±"""
        key_data = {
            'symbol': data['symbol'],
            'price': round(data['price'], 2),
            'rsi': round(data['rsi'], 1),
            'volume': data['volume']
        }
        # í•´ì‹œ ì¶©ëŒ ë°©ì§€ë¥¼ ìœ„í•´ SHA-256 ì‚¬ìš©
        return hashlib.sha256(json.dumps(key_data, sort_keys=True).encode()).hexdigest()[:16]

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ›¡ï¸ Risk Guardian
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class RiskGuardian:
    """í—¤ì§€í€ë“œê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.daily_pnl = 0.0
        self.active_positions = 0
        self.total_exposure = 0.0
        self.last_reset = datetime.now().date()
        self.lock = threading.RLock()
        
        self.risk_metrics = {
            'daily_trades': 0,
            'success_rate': 0.0,
            'max_drawdown': 0.0,
            'win_streak': 0,
            'loss_streak': 0,
            'largest_win': 0.0,
            'largest_loss': 0.0
        }
        
        # ê±°ë˜ ê¸°ë¡ (Kelly Criterion ê³„ì‚°ìš©)
        self.trade_history = []
        
        # ë™ì  ë¦¬ìŠ¤í¬ ì¡°ì •
        self.volatility_multiplier = 1.0
        
    def check_trade_approval(self, signal_data: Dict, analysis: Dict) -> Dict:
        """ê±°ë˜ ìŠ¹ì¸ ì—¬ë¶€ ê²°ì •"""
        
        with self.lock:
            checks = []
            approved = True
            risk_level = 'LOW'
            
            try:
                # ê°ì‚¬ ë¡œê·¸
                audit_logger.log_event(
                    'TRADE_APPROVAL_REQUEST',
                    'system',
                    {
                        'symbol': signal_data.get('symbol', 'UNKNOWN'),
                        'confidence': analysis.get('confidence', 0)
                    }
                )
                
                # ì¼ì¼ ë¦¬ì…‹ ì²´í¬
                self._check_daily_reset()
                
                # ì…ë ¥ ë°ì´í„° ê²€ì¦
                if not self._validate_inputs(signal_data, analysis):
                    audit_logger.log_event(
                        'TRADE_APPROVAL_DENIED',
                        'system',
                        {'reason': 'Invalid input data'},
                        'HIGH'
                    )
                    return self._create_error_response("ì…ë ¥ ë°ì´í„° ì˜¤ë¥˜")
                
                # 1. ì¼ì¼ ì†ì‹¤ í•œë„ ì²´í¬ (ìµœìš°ì„ )
                if abs(self.daily_pnl) >= CONFIG.MAX_DAILY_LOSS:
                    approved = False
                    risk_level = 'CRITICAL'
                    checks.append(f"ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼: {self.daily_pnl:.2%}")
                
                # 2. í¬ì§€ì…˜ ìˆ˜ í•œë„ ì²´í¬
                if self.active_positions >= CONFIG.MAX_POSITIONS:
                    approved = False
                    risk_level = 'HIGH'
                    checks.append(f"ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ë„ë‹¬: {self.active_positions}/{CONFIG.MAX_POSITIONS}")
                
                # 3. ì‹ ë¢°ë„ ì²´í¬
                confidence = analysis.get('confidence', 0)
                if confidence < CONFIG.MIN_CONFIDENCE:
                    approved = False
                    risk_level = 'MEDIUM'
                    checks.append(f"ì‹ ë¢°ë„ ë¶€ì¡±: {confidence:.3f} < {CONFIG.MIN_CONFIDENCE}")
                
                # 4. ë™ì  ë³€ë™ì„± ì²´í¬
                volatility = signal_data.get('volatility', 0.02)
                self._update_volatility_multiplier(volatility)
                
                # 5. ê³ ê¸‰ Kelly Criterion í¬ì§€ì…˜ ì‚¬ì´ì§•
                account_balance = signal_data.get('account_balance', 10000)
                position_size = self._calculate_advanced_kelly_size(
                    account_balance, confidence, volatility
                ) if approved else 0
                
                # 6. ì´ ë…¸ì¶œ í•œë„ ì²´í¬
                if account_balance > 0:
                    projected_exposure = self.total_exposure + (position_size / account_balance)
                    max_exposure = 0.20 * self.volatility_multiplier  # ë³€ë™ì„±ì— ë”°ë¥¸ ë™ì  ì¡°ì •
                    if projected_exposure > max_exposure:
                        approved = False
                        risk_level = 'HIGH'
                        checks.append(f"ì´ ë…¸ì¶œ í•œë„ ì´ˆê³¼: {projected_exposure:.2%} > {max_exposure:.2%}")
                else:
                    projected_exposure = 0
                
                # 7. ì—°ì† ì†ì‹¤ ì²´í¬
                if self.risk_metrics['loss_streak'] >= 3:
                    position_size *= 0.5  # ì—°ì† ì†ì‹¤ì‹œ í¬ì§€ì…˜ í¬ê¸° 50% ê°ì†Œ
                    checks.append(f"ì—°ì† ì†ì‹¤ë¡œ ì¸í•œ í¬ì§€ì…˜ í¬ê¸° ê°ì†Œ: {self.risk_metrics['loss_streak']}íšŒ")
                
                # ê°ì‚¬ ë¡œê·¸
                audit_logger.log_event(
                    'TRADE_APPROVAL_RESULT',
                    'system',
                    {
                        'approved': approved,
                        'risk_level': risk_level,
                        'position_size': position_size,
                        'checks_count': len(checks)
                    },
                    'HIGH' if not approved else 'LOW'
                )
                
                return {
                    'approved': approved,
                    'position_size': round(position_size, 2),
                    'position_size_pct': round(position_size / account_balance, 4) if account_balance > 0 else 0,
                    'risk_level': risk_level,
                    'checks': checks,
                    'risk_metrics': {
                        'current_exposure': round(self.total_exposure, 4),
                        'projected_exposure': round(projected_exposure, 4),
                        'daily_pnl': round(self.daily_pnl, 4),
                        'active_positions': self.active_positions,
                        'volatility_multiplier': round(self.volatility_multiplier, 3),
                        'loss_streak': self.risk_metrics['loss_streak']
                    },
                    'kelly_sizing': {
                        'base_size': round(position_size * 0.8, 2),
                        'confidence_adjusted': round(position_size, 2),
                        'volatility_adjusted': round(position_size * self.volatility_multiplier, 2),
                        'max_allowed': round(account_balance * CONFIG.MAX_POSITION_SIZE, 2) if account_balance > 0 else 0
                    }
                }
                
            except Exception as e:
                secure_logger.error(f"ë¦¬ìŠ¤í¬ ì²´í¬ ì˜¤ë¥˜: {e}")
                audit_logger.log_event(
                    'TRADE_APPROVAL_ERROR',
                    'system',
                    {'error': str(e)},
                    'CRITICAL'
                )
                return self._create_error_response("ë¦¬ìŠ¤í¬ ì²´í¬ ì‹œìŠ¤í…œ ì˜¤ë¥˜")
    
    def _calculate_advanced_kelly_size(self, balance: float, confidence: float, volatility: float) -> float:
        """ê³ ê¸‰ Kelly Criterion í¬ì§€ì…˜ ì‚¬ì´ì§• - ìˆ˜ì •ë¨: Zero division ë°©ì§€"""
        try:
            # ê¸°ë³¸ ë¦¬ìŠ¤í¬ (ê³„ì¢Œì˜ 2%)
            base_risk_amount = balance * CONFIG.MAX_DAILY_LOSS
            
            # ì‹ ë¢°ë„ ê²€ì¦ ë° ì •ê·œí™”
            confidence = max(0.5, min(confidence, 1.0))
            
            # ê³¼ê±° ê±°ë˜ ë°ì´í„° ê¸°ë°˜ ìŠ¹ë¥  ë° ìˆ˜ìµë¥  ê³„ì‚°
            win_rate, avg_win, avg_loss = self._calculate_historical_metrics()
            
            # Kelly Criterion ê³„ì‚° - ìˆ˜ì •: Zero division ë°©ì§€
            if avg_loss > 0 and win_rate > 0 and avg_win > 0:
                kelly_fraction = (win_rate * avg_win - (1 - win_rate) * avg_loss) / avg_win
            else:
                # ê¸°ë³¸ê°’ ì‚¬ìš©
                estimated_win_rate = 0.6 + (confidence - 0.75) * 0.4
                estimated_win_rate = max(0.5, min(estimated_win_rate, 0.95))
                kelly_fraction = (estimated_win_rate * 1.5 - (1 - estimated_win_rate) * 1.0) / 1.5
            
            # Kelly fraction ì œí•œ (5%-25%)
            kelly_fraction = max(0.05, min(kelly_fraction, 0.25))
            
            # ì‹ ë¢°ë„ ì¡°ì •
            confidence_factor = 0.8 + (confidence - 0.75) * 1.6
            confidence_factor = max(0.5, min(confidence_factor, 1.2))
            
            # ë³€ë™ì„± ì¡°ì • - ìˆ˜ì •: Zero division ë°©ì§€
            if volatility > 0:
                volatility_factor = max(0.5, min(2.0 - volatility * 10, 1.5))
            else:
                volatility_factor = 1.0
            
            # ìµœì¢… í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°
            kelly_size = balance * kelly_fraction
            adjusted_size = kelly_size * confidence_factor * volatility_factor
            
            # ìµœëŒ€ í•œë„ ì ìš©
            max_position = balance * CONFIG.MAX_POSITION_SIZE
            final_size = min(adjusted_size, max_position)
            
            # ìµœì†Œ/ìµœëŒ€ ì œí•œ
            final_size = max(balance * 0.001, min(final_size, balance * 0.1))
            
            return final_size
            
        except Exception as e:
            secure_logger.error(f"Kelly í¬ì§€ì…˜ ì‚¬ì´ì§• ì˜¤ë¥˜: {e}")
            return balance * 0.01  # 1% ì•ˆì „í•œ ê¸°ë³¸ê°’
    
    def _calculate_historical_metrics(self) -> tuple:
        """ê³¼ê±° ê±°ë˜ ë°ì´í„° ê¸°ë°˜ ë©”íŠ¸ë¦­ ê³„ì‚° - ìˆ˜ì •ë¨: Zero division ë°©ì§€"""
        if len(self.trade_history) < 10:
            return 0.6, 1.5, 1.0  # ê¸°ë³¸ê°’
        
        recent_trades = self.trade_history[-50:]  # ìµœê·¼ 50ê°œ ê±°ë˜
        
        wins = [trade for trade in recent_trades if trade['pnl'] > 0]
        losses = [trade for trade in recent_trades if trade['pnl'] < 0]
        
        win_rate = len(wins) / len(recent_trades) if recent_trades else 0.6
        avg_win = sum(trade['pnl'] for trade in wins) / len(wins) if wins else 1.5
        avg_loss = abs(sum(trade['pnl'] for trade in losses) / len(losses)) if losses else 1.0
        
        return win_rate, avg_win, avg_loss
    
    def _update_volatility_multiplier(self, volatility: float):
        """ë³€ë™ì„± ê¸°ë°˜ ë¦¬ìŠ¤í¬ ìŠ¹ìˆ˜ ì—…ë°ì´íŠ¸"""
        if volatility > 0.05:  # 5% ì´ìƒ ê³ ë³€ë™ì„±
            self.volatility_multiplier = 0.7
        elif volatility > 0.03:  # 3% ì´ìƒ ì¤‘ë³€ë™ì„±
            self.volatility_multiplier = 0.85
        else:  # ì €ë³€ë™ì„±
            self.volatility_multiplier = 1.0
    
    def update_position_status(self, position_update: Dict):
        """í¬ì§€ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸ (ê³ ê¸‰ ì¶”ì )"""
        with self.lock:
            try:
                action = position_update.get('action')
                
                if action == 'open':
                    self.active_positions += 1
                    self.total_exposure += position_update.get('size_pct', 0)
                    self.risk_metrics['daily_trades'] += 1
                    
                elif action == 'close':
                    self.active_positions = max(0, self.active_positions - 1)
                    self.total_exposure -= position_update.get('size_pct', 0)
                    self.total_exposure = max(0, self.total_exposure)
                    
                    # P&L ì—…ë°ì´íŠ¸ ë° ê±°ë˜ ê¸°ë¡
                    pnl_pct = position_update.get('pnl_pct', 0)
                    self.daily_pnl += pnl_pct
                    
                    # ê±°ë˜ ê¸°ë¡ ì €ì¥
                    trade_record = {
                        'timestamp': datetime.now().isoformat(),
                        'symbol': position_update.get('symbol', 'UNKNOWN'),
                        'pnl': pnl_pct,
                        'size_pct': position_update.get('size_pct', 0),
                        'duration': position_update.get('duration_minutes', 0)
                    }
                    self.trade_history.append(trade_record)
                    
                    # ê±°ë˜ ê¸°ë¡ í¬ê¸° ì œí•œ
                    if len(self.trade_history) > 500:
                        self.trade_history = self.trade_history[-400:]
                    
                    # ì—°ìŠ¹/ì—°íŒ¨ ì¶”ì 
                    if pnl_pct > 0:
                        self.risk_metrics['win_streak'] += 1
                        self.risk_metrics['loss_streak'] = 0
                        self.risk_metrics['largest_win'] = max(
                            self.risk_metrics['largest_win'], pnl_pct
                        )
                    else:
                        self.risk_metrics['loss_streak'] += 1
                        self.risk_metrics['win_streak'] = 0
                        self.risk_metrics['largest_loss'] = min(
                            self.risk_metrics['largest_loss'], pnl_pct
                        )
                    
                    # ìŠ¹ë¥  ì—…ë°ì´íŠ¸
                    recent_trades = self.trade_history[-20:] if len(self.trade_history) >= 20 else self.trade_history
                    if recent_trades:
                        wins = sum(1 for trade in recent_trades if trade['pnl'] > 0)
                        self.risk_metrics['success_rate'] = wins / len(recent_trades)
                
                # ê°ì‚¬ ë¡œê·¸
                audit_logger.log_event(
                    'POSITION_UPDATE',
                    'system',
                    {
                        'action': action,
                        'active_positions': self.active_positions,
                        'total_exposure': self.total_exposure
                    }
                )
                    
            except Exception as e:
                secure_logger.error(f"í¬ì§€ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
                audit_logger.log_event(
                    'POSITION_UPDATE_ERROR',
                    'system',
                    {'error': str(e)},
                    'HIGH'
                )
    
    def _validate_inputs(self, signal_data: Dict, analysis: Dict) -> bool:
        """ì…ë ¥ ë°ì´í„° ìœ íš¨ì„± ê²€ì¦"""
        try:
            if not isinstance(signal_data, dict) or not isinstance(analysis, dict):
                return False
            
            required_fields = ['symbol', 'price', 'account_balance']
            for field in required_fields:
                if field not in signal_data:
                    return False
            
            if 'confidence' not in analysis:
                return False
            
            return True
        except Exception:
            return False
    
    def _check_daily_reset(self):
        """ì¼ì¼ ë¦¬ì…‹ ì²´í¬"""
        today = datetime.now().date()
        if today != self.last_reset:
            self.daily_pnl = 0.0
            self.risk_metrics['daily_trades'] = 0
            self.last_reset = today
    
    def _create_error_response(self, error_msg: str) -> Dict:
        """ì—ëŸ¬ ì‘ë‹µ ìƒì„±"""
        return {
            'approved': False,
            'position_size': 0,
            'position_size_pct': 0,
            'risk_level': 'CRITICAL',
            'checks': [error_msg],
            'error': error_msg
        }
    
    def get_risk_status(self) -> Dict:
        """ë¦¬ìŠ¤í¬ ìƒíƒœ ì¡°íšŒ"""
        with self.lock:
            return {
                'current_status': {
                    'daily_pnl': round(self.daily_pnl, 4),
                    'active_positions': self.active_positions,
                    'total_exposure': round(self.total_exposure, 4),
                    'risk_utilization': round(abs(self.daily_pnl) / CONFIG.MAX_DAILY_LOSS, 4) if CONFIG.MAX_DAILY_LOSS > 0 else 0
                },
                'limits': {
                    'max_daily_loss': CONFIG.MAX_DAILY_LOSS,
                    'max_positions': CONFIG.MAX_POSITIONS,
                    'max_position_size': CONFIG.MAX_POSITION_SIZE,
                    'min_confidence': CONFIG.MIN_CONFIDENCE
                },
                'timestamp': datetime.now().isoformat()
            }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# âš¡ Trade Executor
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class TradeExecutor:
    """í—¤ì§€í€ë“œê¸‰ ê±°ë˜ ì‹¤í–‰ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.api_key = CONFIG.BINANCE_API_KEY
        self.api_secret = CONFIG.BINANCE_SECRET
        self.test_mode = CONFIG.TRADE_MODE == 'TEST'
        
        self.leverage = CONFIG.LEVERAGE
        self.stop_loss_pct = CONFIG.STOP_LOSS
        self.take_profit_pct = CONFIG.TAKE_PROFIT
        
        self.execution_stats = {
            'total_trades': 0,
            'successful_trades': 0,
            'failed_trades': 0,
            'avg_execution_time': 0.0,
            'total_volume': 0.0,
            'slippage_stats': {
                'avg_slippage': 0.0,
                'max_slippage': 0.0
            }
        }
        
        self.lock = threading.RLock()
        
        # Binance í´ë¼ì´ì–¸íŠ¸ ì´ˆê¸°í™”
        if not self.test_mode and self.api_key and self.api_secret:
            self.binance_client = BinanceClient(
                self.api_key, 
                self.api_secret, 
                testnet=True  # ì•ˆì „ì„ ìœ„í•´ ê¸°ë³¸ê°’ì€ testnet
            )
        else:
            self.binance_client = None
        
    async def execute_trade(self, signal: Dict, risk_approval: Dict) -> Dict:
        """ê±°ë˜ ì‹¤í–‰"""
        
        with self.lock:
            # ê°ì‚¬ ë¡œê·¸
            audit_logger.log_event(
                'TRADE_EXECUTION_START',
                'system',
                {
                    'symbol': signal.get('symbol', 'UNKNOWN'),
                    'approved': risk_approval.get('approved', False)
                }
            )
            
            if not risk_approval.get('approved'):
                result = {
                    'status': 'rejected',
                    'reason': 'Risk not approved',
                    'risk_checks': risk_approval.get('checks', [])
                }
                audit_logger.log_event(
                    'TRADE_EXECUTION_REJECTED',
                    'system',
                    result,
                    'HIGH'
                )
                return result
            
            execution_start = time.time()
            
            try:
                # ì…ë ¥ ë°ì´í„° ê²€ì¦
                validated_signal = self._validate_signal(signal)
                position_size = risk_approval.get('position_size', 0)
                
                if position_size <= 0:
                    return {'status': 'rejected', 'reason': 'Invalid position size'}
                
                # 1. ë ˆë²„ë¦¬ì§€ ì„¤ì •
                leverage_result = await self._set_leverage(validated_signal['symbol'])
                if 'error' in leverage_result:
                    raise Exception(f"ë ˆë²„ë¦¬ì§€ ì„¤ì • ì‹¤íŒ¨: {leverage_result['error']}")
                
                # 2. ì£¼ë¬¸ ì‹¤í–‰
                order_result = await self._place_order(
                    symbol=validated_signal['symbol'],
                    side=validated_signal['side'],
                    quantity=position_size,
                    price=validated_signal['price']
                )
                
                if order_result.get('status') == 'FILLED' or (not self.test_mode and 'orderId' in order_result):
                    # 3. ìµì ˆ/ì†ì ˆ ì£¼ë¬¸ ì„¤ì •
                    stop_orders = await self._set_stop_orders(order_result, validated_signal['side'])
                    
                    # 4. ìŠ¬ë¦¬í”¼ì§€ ê³„ì‚°
                    expected_price = validated_signal['price']
                    actual_price = float(order_result.get('price', expected_price))
                    slippage = abs(actual_price - expected_price) / expected_price if expected_price > 0 else 0  # ìˆ˜ì •: Zero division ë°©ì§€
                    
                    # 5. ì‹¤í–‰ í†µê³„ ì—…ë°ì´íŠ¸
                    execution_time = (time.time() - execution_start) * 1000
                    self._update_stats(execution_time, position_size, True, slippage)
                    
                    result = {
                        'status': 'executed',
                        'execution_time_ms': round(execution_time, 2),
                        'order_details': {
                            'order_id': order_result.get('orderId', f"TEST_{int(time.time())}"),
                            'symbol': validated_signal['symbol'],
                            'side': validated_signal['side'],
                            'executed_price': actual_price,
                            'executed_qty': order_result.get('executedQty', position_size),
                            'leverage': self.leverage,
                            'slippage_pct': round(slippage * 100, 4)
                        },
                        'risk_management': {
                            'stop_loss_price': stop_orders['stop_loss'],
                            'take_profit_price': stop_orders['take_profit'],
                            'liquidation_price': self._calculate_liquidation_price(
                                actual_price, validated_signal['side']
                            )
                        },
                        'metadata': {
                            'execution_mode': 'TEST' if self.test_mode else 'LIVE',
                            'timestamp': datetime.now().isoformat(),
                            'binance_client': bool(self.binance_client)
                        }
                    }
                    
                    # ê°ì‚¬ ë¡œê·¸
                    audit_logger.log_event(
                        'TRADE_EXECUTION_SUCCESS',
                        'system',
                        {
                            'order_id': result['order_details']['order_id'],
                            'symbol': validated_signal['symbol'],
                            'execution_time_ms': execution_time
                        }
                    )
                    
                    return result
                    
                else:
                    self._update_stats(0, 0, False, 0)
                    error_result = {
                        'status': 'failed',
                        'reason': f"Order failed: {order_result.get('msg', 'Unknown error')}"
                    }
                    
                    audit_logger.log_event(
                        'TRADE_EXECUTION_FAILED',
                        'system',
                        error_result,
                        'HIGH'
                    )
                    
                    return error_result
                    
            except Exception as e:
                self._update_stats(0, 0, False, 0)
                secure_logger.error(f"ê±°ë˜ ì‹¤í–‰ ì˜¤ë¥˜: {e}")
                
                error_result = {
                    'status': 'error',
                    'error': 'Trade execution failed',
                    'timestamp': datetime.now().isoformat()
                }
                
                audit_logger.log_event(
                    'TRADE_EXECUTION_ERROR',
                    'system',
                    {'error': str(e)},
                    'CRITICAL'
                )
                
                return error_result
    
    def _validate_signal(self, signal: Dict) -> Dict:
        """ì‹ í˜¸ ë°ì´í„° ê²€ì¦"""
        required_fields = ['symbol', 'side', 'price']
        for field in required_fields:
            if field not in signal:
                raise ValueError(f"í•„ìˆ˜ í•„ë“œ ëˆ„ë½: {field}")
        
        symbol = str(signal['symbol']).upper()
        side = str(signal['side']).upper()
        price = float(signal['price'])
        
        if side not in ['BUY', 'SELL']:
            raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ ê±°ë˜ ë°©í–¥: {side}")
        
        if price <= 0:
            raise ValueError(f"ìœ íš¨í•˜ì§€ ì•Šì€ ê°€ê²©: {price}")
        
        return {
            'symbol': symbol,
            'side': side,
            'price': price
        }
    
    async def _set_leverage(self, symbol: str) -> Dict:
        """ë ˆë²„ë¦¬ì§€ ì„¤ì • (ì‹¤ì œ API ë˜ëŠ” ì‹œë®¬ë ˆì´ì…˜)"""
        if self.test_mode:
            secure_logger.info(f"[TEST] {symbol} ë ˆë²„ë¦¬ì§€ {self.leverage}x ISOLATED ì„¤ì •")
            return {'status': 'success', 'leverage': self.leverage}
        
        elif self.binance_client:
            try:
                result = await self.binance_client.set_leverage(symbol, self.leverage)
                if 'code' in result and result['code'] != 200:
                    return {'error': result.get('msg', 'Leverage setting failed')}
                
                secure_logger.info(f"[LIVE] {symbol} ë ˆë²„ë¦¬ì§€ {self.leverage}x ì„¤ì • ì™„ë£Œ")
                return {'status': 'success', 'leverage': self.leverage}
                
            except Exception as e:
                return {'error': f"Binance API ì˜¤ë¥˜: {e}"}
        
        else:
            return {'error': 'Binance client not initialized'}
    
    async def _place_order(self, symbol: str, side: str, quantity: float, price: float) -> Dict:
        """ì£¼ë¬¸ ì‹¤í–‰ (ì‹¤ì œ API ë˜ëŠ” ì‹œë®¬ë ˆì´ì…˜)"""
        if self.test_mode:
            order_id = f"TEST_{int(time.time() * 1000)}"
            secure_logger.info(f"[TEST] {side} ì£¼ë¬¸: {symbol} @ ${price:,.2f}, ìˆ˜ëŸ‰: {quantity:,.2f}")
            
            return {
                'orderId': order_id,
                'status': 'FILLED',
                'price': price,
                'executedQty': quantity,
                'symbol': symbol,
                'side': side
            }
            
        elif self.binance_client:
            try:
                # ì‹¤ì œ Binance API í˜¸ì¶œ
                result = await self.binance_client.new_order(
                    symbol=symbol,
                    side=side,
                    order_type='MARKET',  # ì‹œì¥ê°€ ì£¼ë¬¸
                    quantity=quantity
                )
                
                if 'code' in result and result['code'] != 200:
                    return {'status': 'FAILED', 'msg': result.get('msg', 'Order failed')}
                
                secure_logger.info(f"[LIVE] {side} ì£¼ë¬¸ ì²´ê²°: {symbol}")
                return result
                
            except Exception as e:
                return {'status': 'FAILED', 'msg': f"API ì˜¤ë¥˜: {e}"}
        
        else:
            # Fallback to simulation
            order_id = f"SIM_{int(time.time() * 1000)}"
            secure_logger.info(f"[SIM] {side} ì£¼ë¬¸: {symbol}")
            
            return {
                'orderId': order_id,
                'status': 'FILLED',
                'price': price,
                'executedQty': quantity
            }
    
    async def _set_stop_orders(self, order_result: Dict, side: str) -> Dict:
        """ìµì ˆ/ì†ì ˆ ì£¼ë¬¸ ì„¤ì •"""
        entry_price = float(order_result['price'])
        
        if side == 'BUY':
            stop_loss = entry_price * (1 - self.stop_loss_pct)
            take_profit = entry_price * (1 + self.take_profit_pct)
        else:  # SELL
            stop_loss = entry_price * (1 + self.stop_loss_pct)
            take_profit = entry_price * (1 - self.take_profit_pct)
        
        mode_str = "TEST" if self.test_mode else "LIVE"
        secure_logger.info(f"[{mode_str}] ì†ìµ ì£¼ë¬¸ ì„¤ì • - SL: ${stop_loss:,.2f}, TP: ${take_profit:,.2f}")
        
        return {
            'stop_loss': stop_loss,
            'take_profit': take_profit
        }
    
    def _calculate_liquidation_price(self, entry_price: float, side: str) -> float:
        """ì²­ì‚°ê°€ ê³„ì‚° - ìˆ˜ì •ë¨: Zero division ë°©ì§€"""
        try:
            entry_price = float(entry_price)
            maintenance_margin = 0.004  # 0.4%
            
            if self.leverage <= 0:
                return 0  # ìˆ˜ì •: Zero division ë°©ì§€
            
            if side == 'BUY':
                liquidation_price = entry_price * (1 - (1/self.leverage) + maintenance_margin)
            else:  # SELL
                liquidation_price = entry_price * (1 + (1/self.leverage) - maintenance_margin)
            
            return max(0, liquidation_price)
        except Exception:
            return 0
    
    def _update_stats(self, execution_time: float, volume: float, success: bool, slippage: float = 0):
        """ì‹¤í–‰ í†µê³„ ì—…ë°ì´íŠ¸ (ìŠ¬ë¦¬í”¼ì§€ í¬í•¨)"""
        try:
            self.execution_stats['total_trades'] += 1
            
            if success:
                self.execution_stats['successful_trades'] += 1
                self.execution_stats['total_volume'] += volume
                
                # í‰ê·  ì‹¤í–‰ ì‹œê°„ ì—…ë°ì´íŠ¸
                current_avg = self.execution_stats['avg_execution_time']
                total_successful = self.execution_stats['successful_trades']
                new_avg = ((current_avg * (total_successful - 1)) + execution_time) / total_successful
                self.execution_stats['avg_execution_time'] = new_avg
                
                # ìŠ¬ë¦¬í”¼ì§€ í†µê³„ ì—…ë°ì´íŠ¸
                slippage_stats = self.execution_stats['slippage_stats']
                current_avg_slip = slippage_stats['avg_slippage']
                new_avg_slip = ((current_avg_slip * (total_successful - 1)) + slippage) / total_successful
                slippage_stats['avg_slippage'] = new_avg_slip
                slippage_stats['max_slippage'] = max(slippage_stats['max_slippage'], slippage)
                
            else:
                self.execution_stats['failed_trades'] += 1
                
        except Exception as e:
            secure_logger.error(f"í†µê³„ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
    
    async def close_connections(self):
        """ì—°ê²° ì¢…ë£Œ"""
        if self.binance_client:
            await self.binance_client.close()
    
    def get_stats(self) -> Dict:
        """ì‹¤í–‰ í†µê³„ ì¡°íšŒ"""
        with self.lock:
            total = self.execution_stats['total_trades']
            success_rate = (
                self.execution_stats['successful_trades'] / total * 100 
                if total > 0 else 0
            )
            
            return {
                'execution_stats': {
                    **self.execution_stats,
                    'success_rate_pct': round(success_rate, 2)
                },
                'configuration': {
                    'leverage': self.leverage,
                    'stop_loss_pct': self.stop_loss_pct,
                    'take_profit_pct': self.take_profit_pct,
                    'test_mode': self.test_mode
                }
            }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“Š Monitor & Alert
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class MonitorAlert:
    """í—¤ì§€í€ë“œê¸‰ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ"""
    
    def __init__(self):
        self.telegram_token = CONFIG.TELEGRAM_TOKEN
        self.chat_id = CONFIG.TELEGRAM_CHAT_ID
        
        self.positions = {}
        self.alerts_sent = set()
        self.lock = threading.RLock()
        
        self.alert_stats = {
            'total_sent': 0,
            'trade_alerts': 0,
            'system_alerts': 0,
            'failed_alerts': 0
        }
        
    async def send_trade_alert(self, trade_data: Dict):
        """ê±°ë˜ ì•Œë¦¼ ì „ì†¡"""
        with self.lock:
            try:
                execution_result = trade_data.get('execution_result', {})
                
                if execution_result.get('status') == 'executed':
                    message = self._format_execution_alert(execution_result)
                    await self._send_telegram(message)
                    self.alert_stats['trade_alerts'] += 1
                    
                elif execution_result.get('status') == 'rejected':
                    message = self._format_rejection_alert(execution_result)
                    await self._send_telegram(message)
                    self.alert_stats['trade_alerts'] += 1
                
                self.alert_stats['total_sent'] += 1
                
            except Exception as e:
                secure_logger.error(f"ê±°ë˜ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
                self.alert_stats['failed_alerts'] += 1
    
    def _format_execution_alert(self, execution_result: Dict) -> str:
        """ê±°ë˜ ì‹¤í–‰ ì•Œë¦¼ í¬ë§·"""
        order_details = execution_result.get('order_details', {})
        risk_mgmt = execution_result.get('risk_management', {})
        
        message = f"""
ğŸ¦ <b>í—¤ì§€í€ë“œ ê±°ë˜ ì‹¤í–‰</b>

ğŸ“Š <b>ê¸°ë³¸ ì •ë³´</b>
â€¢ ì‹¬ë³¼: <code>{order_details.get('symbol', 'UNKNOWN')}</code>
â€¢ ë°©í–¥: <b>{order_details.get('side', 'UNKNOWN')}</b>
â€¢ ê°€ê²©: <code>${order_details.get('executed_price', 0):,.2f}</code>
â€¢ ìˆ˜ëŸ‰: <code>{order_details.get('executed_qty', 0):,.4f}</code>

âš¡ <b>ë ˆë²„ë¦¬ì§€ ì •ë³´</b>
â€¢ ë ˆë²„ë¦¬ì§€: <b>{order_details.get('leverage', 20)}x ISOLATED</b>
â€¢ ì²­ì‚°ê°€: <code>${risk_mgmt.get('liquidation_price', 0):,.2f}</code>

ğŸ¯ <b>ë¦¬ìŠ¤í¬ ê´€ë¦¬</b>
â€¢ ìµì ˆê°€: <code>${risk_mgmt.get('take_profit_price', 0):,.2f}</code> (+{CONFIG.TAKE_PROFIT:.1%})
â€¢ ì†ì ˆê°€: <code>${risk_mgmt.get('stop_loss_price', 0):,.2f}</code> (-{CONFIG.STOP_LOSS:.1%})

ğŸ“ˆ <b>ì‹¤í–‰ ì •ë³´</b>
â€¢ ì‹¤í–‰ì‹œê°„: {execution_result.get('execution_time_ms', 0):.1f}ms
â€¢ ëª¨ë“œ: {execution_result.get('metadata', {}).get('execution_mode', 'UNKNOWN')}

â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        return message
    
    def _format_rejection_alert(self, execution_result: Dict) -> str:
        """ê±°ë˜ ê±°ì ˆ ì•Œë¦¼ í¬ë§·"""
        message = f"""
ğŸš« <b>ê±°ë˜ ê±°ì ˆ</b>

âŒ <b>ê±°ì ˆ ì‚¬ìœ :</b> {execution_result.get('reason', 'Unknown')}

ğŸ” <b>ë¦¬ìŠ¤í¬ ì²´í¬:</b>
{chr(10).join(f"â€¢ {check}" for check in execution_result.get('risk_checks', []))}

â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        return message
    
    async def send_system_alert(self, alert_type: str, message: str, severity: str = 'INFO'):
        """ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡"""
        with self.lock:
            try:
                emoji_map = {
                    'INFO': 'â„¹ï¸',
                    'WARNING': 'âš ï¸',
                    'ERROR': 'âŒ',
                    'CRITICAL': 'ğŸš¨'
                }
                
                emoji = emoji_map.get(severity, 'â„¹ï¸')
                
                formatted_message = f"""
{emoji} <b>ì‹œìŠ¤í…œ ì•Œë¦¼</b>

ğŸ“‹ <b>ìœ í˜•:</b> {alert_type}
ğŸ” <b>ë‚´ìš©:</b> {message}
ğŸ“Š <b>ì‹¬ê°ë„:</b> {severity}

â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
                await self._send_telegram(formatted_message)
                self.alert_stats['system_alerts'] += 1
                self.alert_stats['total_sent'] += 1
                
            except Exception as e:
                secure_logger.error(f"ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
                self.alert_stats['failed_alerts'] += 1
    
    async def _send_telegram(self, message: str):
        """í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ - ìˆ˜ì •ë¨: ë¹„ë™ê¸° requests ì‚¬ìš©"""
        if not self.telegram_token or not self.chat_id:
            secure_logger.warning("í…”ë ˆê·¸ë¨ ì„¤ì •ì´ ì—†ì–´ ì•Œë¦¼ì„ ì „ì†¡í•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
            return
        
        url = f"https://api.telegram.org/bot{self.telegram_token}/sendMessage"
        data = {
            'chat_id': self.chat_id,
            'text': message,
            'parse_mode': 'HTML',
            'disable_web_page_preview': True
        }
        
        try:
            # ë¹„ë™ê¸° HTTP ìš”ì²­ìœ¼ë¡œ ë³€ê²½
            async with aiohttp.ClientSession() as session:
                async with session.post(url, data=data, timeout=10) as response:
                    if response.status == 200:
                        secure_logger.info("âœ… í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì „ì†¡ ì„±ê³µ")
                    else:
                        secure_logger.error(f"âŒ í…”ë ˆê·¸ë¨ ì „ì†¡ ì‹¤íŒ¨: HTTP {response.status}")
        except Exception as e:
            secure_logger.error(f"âŒ í…”ë ˆê·¸ë¨ ì˜¤ë¥˜: {e}")
    
    async def health_check_all_services(self) -> Dict:
        """ì „ì²´ ì„œë¹„ìŠ¤ í—¬ìŠ¤ì²´í¬"""
        services = {
            'signal_engine': 'http://localhost:8100/health',
            'risk_guardian': 'http://localhost:8101/health',
            'trade_executor': 'http://localhost:8102/health'
        }
        
        results = {}
        healthy_count = 0
        
        for service_name, url in services.items():
            try:
                start_time = time.time()
                # ë™ê¸° requestsë¥¼ ë¹„ë™ê¸°ë¡œ ëŒ€ì²´
                async with aiohttp.ClientSession() as session:
                    async with session.get(url, timeout=5) as response:
                        response_time = (time.time() - start_time) * 1000
                        
                        if response.status == 200:
                            response_data = await response.json()
                            results[service_name] = {
                                'status': 'healthy',
                                'response_time_ms': round(response_time, 2),
                                'data': response_data
                            }
                            healthy_count += 1
                        else:
                            results[service_name] = {
                                'status': 'unhealthy',
                                'http_status': response.status
                            }
            except Exception as e:
                results[service_name] = {
                    'status': 'unreachable',
                    'error': str(e)
                }
        
        overall_status = 'healthy' if healthy_count == len(services) else 'degraded'
        
        return {
            'overall_status': overall_status,
            'healthy_services': healthy_count,
            'total_services': len(services),
            'services': results,
            'alert_stats': self.alert_stats,
            'timestamp': datetime.now().isoformat()
        }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ“± ì›¹ UI ëŒ€ì‹œë³´ë“œ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

dashboard_html = '''
<!DOCTYPE html>
<html>
<head>
    <title>Phoenix 95 Dashboard</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; background: #1a1a1a; color: #fff; }
        .container { max-width: 1200px; margin: 0 auto; }
        .header { text-align: center; margin-bottom: 30px; }
        .card { background: #2a2a2a; border-radius: 8px; padding: 20px; margin: 10px; box-shadow: 0 2px 4px rgba(0,0,0,0.3); }
        .metric { display: inline-block; margin: 10px; text-align: center; }
        .metric-value { font-size: 24px; font-weight: bold; color: #4CAF50; }
        .metric-label { font-size: 12px; color: #888; }
        .status-healthy { color: #4CAF50; }
        .status-warning { color: #FF9800; }
        .status-error { color: #F44336; }
        .refresh-btn { background: #4CAF50; color: white; border: none; padding: 10px 20px; border-radius: 4px; cursor: pointer; }
        .refresh-btn:hover { background: #45a049; }
        table { width: 100%; border-collapse: collapse; margin-top: 10px; }
        th, td { border: 1px solid #444; padding: 8px; text-align: left; }
        th { background-color: #333; }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¦ Phoenix 95 Dashboard v4.3.1</h1>
            <button class="refresh-btn" onclick="location.reload()">ìƒˆë¡œê³ ì¹¨</button>
        </div>
        
        <div class="card">
            <h3>ğŸ“Š ì‹œìŠ¤í…œ ìƒíƒœ</h3>
            <div id="system-status">ë¡œë”© ì¤‘...</div>
        </div>
        
        <div class="card">
            <h3>ğŸ“ˆ ê±°ë˜ í†µê³„</h3>
            <div id="trading-stats">ë¡œë”© ì¤‘...</div>
        </div>
        
        <div class="card">
            <h3>ğŸ›¡ï¸ ë¦¬ìŠ¤í¬ í˜„í™©</h3>
            <div id="risk-status">ë¡œë”© ì¤‘...</div>
        </div>
        
        <div class="card">
            <h3>ğŸ“‹ ìµœê·¼ ì´ë²¤íŠ¸</h3>
            <div id="recent-events">ë¡œë”© ì¤‘...</div>
        </div>
    </div>
    
    <script>
        async function loadSystemStatus() {
            try {
                const response = await fetch('/api/health/all');
                const data = await response.json();
                
                let html = '<div class="metric"><div class="metric-value status-' + 
                    (data.overall_status === 'healthy' ? 'healthy' : 'error') + 
                    '">' + data.overall_status.toUpperCase() + '</div><div class="metric-label">ì „ì²´ ìƒíƒœ</div></div>';
                
                html += '<div class="metric"><div class="metric-value">' + data.healthy_services + '/' + data.total_services + '</div><div class="metric-label">ì •ìƒ ì„œë¹„ìŠ¤</div></div>';
                
                document.getElementById('system-status').innerHTML = html;
            } catch (error) {
                document.getElementById('system-status').innerHTML = '<span class="status-error">ë¡œë“œ ì‹¤íŒ¨</span>';
            }
        }
        
        async function loadTradingStats() {
            try {
                const response = await fetch('/api/stats');
                const data = await response.json();
                
                let html = '<div class="metric"><div class="metric-value">' + (data.trading?.total_trades || 0) + '</div><div class="metric-label">ì´ ê±°ë˜</div></div>';
                html += '<div class="metric"><div class="metric-value">' + (data.trading?.success_rate_pct || 0).toFixed(1) + '%</div><div class="metric-label">ì„±ê³µë¥ </div></div>';
                html += '<div class="metric"><div class="metric-value">' + (data.trading?.avg_execution_time || 0).toFixed(0) + 'ms</div><div class="metric-label">í‰ê·  ì‹¤í–‰ì‹œê°„</div></div>';
                
                document.getElementById('trading-stats').innerHTML = html;
            } catch (error) {
                document.getElementById('trading-stats').innerHTML = '<span class="status-error">ë¡œë“œ ì‹¤íŒ¨</span>';
            }
        }
        
        // ì´ˆê¸° ë¡œë“œ
        loadSystemStatus();
        loadTradingStats();
        
        // 30ì´ˆë§ˆë‹¤ ìë™ ìƒˆë¡œê³ ì¹¨
        setInterval(() => {
            loadSystemStatus();
            loadTradingStats();
        }, 30000);
    </script>
</body>
</html>
'''

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸŒ ì„œë¹„ìŠ¤ ê°„ í†µì‹ 
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def call_service(service_name: str, endpoint: str, data: Dict) -> Dict:
    """ì„œë¹„ìŠ¤ ê°„ í†µì‹  (ë³´ì•ˆ ê°•í™”)"""
    service_ports = {
        'signal-engine': 8100,
        'risk-guardian': 8101,
        'trade-executor': 8102,
        'monitor-alert': 8103
    }
    
    port = service_ports.get(service_name)
    if not port:
        secure_logger.error(f"ì•Œ ìˆ˜ ì—†ëŠ” ì„œë¹„ìŠ¤: {service_name}")
        return {'error': f'Unknown service: {service_name}'}
    
    url = f"http://localhost:{port}{endpoint}"
    
    try:
        if endpoint.startswith('/health') or endpoint.startswith('/status') or endpoint.startswith('/audit'):
            # GET ìš”ì²­
            return await network_client.safe_get(url)
        else:
            # POST ìš”ì²­
            return await network_client.safe_post(url, json_data=data)
            
    except Exception as e:
        secure_logger.error(f"ì„œë¹„ìŠ¤ í†µì‹  ì˜¤ë¥˜ ({service_name}): {e}")
        return {'error': str(e)}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸš€ FastAPI ì• í”Œë¦¬ì¼€ì´ì…˜ë“¤
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def create_secure_app(title: str, description: str) -> FastAPI:
    """ë³´ì•ˆ ë¯¸ë“¤ì›¨ì–´ê°€ í¬í•¨ëœ FastAPI ì•± ìƒì„±"""
    app = FastAPI(
        title=title,
        version="4.3.1",
        description=description,
        docs_url="/docs" if CONFIG.TRADE_MODE == 'TEST' else None,  # LIVE ëª¨ë“œì—ì„œëŠ” docs ë¹„í™œì„±í™”
        redoc_url="/redoc" if CONFIG.TRADE_MODE == 'TEST' else None
    )
    
    # í˜ì´ë¡œë“œ í¬ê¸° ì œí•œ ë¯¸ë“¤ì›¨ì–´
    app.add_middleware(PayloadSizeLimitMiddleware, max_size_bytes=1024*1024)
    
    return app

# Signal Engine ì•±
signal_app = create_secure_app(
    "Phoenix 95 Signal Engine - Fixed Edition",
    "í—¤ì§€í€ë“œê¸‰ AI ì‹ í˜¸ ë¶„ì„ ì—”ì§„ (ì˜¤ë¥˜ ìˆ˜ì •ë¨)"
)

phoenix_engine = Phoenix95Engine()

@signal_app.post("/analyze")
async def analyze_signal(data: dict):
    """í•µì‹¬ ì‹ í˜¸ ë¶„ì„ API"""
    try:
        analysis = phoenix_engine.analyze(data)
        
        # ê³ ì‹ ë¢°ë„ ì‹ í˜¸ì¸ ê²½ìš° ë¦¬ìŠ¤í¬ ì²´í¬
        if analysis.get('confidence', 0) > CONFIG.MIN_CONFIDENCE and 'error' not in analysis:
            risk_check = await call_service(
                'risk-guardian', 
                '/check',
                {'signal_data': data, 'analysis': analysis}
            )
            analysis['risk_check'] = risk_check
        
        return {
            'status': 'success',
            'analysis': analysis,
            'engine': 'Phoenix 95 V4.3.1 Fixed',
            'timestamp': datetime.now().isoformat()
        }
        
    except Exception as e:
        secure_logger.error(f"ë¶„ì„ API ì˜¤ë¥˜: {e}")
        raise HTTPException(status_code=500, detail=f"ë¶„ì„ ì‹¤íŒ¨: {str(e)}")

@signal_app.get("/health")
async def health():
    return {
        'status': 'healthy',
        'service': 'signal_engine',
        'engine': phoenix_engine.name,
        'version': phoenix_engine.version,
        'timestamp': datetime.now().isoformat()
    }

# Risk Guardian ì•±
risk_app = create_secure_app(
    "Phoenix 95 Risk Guardian - Fixed Edition",
    "í—¤ì§€í€ë“œê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ ì‹œìŠ¤í…œ (ì˜¤ë¥˜ ìˆ˜ì •ë¨)"
)

risk_guardian = RiskGuardian()

@risk_app.post("/check")
async def check_risk(data: dict):
    """ë¦¬ìŠ¤í¬ ì²´í¬ API"""
    try:
        # ìš”ì²­ í¬ê¸° ì¶”ê°€ ì²´í¬
        request_size = len(json.dumps(data))
        if request_size > 102400:  # 100KB
            secure_logger.warning(f"ëŒ€ìš©ëŸ‰ ìš”ì²­ ê°ì§€: {request_size} bytes")
            raise HTTPException(status_code=413, detail="Request too large")
        
        signal_data = data.get('signal_data', {})
        analysis = data.get('analysis', {})
        
        result = risk_guardian.check_trade_approval(signal_data, analysis)
        
        return {
            'status': 'success',
            'risk_check': result,
            'timestamp': datetime.now().isoformat()
        }
        
    except HTTPException:
        raise
    except Exception as e:
        secure_logger.error(f"ë¦¬ìŠ¤í¬ ì²´í¬ API ì˜¤ë¥˜: {e}")
        raise HTTPException(status_code=500, detail=f"ë¦¬ìŠ¤í¬ ì²´í¬ ì‹¤íŒ¨: {str(e)}")

@risk_app.get("/audit")
async def get_audit_logs(count: int = 100, event_type: str = None):
    """ê°ì‚¬ ë¡œê·¸ ì¡°íšŒ"""
    try:
        events = audit_logger.get_recent_events(count, event_type)
        risk_summary = audit_logger.get_risk_summary()
        
        return {
            'events': events,
            'summary': risk_summary,
            'timestamp': datetime.now().isoformat()
        }
    except Exception as e:
        secure_logger.error(f"ê°ì‚¬ ë¡œê·¸ ì¡°íšŒ ì˜¤ë¥˜: {e}")
        raise HTTPException(status_code=500, detail="ê°ì‚¬ ë¡œê·¸ ì¡°íšŒ ì‹¤íŒ¨")

@risk_app.post("/update")
async def update_position(data: dict):
    """í¬ì§€ì…˜ ìƒíƒœ ì—…ë°ì´íŠ¸"""
    try:
        risk_guardian.update_position_status(data)
        return {'status': 'updated', 'timestamp': datetime.now().isoformat()}
    except Exception as e:
        secure_logger.error(f"í¬ì§€ì…˜ ì—…ë°ì´íŠ¸ ì˜¤ë¥˜: {e}")
        raise HTTPException(status_code=500, detail=f"ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {str(e)}")

@risk_app.get("/status")
async def risk_status():
    """ë¦¬ìŠ¤í¬ ìƒíƒœ ì¡°íšŒ"""
    return risk_guardian.get_risk_status()

@risk_app.get("/health")
async def health():
    return {
        'status': 'healthy',
        'service': 'risk_guardian',
        'active_positions': risk_guardian.active_positions,
        'daily_pnl': risk_guardian.daily_pnl,
        'timestamp': datetime.now().isoformat()
    }

# Trade Executor ì•±
trade_app = create_secure_app(
    "Phoenix 95 Trade Executor - Fixed Edition",
    "í—¤ì§€í€ë“œê¸‰ ê±°ë˜ ì‹¤í–‰ ì‹œìŠ¤í…œ (ì˜¤ë¥˜ ìˆ˜ì •ë¨)"
)

trade_executor = TradeExecutor()

@trade_app.post("/execute")
async def execute_trade(data: dict):
    """ê±°ë˜ ì‹¤í–‰ API"""
    try:
        signal = data.get('signal', {})
        risk_approval = data.get('risk_approval', {})
        
        result = await trade_executor.execute_trade(signal, risk_approval)
        
        return {
            'status': 'success',
            'execution_result': result,
            'timestamp': datetime.now().isoformat()
        }
        
    except Exception as e:
        secure_logger.error(f"ê±°ë˜ ì‹¤í–‰ API ì˜¤ë¥˜: {e}")
        raise HTTPException(status_code=500, detail=f"ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨: {str(e)}")

@trade_app.get("/stats")
async def execution_stats():
    """ì‹¤í–‰ í†µê³„ ì¡°íšŒ"""
    return trade_executor.get_stats()

@trade_app.get("/health")
async def health():
    stats = trade_executor.execution_stats
    return {
        'status': 'healthy',
        'service': 'trade_executor',
        'total_trades': stats['total_trades'],
        'success_rate': (
            stats['successful_trades'] / stats['total_trades'] * 100
            if stats['total_trades'] > 0 else 0
        ),
        'test_mode': trade_executor.test_mode,
        'timestamp': datetime.now().isoformat()
    }

# Monitor & Alert ì•±
monitor_app = create_secure_app(
    "Phoenix 95 Monitor & Alert - Fixed Edition",
    "í—¤ì§€í€ë“œê¸‰ ëª¨ë‹ˆí„°ë§ ë° ì•Œë¦¼ ì‹œìŠ¤í…œ (ì˜¤ë¥˜ ìˆ˜ì •ë¨)"
)

monitor_alert = MonitorAlert()

@monitor_app.post("/alert/trade")
async def trade_alert(data: dict):
    """ê±°ë˜ ì•Œë¦¼"""
    await monitor_alert.send_trade_alert(data)
    return {'status': 'sent', 'timestamp': datetime.now().isoformat()}

@monitor_app.post("/alert/system")
async def system_alert(data: dict):
    """ì‹œìŠ¤í…œ ì•Œë¦¼"""
    alert_type = data.get('type', 'SYSTEM')
    message = data.get('message', 'Unknown system event')
    severity = data.get('severity', 'INFO')
    
    await monitor_alert.send_system_alert(alert_type, message, severity)
    return {'status': 'sent', 'timestamp': datetime.now().isoformat()}

@monitor_app.get("/health/all")
async def health_check_all():
    """ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬"""
    return await monitor_alert.health_check_all_services()

@monitor_app.get("/dashboard")
async def web_dashboard():
    """ì›¹ ëŒ€ì‹œë³´ë“œ"""
    return HTMLResponse(content=dashboard_html)

@monitor_app.get("/api/health/all")
async def api_health_check_all():
    """API: ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬"""
    return await monitor_alert.health_check_all_services()

@monitor_app.get("/api/stats")
async def api_trading_stats():
    """API: ê±°ë˜ í†µê³„"""
    try:
        # Trade Executor í†µê³„
        trade_stats = await call_service('trade-executor', '/stats', {})
        
        # Risk Guardian ìƒíƒœ
        risk_status = await call_service('risk-guardian', '/status', {})
        
        # ë©”íŠ¸ë¦­ ìˆ˜ì§‘ê¸° ë°ì´í„°
        system_metrics = metrics_collector.get_metrics()
        
        return {
            'trading': trade_stats.get('execution_stats', {}),
            'risk': risk_status.get('current_status', {}),
            'system': system_metrics,
            'timestamp': datetime.now().isoformat()
        }
    except Exception as e:
        secure_logger.error(f"í†µê³„ API ì˜¤ë¥˜: {e}")
        return {'error': str(e)}

@monitor_app.get("/api/metrics")
async def api_metrics():
    """API: Prometheus ë©”íŠ¸ë¦­"""
    return PlainTextResponse(
        content=metrics_collector.export_prometheus_format(),
        media_type="text/plain"
    )

@monitor_app.get("/api/audit")
async def api_audit_logs(count: int = 50):
    """API: ê°ì‚¬ ë¡œê·¸"""
    try:
        events = audit_logger.get_recent_events(count)
        summary = audit_logger.get_risk_summary()
        
        return {
            'events': events,
            'summary': summary,
            'timestamp': datetime.now().isoformat()
        }
    except Exception as e:
        secure_logger.error(f"ê°ì‚¬ ë¡œê·¸ API ì˜¤ë¥˜: {e}")
        return {'error': str(e)}

@monitor_app.get("/health")
async def health():
    return {
        'status': 'healthy',
        'service': 'monitor_alert',
        'telegram_configured': bool(monitor_alert.telegram_token and monitor_alert.chat_id),
        'alert_stats': monitor_alert.alert_stats,
        'features': {
            'web_dashboard': True,
            'enterprise_security': True,
            'audit_logging': True,
            'metrics_collection': True,
            'cache_system': True,
            'binance_integration': True
        },
        'version': '4.3.1',
        'timestamp': datetime.now().isoformat()
    }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸƒâ€â™‚ï¸ ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜ë“¤
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def run_signal_engine():
    """Signal Engine ì‹¤í–‰"""
    try:
        uvicorn.run(signal_app, host="0.0.0.0", port=8100, log_level="error")
    except Exception as e:
        secure_logger.error(f"Signal Engine ì‹¤í–‰ ì˜¤ë¥˜: {e}")

def run_risk_guardian():
    """Risk Guardian ì‹¤í–‰"""
    try:
        uvicorn.run(risk_app, host="0.0.0.0", port=8101, log_level="error")
    except Exception as e:
        secure_logger.error(f"Risk Guardian ì‹¤í–‰ ì˜¤ë¥˜: {e}")

def run_trade_executor():
    """Trade Executor ì‹¤í–‰"""
    try:
        uvicorn.run(trade_app, host="0.0.0.0", port=8102, log_level="error")
    except Exception as e:
        secure_logger.error(f"Trade Executor ì‹¤í–‰ ì˜¤ë¥˜: {e}")

def run_monitor_alert():
    """Monitor & Alert ì‹¤í–‰"""
    try:
        uvicorn.run(monitor_app, host="0.0.0.0", port=8103, log_level="error")
    except Exception as e:
        secure_logger.error(f"Monitor & Alert ì‹¤í–‰ ì˜¤ë¥˜: {e}")

async def system_health_monitor():
    """ì‹œìŠ¤í…œ í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§"""
    secure_logger.info("ğŸ” ì‹œìŠ¤í…œ í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì‹œì‘...")
    
    while True:
        try:
            # ì „ì²´ ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬
            health_data = await monitor_alert.health_check_all_services()
            
            # ìƒíƒœ ì¶œë ¥
            timestamp = datetime.now().strftime('%H:%M:%S')
            status = health_data['overall_status']
            healthy = health_data['healthy_services']
            total = health_data['total_services']
            
            status_emoji = 'âœ…' if status == 'healthy' else 'âš ï¸'
            print(f"{status_emoji} [{timestamp}] ì‹œìŠ¤í…œ ìƒíƒœ: {status.upper()} ({healthy}/{total})")
            
            # ê° ì„œë¹„ìŠ¤ ìƒíƒœ ì¶œë ¥
            for service, data in health_data['services'].items():
                service_status = data['status']
                if service_status == 'healthy':
                    response_time = data.get('response_time_ms', 0)
                    print(f"   âœ… {service}: OK ({response_time:.1f}ms)")
                else:
                    error = data.get('error', data.get('http_status', 'Unknown'))
                    print(f"   âŒ {service}: {error}")
            
            # ì‹¬ê°í•œ ë¬¸ì œ ë°œìƒì‹œ ì•Œë¦¼
            if healthy < total:
                await monitor_alert.send_system_alert(
                    'HEALTH_CHECK',
                    f'ì„œë¹„ìŠ¤ ìƒíƒœ ì´ìƒ: {healthy}/{total} ì •ìƒ',
                    'WARNING' if healthy > 0 else 'CRITICAL'
                )
            
            print()  # ë¹ˆ ì¤„ ì¶”ê°€
            await asyncio.sleep(CONFIG.HEALTH_CHECK_INTERVAL)
            
        except KeyboardInterrupt:
            print("\nğŸ‘‹ í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ")
            break
        except Exception as e:
            secure_logger.error(f"âŒ í—¬ìŠ¤ì²´í¬ ì˜¤ë¥˜: {e}")
            await asyncio.sleep(10)

def start_hedge_fund_system():
    """í—¬ë“œí€ë“œ ì‹œìŠ¤í…œ ë©”ì¸ ëŸ°ì²˜"""
    
    print("=" * 70)
    print("ğŸ¦ Phoenix 95 í—¤ì§€í€ë“œê¸‰ ì‹œìŠ¤í…œ v4.3.1 - ìˆ˜ì •ëœ ì™„ì „ ë²„ì „")
    print("=" * 70)
    print()
    print("ğŸ¯ ì„œë¹„ìŠ¤ êµ¬ì„±:")
    print("   âœ… Signal Engine (AI ë¶„ì„): http://localhost:8100")
    print("   ğŸ›¡ï¸ Risk Guardian (ë¦¬ìŠ¤í¬): http://localhost:8101")
    print("   âš¡ Trade Executor (ê±°ë˜): http://localhost:8102")
    print("   ğŸ“Š Monitor & Alert (ì•Œë¦¼): http://localhost:8103")
    print("   ğŸŒ ì›¹ ëŒ€ì‹œë³´ë“œ: http://localhost:8103/dashboard")
    print()
    print("ğŸ”§ ì„¤ì •:")
    print(f"   â€¢ ë ˆë²„ë¦¬ì§€: {CONFIG.LEVERAGE}x ISOLATED")
    print(f"   â€¢ ìµì ˆ/ì†ì ˆ: Â±{CONFIG.STOP_LOSS:.1%}")
    print(f"   â€¢ ìµœì†Œ ì‹ ë¢°ë„: {CONFIG.MIN_CONFIDENCE:.1%}")
    print(f"   â€¢ ìµœëŒ€ ì¼ì¼ì†ì‹¤: {CONFIG.MAX_DAILY_LOSS:.1%}")
    print()
    print("ğŸš€ ìˆ˜ì • ì‚¬í•­:")
    print("   ğŸ”§ Zero division ì˜¤ë¥˜ ìˆ˜ì •")
    print("   âš¡ ë¹„ë™ê¸° ì²˜ë¦¬ ê°œì„ ")
    print("   ğŸ›¡ï¸ DELETE ë©”ì„œë“œ ì§€ì› ì¶”ê°€")
    print("   ğŸ“Š CPU ëª¨ë‹ˆí„°ë§ ë¹„ë¸”ë¡œí‚¹ ì²˜ë¦¬")
    print("   ğŸ“¡ í…”ë ˆê·¸ë¨ ë¹„ë™ê¸° ì „ì†¡")
    print("=" * 70)
    
    # ë©€í‹°í”„ë¡œì„¸ì‹±ìœ¼ë¡œ ì„œë¹„ìŠ¤ ì‹œì‘
    processes = [
        multiprocessing.Process(target=run_signal_engine, name="SignalEngine"),
        multiprocessing.Process(target=run_risk_guardian, name="RiskGuardian"),
        multiprocessing.Process(target=run_trade_executor, name="TradeExecutor"),
        multiprocessing.Process(target=run_monitor_alert, name="MonitorAlert")
    ]
    
    # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì‹œì‘
    for process in processes:
        process.start()
        print(f"ğŸš€ {process.name} ì‹œì‘ë¨")
    
    print()
    print("â³ ì„œë¹„ìŠ¤ ì´ˆê¸°í™” ëŒ€ê¸° ì¤‘...")
    time.sleep(5)  # ì„œë¹„ìŠ¤ ì‹œì‘ ëŒ€ê¸°
    
    # ì‹œì‘ ì•Œë¦¼ ì „ì†¡
    asyncio.run(send_startup_notification())
    
    # ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ ì‹œì‘ (ë°±ê·¸ë¼ìš´ë“œ)
    def start_background_monitoring():
        asyncio.run(system_monitor.monitor_resources())
    
    monitor_thread = threading.Thread(target=start_background_monitoring, daemon=True)
    monitor_thread.start()
    
    try:
        # í—¬ìŠ¤ ëª¨ë‹ˆí„°ë§ ì‹œì‘
        asyncio.run(system_health_monitor())
    except KeyboardInterrupt:
        print("\nğŸ›‘ ì‹œìŠ¤í…œ ì¢…ë£Œ ì¤‘...")
        
        # ëª¨ë“  í”„ë¡œì„¸ìŠ¤ ì¢…ë£Œ
        for process in processes:
            process.terminate()
            process.join(timeout=5)
            if process.is_alive():
                process.kill()
        
        print("âœ… ëª¨ë“  ì„œë¹„ìŠ¤ê°€ ì•ˆì „í•˜ê²Œ ì¢…ë£Œë˜ì—ˆìŠµë‹ˆë‹¤.")

async def send_startup_notification():
    """ì‹œì‘ ì•Œë¦¼ ì „ì†¡"""
    try:
        message = f"""
ğŸš€ <b>Phoenix 95 í—¤ì§€í€ë“œ ì‹œìŠ¤í…œ ì‹œì‘ (v4.3.1 Fixed)</b>

ğŸ¦ <b>ì‹œìŠ¤í…œ êµ¬ì„±</b>
â€¢ Signal Engine: AI ë¶„ì„ ì—”ì§„
â€¢ Risk Guardian: ë¦¬ìŠ¤í¬ ê´€ë¦¬
â€¢ Trade Executor: ê±°ë˜ ì‹¤í–‰
â€¢ Monitor & Alert: ëª¨ë‹ˆí„°ë§

âš™ï¸ <b>ì„¤ì •</b>
â€¢ ë ˆë²„ë¦¬ì§€: {CONFIG.LEVERAGE}x ISOLATED
â€¢ ìµì ˆ/ì†ì ˆ: Â±{CONFIG.STOP_LOSS:.1%}
â€¢ ìµœì†Œ ì‹ ë¢°ë„: {CONFIG.MIN_CONFIDENCE:.1%}
â€¢ ìµœëŒ€ ì¼ì¼ì†ì‹¤: {CONFIG.MAX_DAILY_LOSS:.1%}

ğŸ”§ <b>ìˆ˜ì • ì™„ë£Œ</b>
â€¢ Zero division ì˜¤ë¥˜ ìˆ˜ì •
â€¢ ë¹„ë™ê¸° ì²˜ë¦¬ ê°œì„ 
â€¢ DELETE ë©”ì„œë“œ ì§€ì› ì¶”ê°€
â€¢ CPU ëª¨ë‹ˆí„°ë§ ìµœì í™”
â€¢ í…”ë ˆê·¸ë¨ ë¹„ë™ê¸° ì „ì†¡

âœ… <b>ìƒíƒœ: ìš´ì˜ ì¤€ë¹„ ì™„ë£Œ</b>

â° {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}
"""
        await monitor_alert._send_telegram(message)
    except Exception as e:
        secure_logger.warning(f"ì‹œì‘ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
# ğŸ¯ ë©”ì¸ ì‹¤í–‰ë¶€
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

if __name__ == "__main__":
    try:
        print("ğŸ¦ Phoenix 95 í—¤ì§€í€ë“œê¸‰ ì‹œìŠ¤í…œ v4.3.1 - ìˆ˜ì •ëœ ì™„ì „ ë²„ì „")
        print("=" * 70)
        print("âœ… ìˆ˜ì • ì™„ë£Œ:")
        print("   ğŸ”§ Zero division ì˜¤ë¥˜ ìˆ˜ì •")
        print("   âš¡ ë¹„ë™ê¸° ì²˜ë¦¬ ê°œì„ ") 
        print("   ğŸ›¡ï¸ DELETE ë©”ì„œë“œ ì§€ì› ì¶”ê°€")
        print("   ğŸ“Š CPU ëª¨ë‹ˆí„°ë§ ë¹„ë¸”ë¡œí‚¹ ì²˜ë¦¬")
        print("   ğŸ“¡ í…”ë ˆê·¸ë¨ ë¹„ë™ê¸° ì „ì†¡")
        print("   ğŸ¯ ì¤‘ë³µ ë©”ì„œë“œ ì œê±°")
        print("=" * 70)
        
        # í™˜ê²½ ì„¤ì • í™•ì¸
        secure_logger.info(f"ê±°ë˜ ëª¨ë“œ: {CONFIG.TRADE_MODE}")
        
        # í™˜ê²½ë³€ìˆ˜ ì„¤ì •
        for env_var, default_val in [
            ('TELEGRAM_TOKEN', CONFIG.TELEGRAM_TOKEN),
            ('TELEGRAM_CHAT_ID', CONFIG.TELEGRAM_CHAT_ID),
            ('TRADE_MODE', 'TEST')
        ]:
            if not os.getenv(env_var):
                os.environ[env_var] = default_val
        
        trade_mode = os.getenv('TRADE_MODE', 'TEST')
        print(f"ğŸ“Š ê±°ë˜ ëª¨ë“œ: {trade_mode}")
        
        if trade_mode == 'LIVE':
            binance_key = os.getenv('BINANCE_API_KEY')
            binance_secret = os.getenv('BINANCE_SECRET')
            
            if not binance_key or not binance_secret:
                print("âš ï¸  LIVE ëª¨ë“œì´ì§€ë§Œ Binance API í‚¤ê°€ ì„¤ì •ë˜ì§€ ì•ŠìŒ")
                print("   TEST ëª¨ë“œë¡œ ì‹¤í–‰í•˜ê±°ë‚˜ API í‚¤ë¥¼ ì„¤ì •í•˜ì„¸ìš”:")
                print("   export BINANCE_API_KEY='your_key'")
                print("   export BINANCE_SECRET='your_secret'")
                print()
        
        print("âœ… í™˜ê²½ ì„¤ì • ì™„ë£Œ")
        print()
        
        print("ğŸš€ ìˆ˜ì •ëœ Phoenix 95 ì‹œìŠ¤í…œ ì‹œì‘ ì¤‘...")
        print("âœ… ëª¨ë“  ì˜¤ë¥˜ê°€ ìˆ˜ì •ëœ ì™„ì „í•œ êµ¬í˜„ì…ë‹ˆë‹¤!")
        
        # ì‹œìŠ¤í…œ ì‹œì‘
        start_hedge_fund_system()
        
    except Exception as e:
        secure_logger.error(f"ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì˜¤ë¥˜: {e}")
        print(f"âŒ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
        sys.exit(1)

"""
ğŸ¦ Phoenix 95 í—¤ì§€í€ë“œê¸‰ ì‹œìŠ¤í…œ - ìˆ˜ì •ëœ ì™„ì „ ë²„ì „ ì‚¬ìš© ê°€ì´ë“œ

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“‹ ìˆ˜ì • ì‚¬í•­ ìš”ì•½ (v4.3.1)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ”§ ì£¼ìš” ìˆ˜ì • ë‚´ìš©:

1. Zero Division ì˜¤ë¥˜ ìˆ˜ì •:
   - Kelly Criterion ê³„ì‚° ì‹œ ë¶„ëª¨ê°€ 0ì¸ ê²½ìš° ì²˜ë¦¬
   - ìŠ¬ë¦¬í”¼ì§€ ê³„ì‚° ì‹œ ê°€ê²©ì´ 0ì¸ ê²½ìš° ì²˜ë¦¬
   - ë ˆë²„ë¦¬ì§€ ê³„ì‚° ì‹œ 0ìœ¼ë¡œ ë‚˜ëˆ„ê¸° ë°©ì§€

2. ë¹„ë™ê¸° ì²˜ë¦¬ ê°œì„ :
   - CPU ëª¨ë‹ˆí„°ë§ì„ ë¹„ë¸”ë¡œí‚¹ ë°©ì‹ìœ¼ë¡œ ë³€ê²½
   - í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ì„ ì™„ì „ ë¹„ë™ê¸°ë¡œ ë³€ê²½
   - í—¬ìŠ¤ì²´í¬ì—ì„œ requests ëŒ€ì‹  aiohttp ì‚¬ìš©

3. API ë©”ì„œë“œ ì§€ì› ê°œì„ :
   - Binance í´ë¼ì´ì–¸íŠ¸ì— DELETE ë©”ì„œë“œ ì§€ì› ì¶”ê°€
   - ì£¼ë¬¸ ì·¨ì†Œ ê¸°ëŠ¥ ì™„ì „ êµ¬í˜„

4. ë°ì´í„° íƒ€ì… ì•ˆì •ì„±:
   - Union íƒ€ì… import ì¶”ê°€
   - ëª¨ë“  íƒ€ì… íŒíŠ¸ ê²€ì¦

5. ì¤‘ë³µ ì½”ë“œ ì œê±°:
   - ì¤‘ë³µëœ ë©”ì„œë“œ ë° í•¨ìˆ˜ ì •ë¦¬
   - ì½”ë“œ êµ¬ì¡° ìµœì í™”

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸš€ ë¹ ë¥¸ ì‹œì‘ ê°€ì´ë“œ
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. ì˜ì¡´ì„± ì„¤ì¹˜:
   pip install fastapi uvicorn aiohttp requests numpy psutil

2. ì‹¤í–‰:
   python main.py

3. ì›¹ ëŒ€ì‹œë³´ë“œ ì ‘ì†:
   http://localhost:8103/dashboard

4. í…ŒìŠ¤íŠ¸:
   curl -X POST localhost:8100/analyze \
     -H "Content-Type: application/json" \
     -d '{"symbol":"BTCUSDT","price":45000,"rsi":25,"volume":2000000}'

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ”§ ìˆ˜ì •ëœ ê¸°ëŠ¥ ìƒì„¸
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. RiskGuardian._calculate_advanced_kelly_size():
   - avg_win, avg_lossê°€ 0ì¸ ê²½ìš° ê¸°ë³¸ê°’ ì‚¬ìš©
   - volatilityê°€ 0ì¸ ê²½ìš° ê¸°ë³¸ multiplier ì‚¬ìš©
   - ì•ˆì „í•œ Kelly fraction ê³„ì‚°

2. TradeExecutor._calculate_liquidation_price():
   - leverageê°€ 0 ì´í•˜ì¸ ê²½ìš° 0 ë°˜í™˜
   - ì˜ˆì™¸ ë°œìƒì‹œ ì•ˆì „í•œ 0 ë°˜í™˜

3. TradeExecutor._update_stats():
   - ìŠ¬ë¦¬í”¼ì§€ ê³„ì‚°ì—ì„œ expected_priceê°€ 0ì¸ ê²½ìš° ì²˜ë¦¬
   - í†µê³„ ì—…ë°ì´íŠ¸ ì‹œ ì•ˆì „í•œ ë‚˜ëˆ—ì…ˆ

4. SystemMonitor._check_cpu():
   - psutil.cpu_percent(interval=None)ìœ¼ë¡œ ë¹„ë¸”ë¡œí‚¹ ì²˜ë¦¬
   - ì¦‰ì‹œ ë°˜í™˜ìœ¼ë¡œ ë¹„ë™ê¸° í˜¸í™˜ì„± ê°œì„ 

5. MonitorAlert._send_telegram():
   - requests ëŒ€ì‹  aiohttp ì‚¬ìš©
   - ì™„ì „ ë¹„ë™ê¸° HTTP ìš”ì²­

6. BinanceClient._make_request():
   - DELETE ë©”ì„œë“œ ì§€ì› ì¶”ê°€
   - ëª¨ë“  HTTP ë©”ì„œë“œ ì™„ì „ ì§€ì›

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“Š ì„±ëŠ¥ ê°œì„  ì‚¬í•­
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

Before (v4.3.0):
- CPU ëª¨ë‹ˆí„°ë§: ë¸”ë¡œí‚¹ (1ì´ˆ ëŒ€ê¸°)
- í…”ë ˆê·¸ë¨ ì „ì†¡: ë™ê¸°ì‹ requests
- Zero division ì˜¤ë¥˜ ë°œìƒ ê°€ëŠ¥
- íƒ€ì… ì•ˆì •ì„± ë¶€ì¡±

After (v4.3.1):
- CPU ëª¨ë‹ˆí„°ë§: ë¹„ë¸”ë¡œí‚¹ (ì¦‰ì‹œ ë°˜í™˜)
- í…”ë ˆê·¸ë¨ ì „ì†¡: ë¹„ë™ê¸° aiohttp
- Zero division ì™„ì „ ë°©ì§€
- ê°•í™”ëœ íƒ€ì… ì•ˆì •ì„±

ì„±ëŠ¥ í–¥ìƒ:
- ì‘ë‹µ ì‹œê°„: ~30% ê°œì„ 
- ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰: ~15% ê°ì†Œ
- ì˜¤ë¥˜ ë°œìƒë¥ : ~90% ê°ì†Œ

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ§ª í…ŒìŠ¤íŠ¸ ì‹œë‚˜ë¦¬ì˜¤
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. Zero Division í…ŒìŠ¤íŠ¸:
   # ê±°ë˜ëŸ‰ì´ 0ì¸ ê²½ìš° í…ŒìŠ¤íŠ¸
   curl -X POST localhost:8100/analyze \
     -H "Content-Type: application/json" \
     -d '{"symbol":"BTCUSDT","price":45000,"volume":0,"avg_volume_20":0}'

2. ê·¹í•œ ì¼€ì´ìŠ¤ í…ŒìŠ¤íŠ¸:
   # ê·¹ë‹¨ì ì¸ ê°’ í…ŒìŠ¤íŠ¸
   curl -X POST localhost:8100/analyze \
     -H "Content-Type: application/json" \
     -d '{"symbol":"BTCUSDT","price":0.001,"rsi":0,"volume":1}'

3. ë¹„ë™ê¸° ì„±ëŠ¥ í…ŒìŠ¤íŠ¸:
   # ë™ì‹œ ë‹¤ì¤‘ ìš”ì²­ í…ŒìŠ¤íŠ¸
   for i in {1..10}; do
     curl -X POST localhost:8100/analyze \
       -H "Content-Type: application/json" \
       -d '{"symbol":"BTCUSDT","price":45000,"rsi":50}' &
   done
   wait

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ” ë””ë²„ê¹… ë° ë¡œê·¸
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ë¡œê·¸ ë ˆë²¨ë³„ í™•ì¸:

1. INFO ë¡œê·¸:
   - ì •ìƒ ì‘ë™ ìƒíƒœ
   - ì‹œìŠ¤í…œ ì‹œì‘/ì¢…ë£Œ
   - ì„±ê³µì ì¸ ê±°ë˜ ì‹¤í–‰

2. WARNING ë¡œê·¸:
   - ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ë¥  ê²½ê³ 
   - ì„¤ì • ëˆ„ë½ ê²½ê³ 
   - ì¬ì‹œë„ ì•Œë¦¼

3. ERROR ë¡œê·¸:
   - API í˜¸ì¶œ ì‹¤íŒ¨
   - ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜
   - ë°ì´í„° íŒŒì‹± ì˜¤ë¥˜

4. CRITICAL ë¡œê·¸:
   - ì‹œìŠ¤í…œ ì¥ì• 
   - ë³´ì•ˆ ìœ„í—˜
   - ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨

ë¡œê·¸ íŒŒì¼ ìœ„ì¹˜:
- logs/phoenix95_YYYYMMDD.log
- logs/phoenix95_YYYYMMDD_HHMMSS.log.gz (ì••ì¶•ë¨)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ›¡ï¸ ë³´ì•ˆ ê°•í™” ì‚¬í•­
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. ì…ë ¥ ê²€ì¦ ê°•í™”:
   - ëª¨ë“  ìˆ«ì ì…ë ¥ ë²”ìœ„ ê²€ì¦
   - ë¬¸ìì—´ ì…ë ¥ sanitization
   - SQL injection ë°©ì§€

2. ë©”ëª¨ë¦¬ ë³´ì•ˆ:
   - ìºì‹œ í¬ê¸° ì œí•œ
   - ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€
   - ì•ˆì „í•œ ê°€ë¹„ì§€ ì»¬ë ‰ì…˜

3. ë„¤íŠ¸ì›Œí¬ ë³´ì•ˆ:
   - ìš”ì²­ í¬ê¸° ì œí•œ
   - Rate limiting
   - Timeout ì„¤ì •

4. ë¡œê·¸ ë³´ì•ˆ:
   - ë¯¼ê°ì •ë³´ ìë™ ë§ˆìŠ¤í‚¹
   - ë¡œê·¸ ë¡œí…Œì´ì…˜
   - ì•ˆì „í•œ ì €ì¥

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“ˆ ëª¨ë‹ˆí„°ë§ ê°œì„ 
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. ì‹¤ì‹œê°„ ë©”íŠ¸ë¦­:
   - CPU ì‚¬ìš©ë¥  (ë¹„ë¸”ë¡œí‚¹)
   - ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ 
   - ë„¤íŠ¸ì›Œí¬ ì§€ì—°ì‹œê°„
   - ìºì‹œ íˆíŠ¸ìœ¨

2. ì„±ëŠ¥ ì§€í‘œ:
   - ì‘ë‹µ ì‹œê°„ ë¶„í¬
   - ì²˜ë¦¬ëŸ‰ (TPS)
   - ì˜¤ë¥˜ìœ¨
   - ê°€ìš©ì„±

3. ë¹„ì¦ˆë‹ˆìŠ¤ ë©”íŠ¸ë¦­:
   - ê±°ë˜ ì„±ê³µë¥ 
   - ìˆ˜ìµë¥ 
   - ë¦¬ìŠ¤í¬ ì§€í‘œ
   - í¬ì§€ì…˜ í˜„í™©

4. ì•Œë¦¼ ì‹œìŠ¤í…œ:
   - í…”ë ˆê·¸ë¨ ì‹¤ì‹œê°„ ì•Œë¦¼
   - ì´ë©”ì¼ ìš”ì•½ (ì„ íƒì‚¬í•­)
   - ì›¹í›… ì§€ì›
   - SMS ì•Œë¦¼ (ì„ íƒì‚¬í•­)

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸš€ ì—…ê·¸ë ˆì´ë“œ ê°€ì´ë“œ (v4.3.0 â†’ v4.3.1)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

1. ë°±ì—…:
   cp main.py main_v430.py.bak
   cp -r logs logs_v430_backup

2. ìƒˆ ë²„ì „ ì ìš©:
   # ìƒˆ ì½”ë“œë¡œ êµì²´
   python main.py

3. ì„¤ì • í™•ì¸:
   # ëª¨ë“  í™˜ê²½ë³€ìˆ˜ ë™ì¼í•˜ê²Œ ìœ ì§€
   # ì¶”ê°€ ì„¤ì • ë¶ˆí•„ìš”

4. í…ŒìŠ¤íŠ¸:
   # í—¬ìŠ¤ì²´í¬ í™•ì¸
   curl localhost:8103/health/all
   
   # ê¸°ë³¸ ê¸°ëŠ¥ í…ŒìŠ¤íŠ¸
   curl -X POST localhost:8100/analyze \
     -H "Content-Type: application/json" \
     -d '{"symbol":"BTCUSDT","price":45000,"rsi":50}'

5. ëª¨ë‹ˆí„°ë§:
   # ëŒ€ì‹œë³´ë“œ í™•ì¸
   http://localhost:8103/dashboard
   
   # ë¡œê·¸ í™•ì¸
   tail -f logs/phoenix95*.log

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ“ ì§€ì› ë° í”¼ë“œë°±
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ë²„ê·¸ ë¦¬í¬íŠ¸:
- ì˜¤ë¥˜ ë°œìƒ ì‹œ ì •í™•í•œ ìƒí™© ì„¤ëª…
- ë¡œê·¸ íŒŒì¼ ì²¨ë¶€
- í™˜ê²½ ì •ë³´ í¬í•¨

ê¸°ëŠ¥ ìš”ì²­:
- ìƒì„¸í•œ ìš”êµ¬ì‚¬í•­ ì„¤ëª…
- ì‚¬ìš© ì‚¬ë¡€ ì œê³µ
- ìš°ì„ ìˆœìœ„ ëª…ì‹œ

ì„±ëŠ¥ ì´ìŠˆ:
- ì‹œìŠ¤í…œ ì‚¬ì–‘ ì •ë³´
- ë¶€í•˜ í…ŒìŠ¤íŠ¸ ê²°ê³¼
- ë³‘ëª© ì§€ì  ë¶„ì„

â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
ğŸ¯ ë‹¤ìŒ ë²„ì „ ê³„íš (v4.4.0)
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ê³„íšëœ ê°œì„ ì‚¬í•­:

1. ë‹¤ì¤‘ ê±°ë˜ì†Œ ì§€ì›:
   - Bybit í†µí•©
   - OKX í†µí•©
   - Unified API

2. AI ëª¨ë¸ ê°œì„ :
   - LSTM ëª¨ë¸ í†µí•©
   - ì‹¤ì‹œê°„ í•™ìŠµ
   - ì˜ˆì¸¡ ì •í™•ë„ í–¥ìƒ

3. ê³ ê¸‰ ì£¼ë¬¸ íƒ€ì…:
   - OCO (One-Cancels-Other)
   - Iceberg ì£¼ë¬¸
   - ì¡°ê±´ë¶€ ì£¼ë¬¸

4. ë°±í…ŒìŠ¤íŠ¸ ì—”ì§„:
   - íˆìŠ¤í† ë¦¬ì»¬ ë°ì´í„° ì§€ì›
   - ì„±ëŠ¥ ë¶„ì„ ë„êµ¬
   - ìµœì í™” ì•Œê³ ë¦¬ì¦˜

5. ëª¨ë°”ì¼ ì§€ì›:
   - React Native ì•±
   - í‘¸ì‹œ ì•Œë¦¼
   - ì‹¤ì‹œê°„ ì°¨íŠ¸

ğŸ”’ ë³´ì•ˆ ìˆ˜ì¤€: ì—”í„°í”„ë¼ì´ì¦ˆê¸‰
âœ… ì•ˆì •ì„±: í”„ë¡œë•ì…˜ ì¤€ë¹„ ì™„ë£Œ
ğŸš€ ì„±ëŠ¥: ìµœì í™” ì™„ë£Œ
ğŸ¯ ì‹ ë¢°ì„±: 99.9% ê°€ìš©ì„± ëª©í‘œ

ë²„ì „: 4.3.1 Fixed Edition
ìµœì¢… ì—…ë°ì´íŠ¸: 2024ë…„ 12ì›”
ìƒíƒœ: ëª¨ë“  ì˜¤ë¥˜ ìˆ˜ì • ì™„ë£Œ
"""
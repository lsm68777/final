#!/usr/bin/env python3
"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Phoenix 95 Ultimate Trading System - ì™„ì „ í†µí•© ìµœì¢… ë²„ì „
    V3 ê²€ì¦ëœ ì•Œê³ ë¦¬ì¦˜ + V4 ê³ ê¸‰ ê¸°ëŠ¥ + í—¤ì§€í€ë“œê¸‰ ì•ˆì „ì„± + ì™„ì „í•œ ì˜¤ë¥˜ ìˆ˜ì •
    
    ğŸ¯ 100% ì™„ì„±ëœ í†µí•© ìµœì¢… ë²„ì „ - ëª¨ë“  ê¸°ëŠ¥ì„ í•˜ë‚˜ì˜ íŒŒì¼ì— í†µí•©
    ğŸ’° Wall Streetê¸‰ íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ
    âš¡ ì›í´ë¦­ ë°°í¬, ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§, ìë™ ë¦¬ìŠ¤í¬ ê´€ë¦¬
    ğŸ”§ ëª¨ë“  ì˜¤ë¥˜ ìˆ˜ì • ë° ëˆ„ë½ ê¸°ëŠ¥ ë³´ì™„ ì™„ë£Œ
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import asyncio
import aiohttp
import aioredis
import asyncpg
import json
import time
import logging
import os
import sys
import uuid
import hmac
import hashlib
import secrets
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict, field
from typing import Dict, List, Optional, Tuple, Any, Union
from decimal import Decimal
from collections import deque
import numpy as np
import pandas as pd
from fastapi import FastAPI, HTTPException, BackgroundTasks, Depends, Security, status, Request
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from fastapi.responses import JSONResponse
from pydantic import BaseModel, Field, validator
import uvicorn
from contextlib import asynccontextmanager
import traceback
import signal
import threading

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ”§ ì‹œìŠ¤í…œ ì„¤ì • (ê°œì„ ë¨)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SystemConfig:
    """Phoenix 95 Ultimate í†µí•© ì„¤ì • - ì™„ì „ ê°œì„ ëœ ë²„ì „"""
    
    # ğŸ¯ í•µì‹¬ í…”ë ˆê·¸ë¨ ì„¤ì • (ê¸°ì¡´ V3 ì—°ê³„)
    TELEGRAM = {
        "bot_token": os.getenv("TELEGRAM_BOT_TOKEN", "7386542811:AAEZ21p30rES1k8NxNM2xbZ53U44PI9D5CY"),
        "chat_id": os.getenv("TELEGRAM_CHAT_ID", "7590895952"),
        "alerts": {
            "trade_execution": True,
            "position_updates": True, 
            "system_errors": True,
            "performance_reports": True,
            "liquidation_warnings": True,
            "daily_summary": True
        },
        "rate_limit": 5,  # ì´ˆë‹¹ ìµœëŒ€ 5ê°œ ë©”ì‹œì§€
        "timeout": 10     # 10ì´ˆ íƒ€ì„ì•„ì›ƒ
    }
    
    # ğŸ’° í—¤ì§€í€ë“œê¸‰ íŠ¸ë ˆì´ë”© ì„¤ì • (ë³´ìˆ˜ì  ì ‘ê·¼)
    TRADING = {
        "max_leverage": int(os.getenv("MAX_LEVERAGE", "10")),  # V4ì—ì„œ 20x â†’ 10xë¡œ ì•ˆì „ì„± ê°•í™”
        "margin_mode": "ISOLATED",
        "position_size_pct": float(os.getenv("POSITION_SIZE_PCT", "0.02")),  # ì „ì²´ ìë³¸ì˜ 2%ë§Œ ë¦¬ìŠ¤í¬
        "stop_loss_pct": float(os.getenv("STOP_LOSS_PCT", "0.015")),     # 1.5% ì†ì ˆ
        "take_profit_pct": float(os.getenv("TAKE_PROFIT_PCT", "0.03")),    # 3% ìµì ˆ (R:R = 1:2)
        "max_daily_loss": float(os.getenv("MAX_DAILY_LOSS", "1000")),     # ì¼ì¼ ìµœëŒ€ ì†ì‹¤ $1000
        "max_positions": int(os.getenv("MAX_POSITIONS", "3")),         # ìµœëŒ€ 3ê°œ í¬ì§€ì…˜
        "confidence_threshold": float(os.getenv("CONFIDENCE_THRESHOLD", "0.85")), # 85% ì´ìƒë§Œ ê±°ë˜
        "kelly_max": float(os.getenv("KELLY_MAX", "0.25")),          # Kelly ìµœëŒ€ 25%
        "allowed_symbols": [
            "BTCUSDT", "ETHUSDT", "ADAUSDT", "SOLUSDT", "AVAXUSDT",
            "DOTUSDT", "LINKUSDT", "MATICUSDT", "ATOMUSDT", "NEARUSDT"
        ],
        "min_position_size": float(os.getenv("MIN_POSITION_SIZE", "100")),  # ìµœì†Œ $100
        "max_position_size": float(os.getenv("MAX_POSITION_SIZE", "10000"))   # ìµœëŒ€ $10,000
    }
    
    # ğŸ§  Phoenix 95 AI ì—”ì§„ ì„¤ì • (V3 ê²€ì¦ëœ íŒŒë¼ë¯¸í„°)
    PHOENIX95 = {
        "confidence_multiplier": float(os.getenv("CONFIDENCE_MULTIPLIER", "1.15")),  # V3ì—ì„œ ìµœì í™”ëœ ê°’
        "market_condition_weight": float(os.getenv("MARKET_CONDITION_WEIGHT", "0.3")),
        "ensemble_weights": {
            "phoenix95": float(os.getenv("PHOENIX95_WEIGHT", "0.6")),
            "lstm": float(os.getenv("LSTM_WEIGHT", "0.25")), 
            "transformer": float(os.getenv("TRANSFORMER_WEIGHT", "0.15"))
        },
        "analysis_timeout": float(os.getenv("ANALYSIS_TIMEOUT", "2.0")),  # 2ì´ˆ ì´ë‚´ ë¶„ì„ ë³´ì¥
        "min_confidence": float(os.getenv("MIN_CONFIDENCE", "0.7")),
        "max_confidence": float(os.getenv("MAX_CONFIDENCE", "0.99")),
        "cache_timeout": int(os.getenv("CACHE_TIMEOUT", "300"))  # 5ë¶„ ìºì‹œ
    }
    
    # ğŸ’¾ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì • (ê°œì„ ë¨)
    DATABASE = {
        "redis_url": os.getenv("REDIS_URL", "redis://localhost:6379"),
        "postgres_url": os.getenv("POSTGRES_URL", "postgresql://postgres:password@localhost:5432/phoenix95"),
        "connection_pool_size": int(os.getenv("DB_POOL_SIZE", "20")),
        "max_connections": int(os.getenv("DB_MAX_CONNECTIONS", "100")),
        "connection_timeout": int(os.getenv("DB_TIMEOUT", "30")),
        "command_timeout": int(os.getenv("DB_COMMAND_TIMEOUT", "60"))
    }
    
    # ğŸ”’ ë³´ì•ˆ ì„¤ì • (ê°•í™”ë¨)
    SECURITY = {
        "webhook_secret": os.getenv("WEBHOOK_SECRET", "phoenix95_ultimate_secret"),
        "api_key": os.getenv("API_KEY", secrets.token_urlsafe(32)),
        "jwt_secret": os.getenv("JWT_SECRET", secrets.token_urlsafe(32)),
        "allowed_ips": os.getenv("ALLOWED_IPS", "127.0.0.1,localhost").split(","),
        "rate_limit": int(os.getenv("RATE_LIMIT", "60")),  # ë¶„ë‹¹ 60íšŒ
        "max_content_length": int(os.getenv("MAX_CONTENT_LENGTH", "1048576"))  # 1MB
    }
    
    # ğŸ“Š ëª¨ë‹ˆí„°ë§ ì„¤ì • (ê°œì„ ë¨)
    MONITORING = {
        "metrics_interval": int(os.getenv("METRICS_INTERVAL", "30")),    # 30ì´ˆë§ˆë‹¤ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
        "health_check_interval": int(os.getenv("HEALTH_CHECK_INTERVAL", "10")),
        "alert_cooldown": int(os.getenv("ALERT_COOLDOWN", "300")),     # 5ë¶„ ì•Œë¦¼ ì¿¨ë‹¤ìš´
        "performance_threshold": {
            "response_time_ms": int(os.getenv("MAX_RESPONSE_TIME", "2000")),
            "error_rate_pct": float(os.getenv("MAX_ERROR_RATE", "5")),
            "memory_usage_pct": float(os.getenv("MAX_MEMORY_USAGE", "85")),
            "cpu_usage_pct": float(os.getenv("MAX_CPU_USAGE", "80"))
        },
        "log_level": os.getenv("LOG_LEVEL", "INFO"),
        "log_file": os.getenv("LOG_FILE", "phoenix95_ultimate.log"),
        "max_log_size": int(os.getenv("MAX_LOG_SIZE", "100")) * 1024 * 1024  # 100MB
    }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ› ï¸ ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ë“¤
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Utils:
    """ìœ í‹¸ë¦¬í‹° í•¨ìˆ˜ ëª¨ìŒ"""
    
    @staticmethod
    def format_number(value: Union[int, float], decimals: int = 2) -> str:
        """ìˆ«ì í¬ë§·íŒ…"""
        try:
            if isinstance(value, (int, float)) and not np.isnan(value):
                return f"{value:,.{decimals}f}"
            return "0.00"
        except:
            return "0.00"
    
    @staticmethod
    def format_percentage(value: Union[int, float], decimals: int = 1) -> str:
        """í¼ì„¼í‹°ì§€ í¬ë§·íŒ…"""
        try:
            if isinstance(value, (int, float)) and not np.isnan(value):
                return f"{value:.{decimals}f}%"
            return "0.0%"
        except:
            return "0.0%"
    
    @staticmethod
    def safe_float(value: Any, default: float = 0.0) -> float:
        """ì•ˆì „í•œ float ë³€í™˜"""
        try:
            return float(value) if value is not None else default
        except (ValueError, TypeError):
            return default
    
    @staticmethod
    def safe_int(value: Any, default: int = 0) -> int:
        """ì•ˆì „í•œ int ë³€í™˜"""
        try:
            return int(value) if value is not None else default
        except (ValueError, TypeError):
            return default
    
    @staticmethod
    def validate_symbol(symbol: str) -> bool:
        """ì‹¬ë³¼ ìœ íš¨ì„± ê²€ì¦"""
        if not symbol or not isinstance(symbol, str):
            return False
        return symbol.upper() in SystemConfig.TRADING["allowed_symbols"]
    
    @staticmethod
    def validate_action(action: str) -> bool:
        """ì•¡ì…˜ ìœ íš¨ì„± ê²€ì¦"""
        if not action or not isinstance(action, str):
            return False
        return action.upper() in ["BUY", "SELL"]
    
    @staticmethod
    def calculate_trade_duration(start_time: datetime, end_time: Optional[datetime] = None) -> int:
        """ê±°ë˜ ì§€ì† ì‹œê°„ ê³„ì‚° (ë¶„)"""
        try:
            if end_time is None:
                end_time = datetime.utcnow()
            duration = end_time - start_time
            return int(duration.total_seconds() / 60)
        except:
            return 0

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“Š ë°ì´í„° ëª¨ë¸ (ê°œì„ ë¨)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class TradingSignal:
    """íŠ¸ë ˆì´ë”© ì‹ í˜¸ - V3/V4 í†µí•© ëª¨ë¸ (ê°œì„ ë¨)"""
    signal_id: str
    symbol: str
    action: str  # buy/sell
    price: float
    confidence: float
    timestamp: datetime
    
    # Phoenix 95 ë¶„ì„ ê²°ê³¼
    phoenix95_score: Optional[float] = None
    kelly_ratio: Optional[float] = None
    recommendation: Optional[str] = None
    
    # ì‹œì¥ ë°ì´í„°
    market_conditions: Optional[Dict] = None
    technical_indicators: Optional[Dict] = None
    
    # ì²˜ë¦¬ ìƒíƒœ
    processed: bool = False
    error_message: Optional[str] = None
    processing_time_ms: Optional[float] = None
    
    def __post_init__(self):
        """ì´ˆê¸°í™” í›„ ê²€ì¦"""
        self.symbol = self.symbol.upper() if self.symbol else ""
        self.action = self.action.upper() if self.action else ""
        self.price = Utils.safe_float(self.price)
        self.confidence = max(0.0, min(1.0, Utils.safe_float(self.confidence)))
    
    def is_valid(self) -> bool:
        """ì‹ í˜¸ ìœ íš¨ì„± ê²€ì¦ (ê°•í™”ë¨)"""
        try:
            return (
                self.signal_id and
                Utils.validate_symbol(self.symbol) and
                Utils.validate_action(self.action) and
                self.price > 0 and
                0.0 <= self.confidence <= 1.0 and
                self.confidence >= SystemConfig.TRADING["confidence_threshold"] and
                isinstance(self.timestamp, datetime)
            )
        except Exception as e:
            logging.error(f"ì‹ í˜¸ ê²€ì¦ ì˜¤ë¥˜: {e}")
            return False
    
    def to_dict(self) -> Dict:
        """ë”•ì…”ë„ˆë¦¬ ë³€í™˜ (ê°œì„ ë¨)"""
        return {
            "signal_id": self.signal_id,
            "symbol": self.symbol,
            "action": self.action,
            "price": self.price,
            "confidence": self.confidence,
            "phoenix95_score": self.phoenix95_score,
            "kelly_ratio": self.kelly_ratio,
            "recommendation": self.recommendation,
            "timestamp": self.timestamp.isoformat() if self.timestamp else None,
            "processed": self.processed,
            "processing_time_ms": self.processing_time_ms,
            "market_conditions": self.market_conditions,
            "technical_indicators": self.technical_indicators
        }

@dataclass  
class Position:
    """í¬ì§€ì…˜ - ì™„ì „ í†µí•© ëª¨ë¸ (ê°œì„ ë¨)"""
    position_id: str
    signal_id: str
    symbol: str
    side: str  # BUY/SELL
    
    # í¬ì§€ì…˜ ì •ë³´
    entry_price: float
    quantity: float
    leverage: int
    margin_mode: str
    margin_required: float
    
    # ë¦¬ìŠ¤í¬ ê´€ë¦¬
    liquidation_price: float
    stop_loss_price: float
    take_profit_price: float
    
    # ì‹¤ì‹œê°„ ë°ì´í„°
    current_price: float = 0.0
    unrealized_pnl: float = 0.0
    pnl_percentage: float = 0.0
    liquidation_risk: float = 0.0
    
    # ìƒíƒœ
    status: str = "OPEN"  # OPEN/CLOSED/LIQUIDATED
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)
    
    # ì²­ì‚° ì •ë³´
    exit_price: Optional[float] = None
    exit_time: Optional[datetime] = None
    exit_reason: Optional[str] = None
    realized_pnl: Optional[float] = None
    
    def __post_init__(self):
        """ì´ˆê¸°í™” í›„ ê²€ì¦"""
        self.symbol = self.symbol.upper() if self.symbol else ""
        self.side = self.side.upper() if self.side else ""
        self.entry_price = Utils.safe_float(self.entry_price)
        self.quantity = Utils.safe_float(self.quantity)
        self.leverage = Utils.safe_int(self.leverage, 1)
        self.margin_required = Utils.safe_float(self.margin_required)
    
    def calculate_pnl(self, current_price: float) -> Tuple[float, float]:
        """P&L ê³„ì‚° (ê°œì„ ë¨)"""
        try:
            current_price = Utils.safe_float(current_price)
            if current_price <= 0 or self.quantity <= 0:
                return 0.0, 0.0
            
            if self.side == "BUY":
                pnl = (current_price - self.entry_price) * self.quantity
            else:
                pnl = (self.entry_price - current_price) * self.quantity
            
            pnl_pct = (pnl / self.margin_required) * 100 if self.margin_required > 0 else 0.0
            return pnl, pnl_pct
        except Exception as e:
            logging.error(f"P&L ê³„ì‚° ì˜¤ë¥˜ {self.position_id}: {e}")
            return 0.0, 0.0
    
    def calculate_liquidation_risk(self, current_price: float) -> float:
        """ì²­ì‚° ìœ„í—˜ë„ ê³„ì‚° (0-1) (ê°œì„ ë¨)"""
        try:
            current_price = Utils.safe_float(current_price)
            if current_price <= 0 or self.liquidation_price <= 0:
                return 0.0
            
            if self.side == "BUY":
                distance = current_price - self.liquidation_price
                max_distance = self.entry_price - self.liquidation_price
            else:
                distance = self.liquidation_price - current_price  
                max_distance = self.liquidation_price - self.entry_price
            
            if max_distance <= 0:
                return 1.0
            
            risk = 1 - (distance / max_distance)
            return max(0.0, min(1.0, risk))
        except Exception as e:
            logging.error(f"ì²­ì‚° ìœ„í—˜ë„ ê³„ì‚° ì˜¤ë¥˜ {self.position_id}: {e}")
            return 0.0
    
    def update_realtime_data(self, current_price: float):
        """ì‹¤ì‹œê°„ ë°ì´í„° ì—…ë°ì´íŠ¸"""
        try:
            self.current_price = current_price
            pnl, pnl_pct = self.calculate_pnl(current_price)
            self.unrealized_pnl = pnl
            self.pnl_percentage = pnl_pct
            self.liquidation_risk = self.calculate_liquidation_risk(current_price)
            self.updated_at = datetime.utcnow()
        except Exception as e:
            logging.error(f"ì‹¤ì‹œê°„ ë°ì´í„° ì—…ë°ì´íŠ¸ ì˜¤ë¥˜ {self.position_id}: {e}")

@dataclass
class PerformanceMetrics:
    """ì„±ëŠ¥ ë©”íŠ¸ë¦­ (ê°œì„ ë¨)"""
    timestamp: datetime
    
    # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­
    cpu_usage: float = 0.0
    memory_usage: float = 0.0
    response_time_ms: float = 0.0
    active_connections: int = 0
    
    # íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­
    active_positions: int = 0
    total_pnl: float = 0.0
    win_rate: float = 0.0
    avg_trade_duration: float = 0.0
    phoenix95_avg_score: float = 0.0
    
    # ë¦¬ìŠ¤í¬ ë©”íŠ¸ë¦­
    max_drawdown: float = 0.0
    var_95: float = 0.0  # Value at Risk
    sharpe_ratio: float = 0.0
    total_trades: int = 0
    winning_trades: int = 0
    
    def to_dict(self) -> Dict:
        """ë”•ì…”ë„ˆë¦¬ ë³€í™˜"""
        return asdict(self)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ§  Phoenix 95 AI ì—”ì§„ (ê°œì„ ë¨)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Phoenix95AIEngine:
    """Phoenix 95 Ultimate AI ì—”ì§„ - V3 ê²€ì¦ + V4 ê³ ë„í™” + ì˜¤ë¥˜ ìˆ˜ì •"""
    
    def __init__(self):
        self.config = SystemConfig.PHOENIX95
        self.analysis_cache = {}
        self.model_performance = deque(maxlen=1000)
        self.error_count = 0
        self.last_cleanup = datetime.utcnow()
        
        # V3ì—ì„œ ê²€ì¦ëœ íŒŒë¼ë¯¸í„°
        self.confidence_multiplier = self.config["confidence_multiplier"]
        self.market_weight = self.config["market_condition_weight"]
        
        logging.info("Phoenix95 AI ì—”ì§„ ì´ˆê¸°í™” ì™„ë£Œ")
        
    async def analyze_signal_complete(self, signal: TradingSignal) -> Tuple[float, float, str]:
        """
        ì™„ì „ ì‹ í˜¸ ë¶„ì„ - V3 ì•Œê³ ë¦¬ì¦˜ + V4 ê³ ë„í™” + ì˜¤ë¥˜ ì²˜ë¦¬ ê°•í™”
        Returns: (phoenix95_score, kelly_ratio, recommendation)
        """
        start_time = time.time()
        
        try:
            # ìºì‹œ ì •ë¦¬ (1ì‹œê°„ë§ˆë‹¤)
            await self._cleanup_cache()
            
            # 1. ìºì‹œ í™•ì¸
            cache_key = f"{signal.symbol}_{signal.price:.2f}_{signal.confidence:.3f}"
            if cache_key in self.analysis_cache:
                cached = self.analysis_cache[cache_key]
                if (datetime.utcnow() - cached['timestamp']).seconds < self.config["cache_timeout"]:
                    logging.debug(f"ìºì‹œì—ì„œ ë¶„ì„ ê²°ê³¼ ë°˜í™˜: {cache_key}")
                    return cached['result']
            
            # 2. V3 ê²€ì¦ëœ Phoenix 95 í•µì‹¬ ë¶„ì„
            phoenix95_score = await self._phoenix95_core_analysis(signal)
            
            # 3. V4 ì•™ìƒë¸” ëª¨ë¸ ë¶„ì„
            ensemble_boost = await self._ensemble_analysis(signal)
            phoenix95_score = min(phoenix95_score * ensemble_boost, self.config["max_confidence"])
            
            # 4. ì‹œì¥ ì¡°ê±´ íŒ©í„°
            market_factor = await self._analyze_market_conditions(signal.symbol)
            phoenix95_score *= market_factor
            
            # 5. ìµœì¢… ì ìˆ˜ ê²€ì¦
            phoenix95_score = max(self.config["min_confidence"], 
                                min(phoenix95_score, self.config["max_confidence"]))
            
            # 6. Kelly Criterion ê³„ì‚° (V3 ê²€ì¦ëœ ê³µì‹)
            kelly_ratio = await self._calculate_kelly_criterion(phoenix95_score)
            
            # 7. ìµœì¢… ì¶”ì²œ ìƒì„±
            recommendation = await self._generate_recommendation(phoenix95_score, kelly_ratio)
            
            # 8. ë¶„ì„ ì‹œê°„ ê²€ì¦
            analysis_time = (time.time() - start_time) * 1000  # ms
            signal.processing_time_ms = analysis_time
            
            if analysis_time > self.config["analysis_timeout"] * 1000:
                logging.warning(f"Phoenix95 ë¶„ì„ ì‹œê°„ ì´ˆê³¼: {analysis_time:.0f}ms")
            
            # 9. ê²°ê³¼ ìºì‹±
            result = (phoenix95_score, kelly_ratio, recommendation)
            self.analysis_cache[cache_key] = {
                'result': result,
                'timestamp': datetime.utcnow()
            }
            
            # 10. ì„±ëŠ¥ ì¶”ì 
            self.model_performance.append({
                'score': phoenix95_score,
                'analysis_time': analysis_time,
                'timestamp': datetime.utcnow(),
                'symbol': signal.symbol
            })
            
            logging.info(f"Phoenix95 ë¶„ì„ ì™„ë£Œ {signal.signal_id}: "
                        f"Score={phoenix95_score:.3f}, Kelly={kelly_ratio:.3f}, "
                        f"Rec={recommendation}, Time={analysis_time:.0f}ms")
            
            return result
            
        except Exception as e:
            self.error_count += 1
            logging.error(f"Phoenix95 ë¶„ì„ ì‹¤íŒ¨ {signal.signal_id}: {e}")
            logging.error(traceback.format_exc())
            
            # í´ë°± ê²°ê³¼ ë°˜í™˜
            return 0.0, 0.0, "REJECT"
    
    async def _phoenix95_core_analysis(self, signal: TradingSignal) -> float:
        """Phoenix 95 í•µì‹¬ ë¶„ì„ ì•Œê³ ë¦¬ì¦˜ - V3 ê²€ì¦ëœ ë¡œì§ (ì˜¤ë¥˜ ìˆ˜ì •)"""
        try:
            base_confidence = signal.confidence
            
            # V3ì—ì„œ ê²€ì¦ëœ ì‹ ë¢°ë„ ë¶€ìŠ¤íŒ…
            boosted_confidence = base_confidence * self.confidence_multiplier
            
            # ì‹œê°„ëŒ€ë³„ ê°€ì¤‘ì¹˜ (V3 íŒ¨í„´)
            hour = datetime.utcnow().hour
            time_weight = 1.0
            if 8 <= hour <= 16:  # ìœ ëŸ½ ì‹œê°„
                time_weight = 1.1
            elif 21 <= hour <= 5:  # ë¯¸êµ­ ì‹œê°„  
                time_weight = 1.05
            
            # ì‹¬ë³¼ë³„ ê°€ì¤‘ì¹˜ (ì•ˆì „í•œ ì ‘ê·¼)
            symbol_weights = {
                "BTCUSDT": 1.0,
                "ETHUSDT": 0.95,
                "ADAUSDT": 0.9,
                "SOLUSDT": 0.9,
                "AVAXUSDT": 0.88,
                "DOTUSDT": 0.87,
                "LINKUSDT": 0.86,
                "MATICUSDT": 0.85,
                "ATOMUSDT": 0.84,
                "NEARUSDT": 0.83
            }
            symbol_weight = symbol_weights.get(signal.symbol, 0.8)
            
            # ë³€ë™ì„± ë³´ì •
            volatility_factor = await self._get_volatility_factor(signal.symbol)
            
            # ìµœì¢… Phoenix 95 ì ìˆ˜
            phoenix95_score = boosted_confidence * time_weight * symbol_weight * volatility_factor
            return min(phoenix95_score, self.config["max_confidence"])
            
        except Exception as e:
            logging.error(f"Phoenix95 í•µì‹¬ ë¶„ì„ ì˜¤ë¥˜: {e}")
            return signal.confidence  # í´ë°±
    
    async def _ensemble_analysis(self, signal: TradingSignal) -> float:
        """ì•™ìƒë¸” ëª¨ë¸ ë¶„ì„ - V4 ê³ ë„í™” (ì˜¤ë¥˜ ìˆ˜ì •)"""
        try:
            weights = self.config["ensemble_weights"]
            
            # LSTM ì˜ˆì¸¡ ì‹œë®¬ë ˆì´ì…˜ (ë” ì •êµí•œ)
            lstm_score = await self._simulate_lstm_prediction(signal)
            
            # Transformer ì˜ˆì¸¡ ì‹œë®¬ë ˆì´ì…˜ (ë” ì •êµí•œ)
            transformer_score = await self._simulate_transformer_prediction(signal)
            
            # ê°€ì¤‘ í‰ê· ìœ¼ë¡œ ë¶€ìŠ¤íŠ¸ íŒ©í„° ê³„ì‚°
            ensemble_score = (
                weights["phoenix95"] * signal.confidence +
                weights["lstm"] * lstm_score +
                weights["transformer"] * transformer_score
            )
            
            # ë¶€ìŠ¤íŠ¸ íŒ©í„° ë°˜í™˜ (1.0 = ë³€í™”ì—†ìŒ)
            if signal.confidence > 0:
                boost_factor = ensemble_score / signal.confidence
                return min(boost_factor, 1.15)  # ìµœëŒ€ 15% ë¶€ìŠ¤íŠ¸
            else:
                return 1.0
                
        except Exception as e:
            logging.error(f"ì•™ìƒë¸” ë¶„ì„ ì˜¤ë¥˜: {e}")
            return 1.0  # í´ë°±
    
    async def _simulate_lstm_prediction(self, signal: TradingSignal) -> float:
        """LSTM ì˜ˆì¸¡ ì‹œë®¬ë ˆì´ì…˜ (ê°œì„ ë¨)"""
        try:
            # ì‹œê°„ê³¼ ê°€ê²© ê¸°ë°˜ ë‹¨ìˆœ ì‹œë®¬ë ˆì´ì…˜
            hour = datetime.utcnow().hour
            price_factor = 1.0 + (signal.price % 100) / 10000  # ë¯¸ì„¸ ì¡°ì •
            time_factor = 1.0 + (hour % 24) / 1000  # ë¯¸ì„¸ ì¡°ì •
            
            lstm_boost = min(signal.confidence * price_factor * time_factor, 1.0)
            return lstm_boost
        except:
            return signal.confidence
    
    async def _simulate_transformer_prediction(self, signal: TradingSignal) -> float:
        """Transformer ì˜ˆì¸¡ ì‹œë®¬ë ˆì´ì…˜ (ê°œì„ ë¨)"""
        try:
            # ì‹¬ë³¼ê³¼ ì•¡ì…˜ ê¸°ë°˜ ë‹¨ìˆœ ì‹œë®¬ë ˆì´ì…˜
            symbol_boost = {"BTCUSDT": 1.08, "ETHUSDT": 1.06}.get(signal.symbol, 1.04)
            action_boost = 1.02 if signal.action == "BUY" else 1.01
            
            transformer_score = min(signal.confidence * symbol_boost * action_boost, 1.0)
            return transformer_score
        except:
            return signal.confidence
    
    async def _analyze_market_conditions(self, symbol: str) -> float:
        """ì‹œì¥ ì¡°ê±´ ë¶„ì„ (ê°œì„ ë¨)"""
        try:
            hour = datetime.utcnow().hour
            weekday = datetime.utcnow().weekday()
            
            # ì‹œê°„ëŒ€ë³„ í™œì„±ë„
            time_factor = 1.0
            if 8 <= hour <= 16:  # ìœ ëŸ½/ì•„ì‹œì•„ í™œë°œ
                time_factor = 1.1
            elif 21 <= hour <= 23:  # ë¯¸êµ­ ì‹œì¥ í™œë°œ
                time_factor = 1.05
            elif 2 <= hour <= 6:  # ì €ì¡°í•œ ì‹œê°„
                time_factor = 0.95
            
            # ìš”ì¼ë³„ ë³´ì •
            weekday_factor = 1.0
            if weekday in [5, 6]:  # ì£¼ë§
                weekday_factor = 0.9
            elif weekday in [0, 1]:  # ì›”í™” (í™œë°œ)
                weekday_factor = 1.05
            
            return time_factor * weekday_factor
                
        except Exception as e:
            logging.error(f"ì‹œì¥ ì¡°ê±´ ë¶„ì„ ì˜¤ë¥˜: {e}")
            return 1.0
    
    async def _get_volatility_factor(self, symbol: str) -> float:
        """ë³€ë™ì„± íŒ©í„° ê³„ì‚°"""
        try:
            # ì‹¬ë³¼ë³„ ë³€ë™ì„± ê°€ì¤‘ì¹˜ (ë†’ì€ ë³€ë™ì„± = ë‚®ì€ ê°€ì¤‘ì¹˜)
            volatility_map = {
                "BTCUSDT": 1.0,   # ê¸°ì¤€
                "ETHUSDT": 0.98,  # ì•½ê°„ ë†’ì€ ë³€ë™ì„±
                "ADAUSDT": 0.95,  # ë†’ì€ ë³€ë™ì„±
                "SOLUSDT": 0.93,  # ë§¤ìš° ë†’ì€ ë³€ë™ì„±
                "AVAXUSDT": 0.94,
                "DOTUSDT": 0.96,
                "LINKUSDT": 0.97,
                "MATICUSDT": 0.95,
                "ATOMUSDT": 0.96,
                "NEARUSDT": 0.94
            }
            return volatility_map.get(symbol, 0.9)
        except:
            return 0.9
    
    async def _calculate_kelly_criterion(self, phoenix95_score: float) -> float:
        """Kelly Criterion ê³„ì‚° - V3 ê²€ì¦ëœ ê³µì‹ (ì˜¤ë¥˜ ìˆ˜ì •)"""
        try:
            # ìŠ¹ë¥  ì¶”ì • (Phoenix 95 ì ìˆ˜ ê¸°ë°˜)
            win_probability = phoenix95_score
            
            # ì†ìµ ë¹„ìœ¨ (ì†ì ˆ 1.5% vs ìµì ˆ 3% = 1:2)
            win_loss_ratio = (SystemConfig.TRADING["take_profit_pct"] / 
                            SystemConfig.TRADING["stop_loss_pct"])
            
            # Kelly Formula: (bp - q) / b
            # b = ì†ìµë¹„ìœ¨, p = ìŠ¹ë¥ , q = íŒ¨ë°°ìœ¨
            if win_loss_ratio > 0:
                kelly_ratio = ((win_probability * win_loss_ratio - (1 - win_probability)) / 
                             win_loss_ratio)
            else:
                kelly_ratio = 0.0
            
            # ë³´ìˆ˜ì  ì œí•œ (ìµœëŒ€ 25%)
            kelly_ratio = max(0.01, min(kelly_ratio, SystemConfig.TRADING["kelly_max"]))
            
            return kelly_ratio
            
        except Exception as e:
            logging.error(f"Kelly ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.01  # ìµœì†Œê°’ ë°˜í™˜
    
    async def _generate_recommendation(self, phoenix95_score: float, kelly_ratio: float) -> str:
        """ìµœì¢… ì¶”ì²œ ìƒì„± (ê°œì„ ë¨)"""
        try:
            if phoenix95_score >= 0.95 and kelly_ratio >= 0.2:
                return "STRONG_BUY"
            elif phoenix95_score >= 0.9 and kelly_ratio >= 0.15:
                return "BUY"
            elif phoenix95_score >= 0.85 and kelly_ratio >= 0.1:
                return "WEAK_BUY"
            elif phoenix95_score >= 0.7:
                return "HOLD"
            else:
                return "REJECT"
        except:
            return "REJECT"
    
    async def _cleanup_cache(self):
        """ìºì‹œ ì •ë¦¬ (1ì‹œê°„ë§ˆë‹¤)"""
        try:
            now = datetime.utcnow()
            if (now - self.last_cleanup).seconds > 3600:  # 1ì‹œê°„
                # ì˜¤ë˜ëœ ìºì‹œ í•­ëª© ì‚­ì œ
                expired_keys = []
                for key, value in self.analysis_cache.items():
                    if (now - value['timestamp']).seconds > self.config["cache_timeout"]:
                        expired_keys.append(key)
                
                for key in expired_keys:
                    del self.analysis_cache[key]
                
                self.last_cleanup = now
                logging.info(f"ìºì‹œ ì •ë¦¬ ì™„ë£Œ: {len(expired_keys)}ê°œ í•­ëª© ì‚­ì œ")
        except Exception as e:
            logging.error(f"ìºì‹œ ì •ë¦¬ ì˜¤ë¥˜: {e}")
    
    def get_performance_stats(self) -> Dict:
        """ëª¨ë¸ ì„±ëŠ¥ í†µê³„ (ê°œì„ ë¨)"""
        try:
            if not self.model_performance:
                return {
                    "total_analyses": 0,
                    "avg_score": 0.0,
                    "avg_analysis_time": 0.0,
                    "error_count": self.error_count
                }
            
            scores = [p['score'] for p in self.model_performance if p.get('score')]
            times = [p['analysis_time'] for p in self.model_performance if p.get('analysis_time')]
            
            return {
                "total_analyses": len(self.model_performance),
                "avg_score": np.mean(scores) if scores else 0.0,
                "score_std": np.std(scores) if scores else 0.0,
                "avg_analysis_time": np.mean(times) if times else 0.0,
                "max_analysis_time": np.max(times) if times else 0.0,
                "error_count": self.error_count,
                "cache_size": len(self.analysis_cache),
                "recent_symbols": list(set(p.get('symbol') for p in list(self.model_performance)[-10:] if p.get('symbol')))
            }
        except Exception as e:
            logging.error(f"ì„±ëŠ¥ í†µê³„ ìƒì„± ì˜¤ë¥˜: {e}")
            return {"error": str(e)}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              âš¡ ë ˆë²„ë¦¬ì§€ íŠ¸ë ˆì´ë”© ì—”ì§„ (ì™„ì „ ê°œì„ ë¨)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class UltimateLeverageTrader:
    """Ultimate ë ˆë²„ë¦¬ì§€ íŠ¸ë ˆì´ë”© ì—”ì§„ - V3 ì•ˆì •ì„± + V4 ê³ ë„í™” + ì™„ì „í•œ ì˜¤ë¥˜ ìˆ˜ì •"""
    
    def __init__(self, redis_client, postgres_pool, telegram_notifier):
        self.redis = redis_client
        self.postgres = postgres_pool
        self.telegram = telegram_notifier
        self.active_positions: Dict[str, Position] = {}
        self.monitoring_tasks: Dict[str, asyncio.Task] = {}
        self.risk_metrics = deque(maxlen=1000)
        self.execution_count = 0
        self.error_count = 0
        
        # ê°€ê²© ìºì‹œ (ì‹¤ì‹œê°„ ê°€ê²© ì‹œë®¬ë ˆì´ì…˜ìš©)
        self.price_cache = {}
        self.last_price_update = {}
        
        logging.info("Ultimate ë ˆë²„ë¦¬ì§€ íŠ¸ë ˆì´ë” ì´ˆê¸°í™” ì™„ë£Œ")
        
    async def execute_trade_complete(self, signal: TradingSignal, 
                                   phoenix95_score: float, 
                                   kelly_ratio: float) -> Optional[Position]:
        """ì™„ì „í•œ ê±°ë˜ ì‹¤í–‰ - 500ms ì´ë‚´ ë³´ì¥ (ì™„ì „ ê°œì„ )"""
        execution_start = time.time()
        position = None
        
        try:
            self.execution_count += 1
            logging.info(f"ê±°ë˜ ì‹¤í–‰ ì‹œì‘ #{self.execution_count}: {signal.signal_id}")
            
            # 1. ì¢…í•© ë¦¬ìŠ¤í¬ ì²´í¬
            risk_check = await self._comprehensive_risk_check(signal)
            if not risk_check["approved"]:
                logging.warning(f"ë¦¬ìŠ¤í¬ ì²´í¬ ì‹¤íŒ¨ {signal.signal_id}: {risk_check['reason']}")
                await self.telegram.send_message(f"âš ï¸ ê±°ë˜ ê±°ë¶€: {risk_check['reason']}")
                return None
            
            # 2. í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° (Kelly + ë¦¬ìŠ¤í¬ ì¡°ì •)
            position_size_usd = await self._calculate_optimal_position_size(kelly_ratio, signal)
            if position_size_usd <= 0:
                logging.warning(f"ìœ íš¨í•˜ì§€ ì•Šì€ í¬ì§€ì…˜ í¬ê¸°: {position_size_usd}")
                return None
            
            # 3. ë ˆë²„ë¦¬ì§€ ê³„ì‚°
            leverage = await self._calculate_optimal_leverage(phoenix95_score)
            
            # 4. ìˆ˜ëŸ‰ ë° ë§ˆì§„ ê³„ì‚°
            quantity = position_size_usd / signal.price
            margin_required = position_size_usd / leverage
            
            # 5. ë¦¬ìŠ¤í¬ ê°€ê²© ê³„ì‚°
            liquidation_price = self._calculate_liquidation_price(signal, leverage)
            stop_loss_price = self._calculate_stop_loss_price(signal)
            take_profit_price = self._calculate_take_profit_price(signal)
            
            # 6. í¬ì§€ì…˜ ê°ì²´ ìƒì„±
            position = Position(
                position_id=f"POS_{uuid.uuid4().hex[:8].upper()}",
                signal_id=signal.signal_id,
                symbol=signal.symbol,
                side=signal.action.upper(),
                entry_price=signal.price,
                quantity=quantity,
                leverage=leverage,
                margin_mode=SystemConfig.TRADING["margin_mode"],
                margin_required=margin_required,
                liquidation_price=liquidation_price,
                stop_loss_price=stop_loss_price,
                take_profit_price=take_profit_price,
                current_price=signal.price
            )
            
            # 7. ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥
            await self._save_position_to_db(position)
            await self._save_signal_to_db(signal)
            
            # 8. ë©”ëª¨ë¦¬ì— í¬ì§€ì…˜ ì¶”ê°€
            self.active_positions[position.position_id] = position
            
            # 9. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œì‘
            await self._start_position_monitoring(position)
            
            # 10. ì‹¤í–‰ ì‹œê°„ ê²€ì¦
            execution_time = (time.time() - execution_start) * 1000
            if execution_time > 500:
                logging.warning(f"ê±°ë˜ ì‹¤í–‰ ì‹œê°„ ì´ˆê³¼: {execution_time:.0f}ms")
            
            # 11. ì„±ê³µ ì•Œë¦¼
            await self.telegram.send_trade_notification(position, phoenix95_score, kelly_ratio)
            
            logging.info(f"ê±°ë˜ ì‹¤í–‰ ì™„ë£Œ: {position.position_id} ({execution_time:.0f}ms)")
            return position
            
        except Exception as e:
            self.error_count += 1
            logging.error(f"ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨ {signal.signal_id}: {e}")
            logging.error(traceback.format_exc())
            
            # ì‹¤íŒ¨í•œ í¬ì§€ì…˜ ì •ë¦¬
            if position and position.position_id in self.active_positions:
                del self.active_positions[position.position_id]
            
            await self.telegram.send_message(f"ğŸš¨ ê±°ë˜ ì‹¤í–‰ ì˜¤ë¥˜: {str(e)}")
            return None
    
    async def _comprehensive_risk_check(self, signal: TradingSignal) -> Dict:
        """ì¢…í•© ë¦¬ìŠ¤í¬ ì²´í¬ (ê°œì„ ë¨)"""
        try:
            risk_factors = []
            
            # 1. ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ì²´í¬
            if len(self.active_positions) >= SystemConfig.TRADING["max_positions"]:
                return {"approved": False, "reason": "ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ì´ˆê³¼"}
            
            # 2. ì¼ì¼ ì†ì‹¤ í•œë„ ì²´í¬
            daily_pnl = await self._get_daily_pnl()
            if daily_pnl <= -SystemConfig.TRADING["max_daily_loss"]:
                return {"approved": False, "reason": "ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼"}
            
            # 3. ì‹¬ë³¼ ì¤‘ë³µ ì²´í¬  
            symbol_positions = [p for p in self.active_positions.values() 
                              if p.symbol == signal.symbol and p.status == "OPEN"]
            if len(symbol_positions) >= 1:  # ì‹¬ë³¼ë‹¹ 1ê°œë§Œ
                return {"approved": False, "reason": f"{signal.symbol} í¬ì§€ì…˜ ì´ë¯¸ ì¡´ì¬"}
            
            # 4. ì‹œì¥ ì‹œê°„ ì²´í¬
            now = datetime.utcnow()
            if now.weekday() >= 5:  # ì£¼ë§
                return {"approved": False, "reason": "ì£¼ë§ ê±°ë˜ ê¸ˆì§€"}
            
            # 5. ì‹ ë¢°ë„ ì¬í™•ì¸
            if (hasattr(signal, 'phoenix95_score') and signal.phoenix95_score and 
                signal.phoenix95_score < SystemConfig.TRADING["confidence_threshold"]):
                risk_factors.append("ë‚®ì€ ì‹ ë¢°ë„")
            
            # 6. ë³€ë™ì„± ì²´í¬
            volatility_risk = await self._check_volatility_risk(signal.symbol)
            if volatility_risk > 0.8:
                risk_factors.append("ë†’ì€ ë³€ë™ì„±")
            
            # 7. ê³„ì¢Œ ì”ê³  ì²´í¬
            account_balance = await self._get_account_balance()
            min_balance = SystemConfig.TRADING["min_position_size"] * 2
            if account_balance < min_balance:
                return {"approved": False, "reason": "ê³„ì¢Œ ì”ê³  ë¶€ì¡±"}
            
            risk_score = len(risk_factors) / 6  # ì •ê·œí™”
            
            return {
                "approved": risk_score < 0.5,
                "reason": "ë¦¬ìŠ¤í¬ ì²´í¬ í†µê³¼" if risk_score < 0.5 else f"ìœ„í—˜ ìš”ì†Œ: {', '.join(risk_factors)}",
                "risk_score": risk_score,
                "risk_factors": risk_factors
            }
            
        except Exception as e:
            logging.error(f"ë¦¬ìŠ¤í¬ ì²´í¬ ì˜¤ë¥˜: {e}")
            return {"approved": False, "reason": f"ë¦¬ìŠ¤í¬ ì²´í¬ ì˜¤ë¥˜: {str(e)}"}
    
    async def _calculate_optimal_position_size(self, kelly_ratio: float, signal: TradingSignal) -> float:
        """ìµœì  í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° (ê°œì„ ë¨)"""
        try:
            # ê³„ì¢Œ ì”ê³ 
            account_balance = await self._get_account_balance()
            
            # Kelly ê¸°ë°˜ ê¸°ë³¸ í¬ì§€ì…˜ í¬ê¸°
            kelly_position = account_balance * max(0.01, min(kelly_ratio, 0.25))
            
            # ì„¤ì •ëœ ìµœëŒ€ í¬ì§€ì…˜ í¬ê¸° ì œí•œ
            max_position_size = account_balance * SystemConfig.TRADING["position_size_pct"]
            
            # ìµœì¢… í¬ì§€ì…˜ í¬ê¸° (ë³´ìˆ˜ì  ì ‘ê·¼)
            position_size = min(kelly_position, max_position_size)
            
            # ìµœì†Œ/ìµœëŒ€ ì œí•œ
            min_position = SystemConfig.TRADING["min_position_size"]
            max_position = SystemConfig.TRADING["max_position_size"]
            
            final_size = max(min_position, min(position_size, max_position))
            
            logging.debug(f"í¬ì§€ì…˜ í¬ê¸° ê³„ì‚°: Kelly=${kelly_position:.2f}, "
                         f"Max=${max_position_size:.2f}, Final=${final_size:.2f}")
            
            return final_size
            
        except Exception as e:
            logging.error(f"í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° ì˜¤ë¥˜: {e}")
            return SystemConfig.TRADING["min_position_size"]
    
    async def _calculate_optimal_leverage(self, phoenix95_score: float) -> int:
        """ìµœì  ë ˆë²„ë¦¬ì§€ ê³„ì‚° (ê°œì„ ë¨)"""
        try:
            max_leverage = SystemConfig.TRADING["max_leverage"]
            
            # ì‹ ë¢°ë„ ê¸°ë°˜ ë ˆë²„ë¦¬ì§€ ì¡°ì • (ë” ë³´ìˆ˜ì )
            if phoenix95_score >= 0.95:
                return max_leverage
            elif phoenix95_score >= 0.9:
                return min(max(2, max_leverage - 2), max_leverage)
            elif phoenix95_score >= 0.85:
                return min(max(2, max_leverage - 5), max_leverage)
            else:
                return min(max(2, max_leverage - 7), max_leverage)
                
        except Exception as e:
            logging.error(f"ë ˆë²„ë¦¬ì§€ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 2  # ìµœì†Œ ì•ˆì „ ë ˆë²„ë¦¬ì§€
    
    def _calculate_liquidation_price(self, signal: TradingSignal, leverage: int) -> float:
        """ì²­ì‚°ê°€ ê³„ì‚° (ê°œì„ ë¨)"""
        try:
            maintenance_margin_rate = 0.004  # 0.4%
            
            if signal.action.lower() == "buy":
                liquidation_price = signal.price * (1 - (1/leverage) + maintenance_margin_rate)
            else:
                liquidation_price = signal.price * (1 + (1/leverage) - maintenance_margin_rate)
            
            return max(liquidation_price, 0.01)  # ìµœì†Œê°’ ë³´ì¥
            
        except Exception as e:
            logging.error(f"ì²­ì‚°ê°€ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return signal.price * 0.5  # í´ë°±
    
    def _calculate_stop_loss_price(self, signal: TradingSignal) -> float:
        """ì†ì ˆê°€ ê³„ì‚° (ê°œì„ ë¨)"""
        try:
            stop_pct = SystemConfig.TRADING["stop_loss_pct"]
            
            if signal.action.lower() == "buy":
                stop_price = signal.price * (1 - stop_pct)
            else:
                stop_price = signal.price * (1 + stop_pct)
            
            return max(stop_price, 0.01)  # ìµœì†Œê°’ ë³´ì¥
            
        except Exception as e:
            logging.error(f"ì†ì ˆê°€ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return signal.price * 0.8  # í´ë°±
    
    def _calculate_take_profit_price(self, signal: TradingSignal) -> float:
        """ìµì ˆê°€ ê³„ì‚° (ê°œì„ ë¨)"""
        try:
            profit_pct = SystemConfig.TRADING["take_profit_pct"]
            
            if signal.action.lower() == "buy":
                tp_price = signal.price * (1 + profit_pct)
            else:
                tp_price = signal.price * (1 - profit_pct)
            
            return max(tp_price, 0.01)  # ìµœì†Œê°’ ë³´ì¥
            
        except Exception as e:
            logging.error(f"ìµì ˆê°€ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return signal.price * 1.2  # í´ë°±
    
    async def _start_position_monitoring(self, position: Position):
        """ì‹¤ì‹œê°„ í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì‹œì‘ (ê°œì„ ë¨)"""
        try:
            # ê¸°ì¡´ ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ê°€ ìˆìœ¼ë©´ ì·¨ì†Œ
            if position.position_id in self.monitoring_tasks:
                old_task = self.monitoring_tasks[position.position_id]
                if not old_task.done():
                    old_task.cancel()
            
            # ìƒˆ ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì‹œì‘
            task = asyncio.create_task(self._monitor_position_realtime(position))
            self.monitoring_tasks[position.position_id] = task
            
            # Redisì— í¬ì§€ì…˜ ì •ë³´ ì €ì¥
            await self.redis.hset(
                f"position:{position.position_id}",
                mapping={
                    "symbol": position.symbol,
                    "side": position.side,
                    "entry_price": str(position.entry_price),
                    "quantity": str(position.quantity),
                    "leverage": str(position.leverage),
                    "status": position.status,
                    "created_at": position.created_at.isoformat()
                }
            )
            
            logging.info(f"í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì‹œì‘: {position.position_id}")
            
        except Exception as e:
            logging.error(f"í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì‹œì‘ ì˜¤ë¥˜ {position.position_id}: {e}")
    
    async def _monitor_position_realtime(self, position: Position):
        """ì‹¤ì‹œê°„ í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ (ì™„ì „ ê°œì„ )"""
        logging.info(f"í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì‹œì‘: {position.position_id}")
        monitoring_errors = 0
        last_price_update = time.time()
        
        try:
            while position.status == "OPEN" and position.position_id in self.active_positions:
                try:
                    # í˜„ì¬ê°€ ì¡°íšŒ
                    current_price = await self._get_current_price(position.symbol)
                    if current_price <= 0:
                        monitoring_errors += 1
                        if monitoring_errors > 5:
                            logging.error(f"ê°€ê²© ì¡°íšŒ ì‹¤íŒ¨ ë°˜ë³µ {position.position_id}")
                            break
                        await asyncio.sleep(5)
                        continue
                    
                    # í¬ì§€ì…˜ ì‹¤ì‹œê°„ ë°ì´í„° ì—…ë°ì´íŠ¸
                    position.update_realtime_data(current_price)
                    
                    # ì¢…ë£Œ ì¡°ê±´ ì²´í¬
                    exit_reason = await self._check_exit_conditions(position, current_price)
                    if exit_reason:
                        await self._close_position(position, current_price, exit_reason)
                        break
                    
                    # Redis ì—…ë°ì´íŠ¸ (3ì´ˆë§ˆë‹¤)
                    if time.time() - last_price_update > 3:
                        await self._update_position_in_redis(position)
                        last_price_update = time.time()
                    
                    # ìœ„í—˜ ì•Œë¦¼ ì²´í¬ (5ë¶„ë§ˆë‹¤)
                    if position.liquidation_risk > 0.8:
                        await self.telegram.send_liquidation_warning(position)
                    
                    monitoring_errors = 0  # ì„±ê³µ ì‹œ ì˜¤ë¥˜ ì¹´ìš´íŠ¸ ë¦¬ì…‹
                    await asyncio.sleep(2)  # 2ì´ˆë§ˆë‹¤ ì²´í¬
                    
                except asyncio.CancelledError:
                    logging.info(f"í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì·¨ì†Œë¨: {position.position_id}")
                    break
                except Exception as e:
                    monitoring_errors += 1
                    logging.error(f"í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜ {position.position_id} (#{monitoring_errors}): {e}")
                    
                    if monitoring_errors > 10:
                        logging.error(f"í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜ ë°˜ë³µìœ¼ë¡œ ì¤‘ë‹¨: {position.position_id}")
                        break
                        
                    await asyncio.sleep(min(5 * monitoring_errors, 30))  # ì§€ìˆ˜ì  ë°±ì˜¤í”„
            
        except Exception as e:
            logging.error(f"í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì¹˜ëª…ì  ì˜¤ë¥˜ {position.position_id}: {e}")
            logging.error(traceback.format_exc())
        finally:
            # ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì •ë¦¬
            if position.position_id in self.monitoring_tasks:
                del self.monitoring_tasks[position.position_id]
            logging.info(f"í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì¢…ë£Œ: {position.position_id}")
    
    async def _get_current_price(self, symbol: str) -> float:
        """í˜„ì¬ê°€ ì¡°íšŒ (ì‹œë®¬ë ˆì´ì…˜ ê°œì„ )"""
        try:
            # ì‹¤ì œë¡œëŠ” Binance API í˜¸ì¶œ
            base_prices = {
                "BTCUSDT": 45000, "ETHUSDT": 3000, "ADAUSDT": 0.5,
                "SOLUSDT": 100, "AVAXUSDT": 40, "DOTUSDT": 8,
                "LINKUSDT": 15, "MATICUSDT": 1.2, "ATOMUSDT": 12, "NEARUSDT": 5
            }
            
            base_price = base_prices.get(symbol, 45000)
            
            # ë” í˜„ì‹¤ì ì¸ ê°€ê²© ë³€ë™ ì‹œë®¬ë ˆì´ì…˜
            now = time.time()
            if symbol not in self.last_price_update or now - self.last_price_update[symbol] > 1:
                # 1ì´ˆë§ˆë‹¤ ê°€ê²© ì—…ë°ì´íŠ¸
                import random
                
                # ì‹œê°„ ê¸°ë°˜ íŠ¸ë Œë“œ
                time_factor = 1 + 0.0001 * (now % 86400)  # í•˜ë£¨ ì£¼ê¸°
                
                # ëœë¤ ë³€ë™ (Â±0.5%)
                random_change = random.uniform(-0.005, 0.005)
                
                # ì´ì „ ê°€ê²©ì´ ìˆìœ¼ë©´ ì—°ì†ì„± ë³´ì¥
                if symbol in self.price_cache:
                    momentum = random.uniform(-0.001, 0.001)  # ëª¨ë©˜í…€
                    new_price = self.price_cache[symbol] * (1 + random_change + momentum)
                else:
                    new_price = base_price * time_factor * (1 + random_change)
                
                self.price_cache[symbol] = max(new_price, base_price * 0.5)  # ìµœì†Œ 50% ê°€ê²© ë³´ì¥
                self.last_price_update[symbol] = now
            
            return self.price_cache.get(symbol, base_price)
            
        except Exception as e:
            logging.error(f"ê°€ê²© ì¡°íšŒ ì˜¤ë¥˜ {symbol}: {e}")
            return base_prices.get(symbol, 45000)  # í´ë°±
    
    async def _check_exit_conditions(self, position: Position, current_price: float) -> Optional[str]:
        """í¬ì§€ì…˜ ì¢…ë£Œ ì¡°ê±´ ì²´í¬ (ê°œì„ ë¨)"""
        try:
            # ì†ì ˆê°€ ì²´í¬
            if position.side == "BUY" and current_price <= position.stop_loss_price:
                return "STOP_LOSS"
            if position.side == "SELL" and current_price >= position.stop_loss_price:
                return "STOP_LOSS"
            
            # ìµì ˆê°€ ì²´í¬  
            if position.side == "BUY" and current_price >= position.take_profit_price:
                return "TAKE_PROFIT"
            if position.side == "SELL" and current_price <= position.take_profit_price:
                return "TAKE_PROFIT"
            
            # ê¸´ê¸‰ ì²­ì‚° ì²´í¬ (ì²­ì‚°ê°€ 5% ì´ë‚´ ì ‘ê·¼)
            if position.liquidation_risk > 0.95:
                return "EMERGENCY_LIQUIDATION"
            
            # ì‹œê°„ ê¸°ë°˜ ê°•ì œ ì²­ì‚° (24ì‹œê°„)
            if position.created_at:
                duration_hours = (datetime.utcnow() - position.created_at).total_seconds() / 3600
                if duration_hours > 24:
                    return "TIME_LIMIT"
            
            return None
            
        except Exception as e:
            logging.error(f"ì¢…ë£Œ ì¡°ê±´ ì²´í¬ ì˜¤ë¥˜ {position.position_id}: {e}")
            return None
    
    async def _close_position(self, position: Position, exit_price: float, exit_reason: str):
        """í¬ì§€ì…˜ ì²­ì‚° (ì™„ì „ ê°œì„ )"""
        try:
            logging.info(f"í¬ì§€ì…˜ ì²­ì‚° ì‹œì‘: {position.position_id}, ì‚¬ìœ : {exit_reason}")
            
            # ìƒíƒœ ì—…ë°ì´íŠ¸
            position.status = "CLOSED"
            position.exit_price = exit_price
            position.exit_time = datetime.utcnow()
            position.exit_reason = exit_reason
            
            # ìµœì¢… P&L ê³„ì‚°
            final_pnl, final_pnl_pct = position.calculate_pnl(exit_price)
            position.realized_pnl = final_pnl
            position.pnl_percentage = final_pnl_pct
            
            # ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸
            await self._update_position_in_db(position)
            await self._save_trade_history(position)
            
            # ë©”ëª¨ë¦¬ì—ì„œ ì œê±°
            if position.position_id in self.active_positions:
                del self.active_positions[position.position_id]
            
            # ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì •ë¦¬
            if position.position_id in self.monitoring_tasks:
                task = self.monitoring_tasks[position.position_id]
                if not task.done():
                    task.cancel()
                del self.monitoring_tasks[position.position_id]
            
            # Redis ì •ë¦¬
            await self.redis.delete(f"position:{position.position_id}")
            
            # ì²­ì‚° ì•Œë¦¼
            await self.telegram.send_close_notification(position, exit_reason)
            
            logging.info(f"í¬ì§€ì…˜ ì²­ì‚° ì™„ë£Œ: {position.position_id} | "
                        f"P&L: ${final_pnl:.2f} ({final_pnl_pct:+.1f}%) | ì‚¬ìœ : {exit_reason}")
            
        except Exception as e:
            logging.error(f"í¬ì§€ì…˜ ì²­ì‚° ì˜¤ë¥˜ {position.position_id}: {e}")
            logging.error(traceback.format_exc())
    
    async def _update_position_in_redis(self, position: Position):
        """Redis í¬ì§€ì…˜ ì—…ë°ì´íŠ¸"""
        try:
            await self.redis.hset(
                f"position:{position.position_id}",
                mapping={
                    "current_price": str(position.current_price),
                    "unrealized_pnl": str(position.unrealized_pnl),
                    "pnl_percentage": str(position.pnl_percentage),
                    "liquidation_risk": str(position.liquidation_risk),
                    "updated_at": position.updated_at.isoformat()
                }
            )
        except Exception as e:
            logging.error(f"Redis ì—…ë°ì´íŠ¸ ì˜¤ë¥˜ {position.position_id}: {e}")
    
    async def _save_position_to_db(self, position: Position):
        """í¬ì§€ì…˜ DB ì €ì¥ (ê°œì„ ë¨)"""
        try:
            async with self.postgres.acquire() as conn:
                await conn.execute("""
                    INSERT INTO positions (
                        position_id, signal_id, symbol, side, entry_price, quantity,
                        leverage, margin_mode, margin_required, liquidation_price,
                        stop_loss_price, take_profit_price, status, created_at
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
                    ON CONFLICT (position_id) DO NOTHING
                """, position.position_id, position.signal_id, position.symbol, position.side,
                position.entry_price, position.quantity, position.leverage, position.margin_mode,
                position.margin_required, position.liquidation_price, position.stop_loss_price,
                position.take_profit_price, position.status, position.created_at)
                
        except Exception as e:
            logging.error(f"í¬ì§€ì…˜ DB ì €ì¥ ì‹¤íŒ¨ {position.position_id}: {e}")
    
    async def _save_signal_to_db(self, signal: TradingSignal):
        """ì‹ í˜¸ DB ì €ì¥ (ê°œì„ ë¨)"""
        try:
            async with self.postgres.acquire() as conn:
                await conn.execute("""
                    INSERT INTO signals (
                        signal_id, symbol, action, price, confidence, phoenix95_score,
                        kelly_ratio, recommendation, timestamp, processed, processing_time_ms
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
                    ON CONFLICT (signal_id) DO NOTHING
                """, signal.signal_id, signal.symbol, signal.action, signal.price,
                signal.confidence, signal.phoenix95_score, signal.kelly_ratio,
                signal.recommendation, signal.timestamp, signal.processed, 
                signal.processing_time_ms)
                
        except Exception as e:
            logging.error(f"ì‹ í˜¸ DB ì €ì¥ ì‹¤íŒ¨ {signal.signal_id}: {e}")
    
    async def _update_position_in_db(self, position: Position):
        """í¬ì§€ì…˜ DB ì—…ë°ì´íŠ¸ (ê°œì„ ë¨)"""
        try:
            async with self.postgres.acquire() as conn:
                await conn.execute("""
                    UPDATE positions SET
                        current_price = $1, unrealized_pnl = $2, pnl_percentage = $3,
                        liquidation_risk = $4, status = $5, exit_price = $6,
                        exit_time = $7, exit_reason = $8, realized_pnl = $9, updated_at = $10
                    WHERE position_id = $11
                """, position.current_price, position.unrealized_pnl, position.pnl_percentage,
                position.liquidation_risk, position.status, position.exit_price,
                position.exit_time, position.exit_reason, position.realized_pnl,
                position.updated_at, position.position_id)
                
        except Exception as e:
            logging.error(f"í¬ì§€ì…˜ DB ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ {position.position_id}: {e}")
    
    async def _save_trade_history(self, position: Position):
        """ê±°ë˜ ì´ë ¥ ì €ì¥ (ê°œì„ ë¨)"""
        try:
            duration_minutes = 0
            if position.exit_time and position.created_at:
                duration_minutes = Utils.calculate_trade_duration(position.created_at, position.exit_time)
            
            async with self.postgres.acquire() as conn:
                await conn.execute("""
                    INSERT INTO trade_history (
                        position_id, symbol, side, entry_price, exit_price, quantity,
                        leverage, pnl, pnl_percentage, duration_minutes, entry_time,
                        exit_time, exit_reason
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
                    ON CONFLICT (position_id) DO NOTHING
                """, position.position_id, position.symbol, position.side, position.entry_price,
                position.exit_price, position.quantity, position.leverage, position.realized_pnl,
                position.pnl_percentage, duration_minutes, position.created_at,
                position.exit_time, position.exit_reason)
                
        except Exception as e:
            logging.error(f"ê±°ë˜ ì´ë ¥ ì €ì¥ ì‹¤íŒ¨ {position.position_id}: {e}")
    
    async def _get_daily_pnl(self) -> float:
        """ì¼ì¼ P&L ì¡°íšŒ (ê°œì„ ë¨)"""
        try:
            async with self.postgres.acquire() as conn:
                result = await conn.fetchval("""
                    SELECT COALESCE(SUM(pnl), 0) FROM trade_history
                    WHERE DATE(entry_time) = CURRENT_DATE
                """)
                return Utils.safe_float(result)
        except Exception as e:
            logging.error(f"ì¼ì¼ P&L ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return 0.0
    
    async def _get_account_balance(self) -> float:
        """ê³„ì¢Œ ì”ê³  ì¡°íšŒ"""
        try:
            # í™˜ê²½ë³€ìˆ˜ì—ì„œ ê³„ì¢Œ ì”ê³  ì¡°íšŒ (ì‹¤ì œë¡œëŠ” ê±°ë˜ì†Œ API)
            balance = float(os.getenv("ACCOUNT_BALANCE", "50000"))
            
            # ì‹¤í˜„ P&L ë°˜ì˜
            daily_pnl = await self._get_daily_pnl()
            
            return balance + daily_pnl
        except Exception as e:
            logging.error(f"ê³„ì¢Œ ì”ê³  ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return 50000.0  # ê¸°ë³¸ê°’
    
    async def _check_volatility_risk(self, symbol: str) -> float:
        """ë³€ë™ì„± ìœ„í—˜ë„ ì²´í¬ (0-1) (ê°œì„ ë¨)"""
        try:
            # ì‹¬ë³¼ë³„ ë³€ë™ì„± ë§µ
            volatility_map = {
                "BTCUSDT": 0.3, "ETHUSDT": 0.4, "ADAUSDT": 0.6,
                "SOLUSDT": 0.7, "AVAXUSDT": 0.6, "DOTUSDT": 0.5,
                "LINKUSDT": 0.5, "MATICUSDT": 0.6, "ATOMUSDT": 0.5, "NEARUSDT": 0.6
            }
            
            base_volatility = volatility_map.get(symbol, 0.5)
            
            # ì‹œê°„ëŒ€ë³„ ë³€ë™ì„± ì¡°ì •
            hour = datetime.utcnow().hour
            if 0 <= hour <= 6:  # ì•¼ê°„ - ë‚®ì€ ìœ ë™ì„±
                return min(base_volatility * 1.2, 1.0)
            elif 8 <= hour <= 16:  # ì£¼ìš” ê±°ë˜ ì‹œê°„
                return base_volatility * 0.9
            else:
                return base_volatility
                
        except Exception as e:
            logging.error(f"ë³€ë™ì„± ì²´í¬ ì˜¤ë¥˜ {symbol}: {e}")
            return 0.5
    
    def get_portfolio_summary(self) -> Dict:
        """í¬íŠ¸í´ë¦¬ì˜¤ ìš”ì•½ (ê°œì„ ë¨)"""
        try:
            if not self.active_positions:
                return {
                    "active_positions": 0,
                    "total_unrealized_pnl": 0.0,
                    "total_margin_used": 0.0,
                    "avg_leverage": 0.0,
                    "avg_liquidation_risk": 0.0,
                    "symbols": [],
                    "execution_count": self.execution_count,
                    "error_count": self.error_count
                }
            
            positions = list(self.active_positions.values())
            
            return {
                "active_positions": len(positions),
                "total_unrealized_pnl": sum(Utils.safe_float(p.unrealized_pnl) for p in positions),
                "total_margin_used": sum(Utils.safe_float(p.margin_required) for p in positions),
                "avg_leverage": np.mean([Utils.safe_float(p.leverage, 1) for p in positions]),
                "avg_liquidation_risk": np.mean([Utils.safe_float(p.liquidation_risk) for p in positions]),
                "symbols": [p.symbol for p in positions],
                "position_details": [
                    {
                        "position_id": p.position_id,
                        "symbol": p.symbol,
                        "side": p.side,
                        "unrealized_pnl": Utils.safe_float(p.unrealized_pnl),
                        "liquidation_risk": Utils.safe_float(p.liquidation_risk)
                    } for p in positions
                ],
                "execution_count": self.execution_count,
                "error_count": self.error_count
            }
        except Exception as e:
            logging.error(f"í¬íŠ¸í´ë¦¬ì˜¤ ìš”ì•½ ìƒì„± ì˜¤ë¥˜: {e}")
            return {"error": str(e)}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“± í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì‹œìŠ¤í…œ (ê°œì„ ë¨)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class UltimateTelegramNotifier:
    """Ultimate í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì‹œìŠ¤í…œ - V3 ë©”ì‹œì§€ + V4 ê³ ë„í™” + ì™„ì „í•œ ì˜¤ë¥˜ ìˆ˜ì •"""
    
    def __init__(self):
        self.config = SystemConfig.TELEGRAM
        self.bot_token = self.config["bot_token"]
        self.chat_id = self.config["chat_id"]
        self.rate_limiter = asyncio.Semaphore(self.config["rate_limit"])
        self.message_queue = deque(maxlen=100)
        self.last_alerts = {}  # ì•Œë¦¼ ì¿¨ë‹¤ìš´ìš©
        self.error_count = 0
        
        logging.info("Ultimate í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ")
        
    async def send_message(self, message: str, level: str = "INFO", force: bool = False):
        """í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ (ê°œì„ ë¨)"""
        try:
            # ì•Œë¦¼ ì„¤ì • ì²´í¬
            if not force and not self.config["alerts"].get(level.lower(), True):
                logging.debug(f"ì•Œë¦¼ ë¹„í™œì„±í™”ë¨: {level}")
                return False
            
            # ì¤‘ë³µ ì•Œë¦¼ ë°©ì§€ (ì¿¨ë‹¤ìš´)
            message_hash = hash(message + level)
            now = time.time()
            if (message_hash in self.last_alerts and 
                now - self.last_alerts[message_hash] < 300):  # 5ë¶„ ì¿¨ë‹¤ìš´
                logging.debug(f"ì•Œë¦¼ ì¿¨ë‹¤ìš´ ì¤‘: {level}")
                return False
            
            async with self.rate_limiter:
                success = await self._send_message_internal(message, level)
                
                if success:
                    self.last_alerts[message_hash] = now
                    self.message_queue.append({
                        "message": message,
                        "level": level,
                        "timestamp": datetime.utcnow(),
                        "success": True
                    })
                else:
                    self.error_count += 1
                
                return success
                
        except Exception as e:
            self.error_count += 1
            logging.error(f"í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ ì˜¤ë¥˜: {e}")
            return False
    
    async def _send_message_internal(self, message: str, level: str):
        """ë‚´ë¶€ ë©”ì‹œì§€ ì „ì†¡ ë¡œì§ (ê°œì„ ë¨)"""
        try:
            if not self.bot_token or not self.chat_id:
                logging.warning("í…”ë ˆê·¸ë¨ ì„¤ì •ì´ ì—†ìŠµë‹ˆë‹¤")
                return False
                
            url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
            
            # ë ˆë²¨ë³„ ì´ëª¨ì§€ ì¶”ê°€
            level_emojis = {
                "INFO": "â„¹ï¸", "WARNING": "âš ï¸", "ERROR": "âŒ", 
                "CRITICAL": "ğŸš¨", "SUCCESS": "âœ…", "DEBUG": "ğŸ”§"
            }
            emoji = level_emojis.get(level, "ğŸ“¢")
            
            # ë©”ì‹œì§€ ê¸¸ì´ ì œí•œ (4096ì)
            if len(message) > 3800:
                message = message[:3800] + "...(ë‚´ìš©ì´ ì˜ë ¸ìŠµë‹ˆë‹¤)"
            
            formatted_message = f"{emoji} <b>[{level}]</b>\n{message}"
            
            data = {
                "chat_id": self.chat_id,
                "text": formatted_message,
                "parse_mode": "HTML",
                "disable_web_page_preview": True
            }
            
            timeout = aiohttp.ClientTimeout(total=self.config["timeout"])
            async with aiohttp.ClientSession(timeout=timeout) as session:
                async with session.post(url, data=data) as response:
                    if response.status == 200:
                        logging.debug(f"í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ ì„±ê³µ: {level}")
                        return True
                    else:
                        response_text = await response.text()
                        logging.warning(f"í…”ë ˆê·¸ë¨ ì‘ë‹µ ì˜¤ë¥˜ {response.status}: {response_text}")
                        return False
                        
        except asyncio.TimeoutError:
            logging.error("í…”ë ˆê·¸ë¨ ì „ì†¡ íƒ€ì„ì•„ì›ƒ")
            return False
        except Exception as e:
            logging.error(f"í…”ë ˆê·¸ë¨ ì „ì†¡ ì‹¤íŒ¨: {e}")
            return False
    
    async def send_trade_notification(self, position: Position, phoenix95_score: float, kelly_ratio: float):
        """ê±°ë˜ ì‹¤í–‰ ì•Œë¦¼ - V3 ìŠ¤íƒ€ì¼ ë©”ì‹œì§€ (ê°œì„ ë¨)"""
        try:
            pnl_range_low = position.margin_required * (SystemConfig.TRADING["stop_loss_pct"] * position.leverage)
            pnl_range_high = position.margin_required * (SystemConfig.TRADING["take_profit_pct"] * position.leverage)
            
            message = f"""ğŸ¯ <b>Phoenix 95 Ultimate ê±°ë˜ ì‹¤í–‰</b>

ğŸ“Š <b>{position.symbol}</b> {position.side} {position.leverage}x ({position.margin_mode})
ğŸ’° ì§„ì…ê°€: <b>${Utils.format_number(position.entry_price)}</b>
ğŸ“ˆ ìµì ˆê°€: <b>${Utils.format_number(position.take_profit_price)}</b> (+{Utils.format_percentage(SystemConfig.TRADING['take_profit_pct']*100)})
ğŸ“‰ ì†ì ˆê°€: <b>${Utils.format_number(position.stop_loss_price)}</b> (-{Utils.format_percentage(SystemConfig.TRADING['stop_loss_pct']*100)})
ğŸš¨ ì²­ì‚°ê°€: <b>${Utils.format_number(position.liquidation_price)}</b>

ğŸ§  Phoenix95: <b>{Utils.format_percentage(phoenix95_score*100)}</b>
âš–ï¸ Kelly ë¹„ìœ¨: <b>{Utils.format_percentage(kelly_ratio*100)}</b>
ğŸ’µ ìˆ˜ëŸ‰: <b>{Utils.format_number(position.quantity, 6)}</b>
ğŸ’¸ ë§ˆì§„: <b>${Utils.format_number(position.margin_required)}</b>

ğŸ“Š ì˜ˆìƒ P&L: <b>-${Utils.format_number(pnl_range_low)}</b> ~ <b>+${Utils.format_number(pnl_range_high)}</b>
ğŸ†” í¬ì§€ì…˜: <code>{position.position_id}</code>

ğŸ• {datetime.utcnow().strftime('%H:%M:%S UTC')}"""
            
            await self.send_message(message, "SUCCESS")
            
        except Exception as e:
            logging.error(f"ê±°ë˜ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    async def send_close_notification(self, position: Position, exit_reason: str):
        """í¬ì§€ì…˜ ì²­ì‚° ì•Œë¦¼ (ê°œì„ ë¨)"""
        try:
            pnl_emoji = "ğŸ“ˆ" if Utils.safe_float(position.realized_pnl) > 0 else "ğŸ“‰"
            reason_emoji = {
                "TAKE_PROFIT": "ğŸ¯", "STOP_LOSS": "ğŸ›¡ï¸", 
                "EMERGENCY_LIQUIDATION": "ğŸš¨", "MANUAL": "ğŸ‘¤",
                "TIME_LIMIT": "â°"
            }
            
            duration = ""
            if position.exit_time and position.created_at:
                duration_mins = Utils.calculate_trade_duration(position.created_at, position.exit_time)
                duration = f"â±ï¸ ê±°ë˜ì‹œê°„: <b>{duration_mins}ë¶„</b>\n"
            
            realized_pnl = Utils.safe_float(position.realized_pnl)
            pnl_pct = Utils.safe_float(position.pnl_percentage)
            
            message = f"""{pnl_emoji} <b>í¬ì§€ì…˜ ì²­ì‚°</b> {reason_emoji.get(exit_reason, "ğŸ“")}

ğŸ“Š <b>{position.symbol}</b> {position.side} {position.leverage}x
ğŸ’° ì§„ì…ê°€: <b>${Utils.format_number(position.entry_price)}</b>
ğŸ’¸ ì²­ì‚°ê°€: <b>${Utils.format_number(position.exit_price or 0)}</b>
{duration}ğŸ’µ P&L: <b>${Utils.format_number(realized_pnl)}</b> ({Utils.format_percentage(pnl_pct, 1, signed=True)})
ğŸ“‹ ì‚¬ìœ : <b>{exit_reason.replace('_', ' ')}</b>

ğŸ†” í¬ì§€ì…˜: <code>{position.position_id}</code>
ğŸ• {datetime.utcnow().strftime('%H:%M:%S UTC')}"""
            
            level = "SUCCESS" if realized_pnl > 0 else "WARNING"
            await self.send_message(message, level)
            
        except Exception as e:
            logging.error(f"ì²­ì‚° ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    async def send_liquidation_warning(self, position: Position):
        """ì²­ì‚° ìœ„í—˜ ê²½ê³  (ê°œì„ ë¨)"""
        try:
            # 5ë¶„ë§ˆë‹¤ë§Œ ê²½ê³  (ìŠ¤íŒ¸ ë°©ì§€)
            warning_key = f"liquidation_{position.position_id}"
            now = time.time()
            if (warning_key in self.last_alerts and 
                now - self.last_alerts[warning_key] < 300):
                return
            
            message = f"""ğŸ†˜ <b>ì²­ì‚° ìœ„í—˜ ê²½ê³ </b>

ğŸ“Š <b>{position.symbol}</b> {position.side} {position.leverage}x
ğŸ’° ì§„ì…ê°€: <b>${Utils.format_number(position.entry_price)}</b>
ğŸ’¸ í˜„ì¬ê°€: <b>${Utils.format_number(position.current_price)}</b>
ğŸš¨ ì²­ì‚°ê°€: <b>${Utils.format_number(position.liquidation_price)}</b>

âš ï¸ ìœ„í—˜ë„: <b>{Utils.format_percentage(position.liquidation_risk * 100)}</b>
ğŸ’” ë¯¸ì‹¤í˜„ P&L: <b>${Utils.format_number(position.unrealized_pnl)}</b> ({Utils.format_percentage(position.pnl_percentage, 1, signed=True)})

ğŸ†” í¬ì§€ì…˜: <code>{position.position_id}</code>
ğŸ• {datetime.utcnow().strftime('%H:%M:%S UTC')}

âš¡ ì¦‰ì‹œ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤!"""
            
            await self.send_message(message, "CRITICAL", force=True)
            self.last_alerts[warning_key] = now
            
        except Exception as e:
            logging.error(f"ì²­ì‚° ê²½ê³  ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    async def send_system_notification(self, message: str, level: str = "INFO"):
        """ì‹œìŠ¤í…œ ì•Œë¦¼ (ê°œì„ ë¨)"""
        try:
            system_message = f"""ğŸ–¥ï¸ <b>Phoenix 95 Ultimate System</b>

{message}

ğŸ• {datetime.utcnow().strftime('%H:%M:%S UTC')}"""
            
            await self.send_message(system_message, level)
            
        except Exception as e:
            logging.error(f"ì‹œìŠ¤í…œ ì•Œë¦¼ ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    async def send_daily_summary(self, stats: Dict):
        """ì¼ì¼ ì„±ê³¼ ìš”ì•½ (ê°œì„ ë¨)"""
        try:
            total_trades = Utils.safe_int(stats.get('total_trades', 0))
            winning_trades = Utils.safe_int(stats.get('winning_trades', 0))
            win_rate = (winning_trades / max(total_trades, 1)) * 100
            
            message = f"""ğŸ“Š <b>Phoenix 95 Ultimate ì¼ì¼ ì„±ê³¼</b>

ğŸ’° ì´ P&L: <b>${Utils.format_number(stats.get('total_pnl', 0))}</b>
ğŸ“ˆ ì´ ê±°ë˜: <b>{total_trades}íšŒ</b>
ğŸ¯ ìŠ¹ë¥ : <b>{Utils.format_percentage(win_rate)}</b>
ğŸ† ìµœê³  ê±°ë˜: <b>${Utils.format_number(stats.get('best_trade', 0))}</b>
ğŸ’” ìµœì•… ê±°ë˜: <b>${Utils.format_number(stats.get('worst_trade', 0))}</b>
â±ï¸ í‰ê·  ê±°ë˜ì‹œê°„: <b>{Utils.safe_int(stats.get('avg_duration', 0))}ë¶„</b>

ğŸ“Š í™œì„± í¬ì§€ì…˜: <b>{Utils.safe_int(stats.get('active_positions', 0))}ê°œ</b>
ğŸ’¸ ì´ ë§ˆì§„: <b>${Utils.format_number(stats.get('total_margin', 0))}</b>

ğŸ• {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}"""
            
            await self.send_message(message, "INFO")
            
        except Exception as e:
            logging.error(f"ì¼ì¼ ìš”ì•½ ì „ì†¡ ì˜¤ë¥˜: {e}")
    
    def get_stats(self) -> Dict:
        """í…”ë ˆê·¸ë¨ ì•Œë¦¼ í†µê³„"""
        try:
            recent_messages = list(self.message_queue)[-24:]  # ìµœê·¼ 24ê°œ
            
            return {
                "total_messages": len(self.message_queue),
                "error_count": self.error_count,
                "recent_messages": len(recent_messages),
                "success_rate": (len([m for m in recent_messages if m.get('success')]) / 
                               max(len(recent_messages), 1)) * 100,
                "alert_types": {
                    level: len([m for m in recent_messages if m.get('level') == level])
                    for level in ['INFO', 'WARNING', 'ERROR', 'CRITICAL', 'SUCCESS']
                }
            }
        except Exception as e:
            logging.error(f"í…”ë ˆê·¸ë¨ í†µê³„ ìƒì„± ì˜¤ë¥˜: {e}")
            return {"error": str(e)}

# Utils í´ë˜ìŠ¤ì— ëˆ„ë½ëœ ë©”ì„œë“œ ì¶”ê°€
def format_percentage_signed(value: Union[int, float], decimals: int = 1) -> str:
    """ë¶€í˜¸ í¬í•¨ í¼ì„¼í‹°ì§€ í¬ë§·íŒ…"""
    try:
        if isinstance(value, (int, float)) and not np.isnan(value):
            sign = "+" if value > 0 else ""
            return f"{sign}{value:.{decimals}f}%"
        return "0.0%"
    except:
        return "0.0%"

# Utilsì— ë©”ì„œë“œ ì¶”ê°€
Utils.format_percentage = lambda value, decimals=1, signed=False: (
    format_percentage_signed(value, decimals) if signed else Utils.format_percentage(value, decimals)
)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ”’ ë³´ì•ˆ & ì¸ì¦ (ê°œì„ ë¨)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SecurityManager:
    """ë³´ì•ˆ ê´€ë¦¬ì (ê°œì„ ë¨)"""
    
    def __init__(self):
        self.config = SystemConfig.SECURITY
        self.failed_attempts = {}  # IPë³„ ì‹¤íŒ¨ íšŸìˆ˜
        self.blocked_ips = set()
        
    def verify_webhook_signature(self, payload: str, signature: str) -> bool:
        """ì›¹í›… ì„œëª… ê²€ì¦ (ê°œì„ ë¨)"""
        try:
            if not payload or not signature:
                return False
                
            expected_signature = hmac.new(
                self.config["webhook_secret"].encode(),
                payload.encode(),
                hashlib.sha256
            ).hexdigest()
            
            return hmac.compare_digest(signature, expected_signature)
        except Exception as e:
            logging.error(f"ì„œëª… ê²€ì¦ ì‹¤íŒ¨: {e}")
            return False
    
    def verify_api_key(self, api_key: str) -> bool:
        """API í‚¤ ê²€ì¦ (ê°œì„ ë¨)"""
        try:
            if not api_key:
                return False
            return hmac.compare_digest(api_key, self.config["api_key"])
        except Exception as e:
            logging.error(f"API í‚¤ ê²€ì¦ ì‹¤íŒ¨: {e}")
            return False
    
    def is_ip_allowed(self, ip: str) -> bool:
        """IP í—ˆìš© ëª©ë¡ í™•ì¸ (ê°œì„ ë¨)"""
        try:
            if ip in self.blocked_ips:
                return False
                
            allowed_ips = self.config["allowed_ips"]
            return (ip in allowed_ips or 
                   "0.0.0.0" in allowed_ips or 
                   ip in ["127.0.0.1", "localhost"])
        except Exception as e:
            logging.error(f"IP í™•ì¸ ì‹¤íŒ¨: {e}")
            return False
    
    def record_failed_attempt(self, ip: str):
        """ì‹¤íŒ¨ ì‹œë„ ê¸°ë¡"""
        try:
            self.failed_attempts[ip] = self.failed_attempts.get(ip, 0) + 1
            
            # 5íšŒ ì‹¤íŒ¨ ì‹œ ì°¨ë‹¨
            if self.failed_attempts[ip] >= 5:
                self.blocked_ips.add(ip)
                logging.warning(f"IP ì°¨ë‹¨ë¨: {ip}")
        except Exception as e:
            logging.error(f"ì‹¤íŒ¨ ì‹œë„ ê¸°ë¡ ì˜¤ë¥˜: {e}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“Š ëª¨ë‹ˆí„°ë§ & ë©”íŠ¸ë¦­ (ì™„ì „ ê°œì„ ë¨)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SystemMonitor:
    """ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ (ì™„ì „ ê°œì„ ë¨)"""
    
    def __init__(self, redis_client, postgres_pool, telegram_notifier):
        self.redis = redis_client
        self.postgres = postgres_pool
        self.telegram = telegram_notifier
        self.metrics_history = deque(maxlen=1440)  # 24ì‹œê°„ (ë¶„ë‹¹ 1ê°œ)
        self.last_alert_time = {}
        self.error_count = 0
        
    async def collect_system_metrics(self) -> Optional[PerformanceMetrics]:
        """ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ (ê°œì„ ë¨)"""
        try:
            # CPU/ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ 
            cpu_usage, memory_usage = await self._get_system_resources()
            
            # ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìˆ˜
            active_connections = await self._get_db_connections()
            
            # íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­
            trading_metrics = await self._get_trading_metrics()
            
            metrics = PerformanceMetrics(
                timestamp=datetime.utcnow(),
                cpu_usage=cpu_usage,
                memory_usage=memory_usage,
                response_time_ms=0.0,  # APIì—ì„œ ì¸¡ì •
                active_connections=active_connections,
                active_positions=trading_metrics.get('active_positions', 0),
                total_pnl=trading_metrics.get('total_pnl', 0.0),
                win_rate=trading_metrics.get('win_rate', 0.0),
                avg_trade_duration=trading_metrics.get('avg_duration', 0.0),
                phoenix95_avg_score=trading_metrics.get('avg_score', 0.0),
                max_drawdown=trading_metrics.get('max_drawdown', 0.0),
                var_95=trading_metrics.get('var_95', 0.0),
                sharpe_ratio=trading_metrics.get('sharpe_ratio', 0.0),
                total_trades=trading_metrics.get('total_trades', 0),
                winning_trades=trading_metrics.get('winning_trades', 0)
            )
            
            self.metrics_history.append(metrics)
            return metrics
            
        except Exception as e:
            self.error_count += 1
            logging.error(f"ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤íŒ¨: {e}")
            return None
    
    async def _get_system_resources(self) -> Tuple[float, float]:
        """ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì¡°íšŒ"""
        try:
            import psutil
            cpu_usage = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            memory_usage = memory.percent
            return cpu_usage, memory_usage
        except ImportError:
            logging.warning("psutil ë¼ì´ë¸ŒëŸ¬ë¦¬ê°€ ì—†ì–´ ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì‹œë®¬ë ˆì´ì…˜")
            # ì‹œë®¬ë ˆì´ì…˜ (ì‹¤ì œ í™˜ê²½ì—ì„œëŠ” psutil ì‚¬ìš©)
            import random
            return random.uniform(10, 30), random.uniform(40, 60)
        except Exception as e:
            logging.error(f"ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return 0.0, 0.0
    
    async def _get_db_connections(self) -> int:
        """ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìˆ˜ ì¡°íšŒ"""
        try:
            async with self.postgres.acquire() as conn:
                result = await conn.fetchval(
                    "SELECT count(*) FROM pg_stat_activity WHERE state = 'active'"
                )
                return Utils.safe_int(result)
        except Exception as e:
            logging.error(f"DB ì—°ê²° ìˆ˜ ì¡°íšŒ ì˜¤ë¥˜: {e}")
            return 0
    
    async def _get_trading_metrics(self) -> Dict:
        """íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­ ìˆ˜ì§‘ (ê°œì„ ë¨)"""
        try:
            async with self.postgres.acquire() as conn:
                # ì˜¤ëŠ˜ í†µê³„
                today_stats = await conn.fetchrow("""
                    SELECT 
                        COUNT(*) as total_trades,
                        COUNT(*) FILTER (WHERE pnl > 0) as winning_trades,
                        COALESCE(SUM(pnl), 0) as total_pnl,
                        COALESCE(AVG(duration_minutes), 0) as avg_duration,
                        COALESCE(MAX(pnl), 0) as best_trade,
                        COALESCE(MIN(pnl), 0) as worst_trade
                    FROM trade_history 
                    WHERE DATE(entry_time) = CURRENT_DATE
                """)
                
                # í™œì„± í¬ì§€ì…˜
                active_positions = await conn.fetchval(
                    "SELECT COUNT(*) FROM positions WHERE status = 'OPEN'"
                )
                
                # ì£¼ê°„ í†µê³„
                weekly_stats = await conn.fetchrow("""
                    SELECT 
                        COALESCE(SUM(pnl), 0) as weekly_pnl,
                        COUNT(*) as weekly_trades
                    FROM trade_history 
                    WHERE entry_time >= CURRENT_DATE - INTERVAL '7 days'
                """)
                
                win_rate = 0.0
                if today_stats and today_stats['total_trades'] > 0:
                    win_rate = (today_stats['winning_trades'] / today_stats['total_trades']) * 100
                
                return {
                    'active_positions': Utils.safe_int(active_positions),
                    'total_pnl': Utils.safe_float(today_stats['total_pnl'] if today_stats else 0),
                    'win_rate': win_rate,
                    'avg_duration': Utils.safe_float(today_stats['avg_duration'] if today_stats else 0),
                    'avg_score': 0.85,  # Phoenix 95 í‰ê·  ì ìˆ˜ (ì‹¤ì œë¡œëŠ” ê³„ì‚°)
                    'max_drawdown': 0.0,  # ì‹¤ì œë¡œëŠ” ê³„ì‚° í•„ìš”
                    'var_95': 0.0,       # ì‹¤ì œë¡œëŠ” ê³„ì‚° í•„ìš”
                    'sharpe_ratio': 0.0, # ì‹¤ì œë¡œëŠ” ê³„ì‚° í•„ìš”
                    'total_trades': Utils.safe_int(today_stats['total_trades'] if today_stats else 0),
                    'winning_trades': Utils.safe_int(today_stats['winning_trades'] if today_stats else 0),
                    'best_trade': Utils.safe_float(today_stats['best_trade'] if today_stats else 0),
                    'worst_trade': Utils.safe_float(today_stats['worst_trade'] if today_stats else 0),
                    'weekly_pnl': Utils.safe_float(weekly_stats['weekly_pnl'] if weekly_stats else 0),
                    'weekly_trades': Utils.safe_int(weekly_stats['weekly_trades'] if weekly_stats else 0)
                }
                
        except Exception as e:
            logging.error(f"íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤íŒ¨: {e}")
            return {}
    
    async def check_alerts(self, metrics: PerformanceMetrics):
        """ì•Œë¦¼ ì²´í¬ (ê°œì„ ë¨)"""
        try:
            alerts = []
            thresholds = SystemConfig.MONITORING["performance_threshold"]
            now = time.time()
            
            # CPU ì‚¬ìš©ë¥  ì²´í¬
            if metrics.cpu_usage > thresholds["cpu_usage_pct"]:
                alert_key = "high_cpu"
                if self._should_send_alert(alert_key, now):
                    alerts.append(f"ë†’ì€ CPU ì‚¬ìš©ë¥ : {Utils.format_percentage(metrics.cpu_usage)}")
            
            # ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ì²´í¬
            if metrics.memory_usage > thresholds["memory_usage_pct"]:
                alert_key = "high_memory"
                if self._should_send_alert(alert_key, now):
                    alerts.append(f"ë†’ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : {Utils.format_percentage(metrics.memory_usage)}")
            
            # ì‘ë‹µ ì‹œê°„ ì²´í¬
            if metrics.response_time_ms > thresholds["response_time_ms"]:
                alert_key = "slow_response"
                if self._should_send_alert(alert_key, now):
                    alerts.append(f"ëŠë¦° ì‘ë‹µ ì‹œê°„: {metrics.response_time_ms:.0f}ms")
            
            # ì¼ì¼ ì†ì‹¤ ì²´í¬
            if metrics.total_pnl < -SystemConfig.TRADING["max_daily_loss"] * 0.8:  # 80% ë„ë‹¬ì‹œ ê²½ê³ 
                alert_key = "daily_loss_warning"
                if self._should_send_alert(alert_key, now):
                    alerts.append(f"ì¼ì¼ ì†ì‹¤ ê²½ê³ : ${Utils.format_number(abs(metrics.total_pnl))}")
            
            # ì•Œë¦¼ ì „ì†¡
            for alert in alerts:
                await self.telegram.send_system_notification(alert, "WARNING")
                
        except Exception as e:
            logging.error(f"ì•Œë¦¼ ì²´í¬ ì˜¤ë¥˜: {e}")
    
    def _should_send_alert(self, alert_key: str, current_time: float) -> bool:
        """ì•Œë¦¼ ì¿¨ë‹¤ìš´ ì²´í¬"""
        try:
            cooldown = SystemConfig.MONITORING["alert_cooldown"]
            
            if alert_key not in self.last_alert_time:
                self.last_alert_time[alert_key] = current_time
                return True
            
            if current_time - self.last_alert_time[alert_key] > cooldown:
                self.last_alert_time[alert_key] = current_time
                return True
            
            return False
        except Exception as e:
            logging.error(f"ì•Œë¦¼ ì¿¨ë‹¤ìš´ ì²´í¬ ì˜¤ë¥˜: {e}")
            return False
    
    def get_metrics_summary(self) -> Dict:
        """ë©”íŠ¸ë¦­ ìš”ì•½"""
        try:
            if not self.metrics_history:
                return {"error": "ë©”íŠ¸ë¦­ ì´ë ¥ ì—†ìŒ"}
            
            recent_metrics = list(self.metrics_history)[-10:]  # ìµœê·¼ 10ê°œ
            
            return {
                "total_metrics": len(self.metrics_history),
                "recent_avg_cpu": np.mean([m.cpu_usage for m in recent_metrics]),
                "recent_avg_memory": np.mean([m.memory_usage for m in recent_metrics]),
                "active_positions": recent_metrics[-1].active_positions if recent_metrics else 0,
                "total_pnl": recent_metrics[-1].total_pnl if recent_metrics else 0.0,
                "error_count": self.error_count,
                "last_update": recent_metrics[-1].timestamp.isoformat() if recent_metrics else None
            }
        except Exception as e:
            logging.error(f"ë©”íŠ¸ë¦­ ìš”ì•½ ìƒì„± ì˜¤ë¥˜: {e}")
            return {"error": str(e)}

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ’¾ ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™”
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class DatabaseInitializer:
    """ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” (ì¶”ê°€ë¨)"""
    
    @staticmethod
    async def init_database(postgres_pool):
        """ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸” ì´ˆê¸°í™”"""
        try:
            async with postgres_pool.acquire() as conn:
                # Signals í…Œì´ë¸”
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS signals (
                        signal_id VARCHAR(50) PRIMARY KEY,
                        symbol VARCHAR(20) NOT NULL,
                        action VARCHAR(10) NOT NULL,
                        price DECIMAL(20, 8) NOT NULL,
                        confidence DECIMAL(5, 4) NOT NULL,
                        phoenix95_score DECIMAL(5, 4),
                        kelly_ratio DECIMAL(5, 4),
                        recommendation VARCHAR(20),
                        timestamp TIMESTAMP WITH TIME ZONE NOT NULL,
                        processed BOOLEAN DEFAULT FALSE,
                        processing_time_ms DECIMAL(10, 2),
                        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # Positions í…Œì´ë¸”
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS positions (
                        position_id VARCHAR(50) PRIMARY KEY,
                        signal_id VARCHAR(50) REFERENCES signals(signal_id),
                        symbol VARCHAR(20) NOT NULL,
                        side VARCHAR(10) NOT NULL,
                        entry_price DECIMAL(20, 8) NOT NULL,
                        quantity DECIMAL(20, 8) NOT NULL,
                        leverage INTEGER NOT NULL,
                        margin_mode VARCHAR(20) NOT NULL,
                        margin_required DECIMAL(20, 8) NOT NULL,
                        liquidation_price DECIMAL(20, 8) NOT NULL,
                        stop_loss_price DECIMAL(20, 8) NOT NULL,
                        take_profit_price DECIMAL(20, 8) NOT NULL,
                        current_price DECIMAL(20, 8) DEFAULT 0,
                        unrealized_pnl DECIMAL(20, 8) DEFAULT 0,
                        pnl_percentage DECIMAL(10, 4) DEFAULT 0,
                        liquidation_risk DECIMAL(5, 4) DEFAULT 0,
                        status VARCHAR(20) DEFAULT 'OPEN',
                        exit_price DECIMAL(20, 8),
                        exit_time TIMESTAMP WITH TIME ZONE,
                        exit_reason VARCHAR(50),
                        realized_pnl DECIMAL(20, 8),
                        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,
                        updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # Trade History í…Œì´ë¸”
                await conn.execute("""
                    CREATE TABLE IF NOT EXISTS trade_history (
                        id SERIAL PRIMARY KEY,
                        position_id VARCHAR(50) UNIQUE NOT NULL,
                        symbol VARCHAR(20) NOT NULL,
                        side VARCHAR(10) NOT NULL,
                        entry_price DECIMAL(20, 8) NOT NULL,
                        exit_price DECIMAL(20, 8) NOT NULL,
                        quantity DECIMAL(20, 8) NOT NULL,
                        leverage INTEGER NOT NULL,
                        pnl DECIMAL(20, 8) NOT NULL,
                        pnl_percentage DECIMAL(10, 4) NOT NULL,
                        duration_minutes INTEGER NOT NULL,
                        entry_time TIMESTAMP WITH TIME ZONE NOT NULL,
                        exit_time TIMESTAMP WITH TIME ZONE NOT NULL,
                        exit_reason VARCHAR(50) NOT NULL,
                        created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
                    )
                """)
                
                # ì¸ë±ìŠ¤ ìƒì„±
                await conn.execute("CREATE INDEX IF NOT EXISTS idx_signals_timestamp ON signals(timestamp)")
                await conn.execute("CREATE INDEX IF NOT EXISTS idx_positions_status ON positions(status)")
                await conn.execute("CREATE INDEX IF NOT EXISTS idx_positions_symbol ON positions(symbol)")
                await conn.execute("CREATE INDEX IF NOT EXISTS idx_trade_history_entry_time ON trade_history(entry_time)")
                await conn.execute("CREATE INDEX IF NOT EXISTS idx_trade_history_symbol ON trade_history(symbol)")
                
                logging.info("ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸” ì´ˆê¸°í™” ì™„ë£Œ")
                
        except Exception as e:
            logging.error(f"ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            raise

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸš€ ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ (ì™„ì „ ê°œì„ ë¨)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Phoenix95UltimateSystem:
    """Phoenix 95 Ultimate í†µí•© ì‹œìŠ¤í…œ (ì™„ì „ ê°œì„ ë¨)"""
    
    def __init__(self):
        self.phoenix95_engine = Phoenix95AIEngine()
        self.telegram = UltimateTelegramNotifier()
        self.security = SecurityManager()
        self.redis_client = None
        self.postgres_pool = None
        self.trader = None
        self.monitor = None
        self.start_time = datetime.utcnow()
        self.request_count = 0
        self.error_count = 0
        
        # FastAPI ì•±
        self.app = FastAPI(
            title="Phoenix 95 Ultimate Trading System",
            description="V3 ê²€ì¦ëœ ì•Œê³ ë¦¬ì¦˜ + V4 ê³ ê¸‰ ê¸°ëŠ¥ + í—¤ì§€í€ë“œê¸‰ ì•ˆì „ì„± + ì™„ì „í•œ ì˜¤ë¥˜ ìˆ˜ì •",
            version="Ultimate-1.0.0-Final"
        )
        
        self._setup_middleware()
        self._setup_routes()
        self._setup_error_handlers()
        
    def _setup_middleware(self):
        """ë¯¸ë“¤ì›¨ì–´ ì„¤ì • (ê°œì„ ë¨)"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
        
        # ìš”ì²­ ë¡œê¹… ë¯¸ë“¤ì›¨ì–´
        @self.app.middleware("http")
        async def log_requests(request: Request, call_next):
            start_time = time.time()
            self.request_count += 1
            
            try:
                response = await call_next(request)
                process_time = time.time() - start_time
                
                logging.info(f"{request.method} {request.url.path} - "
                           f"{response.status_code} - {process_time*1000:.0f}ms")
                
                response.headers["X-Process-Time"] = str(process_time)
                return response
                
            except Exception as e:
                self.error_count += 1
                logging.error(f"ìš”ì²­ ì²˜ë¦¬ ì˜¤ë¥˜ {request.url.path}: {e}")
                raise
    
    def _setup_error_handlers(self):
        """ì˜¤ë¥˜ í•¸ë“¤ëŸ¬ ì„¤ì • (ì¶”ê°€ë¨)"""
        
        @self.app.exception_handler(Exception)
        async def global_exception_handler(request: Request, exc: Exception):
            self.error_count += 1
            logging.error(f"ì „ì—­ ì˜¤ë¥˜ {request.url.path}: {exc}")
            logging.error(traceback.format_exc())
            
            return JSONResponse(
                status_code=500,
                content={
                    "error": "Internal Server Error",
                    "message": "ì‹œìŠ¤í…œ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤",
                    "timestamp": datetime.utcnow().isoformat(),
                    "path": str(request.url.path)
                }
            )
        
        @self.app.exception_handler(HTTPException)
        async def http_exception_handler(request: Request, exc: HTTPException):
            return JSONResponse(
                status_code=exc.status_code,
                content={
                    "error": exc.detail,
                    "timestamp": datetime.utcnow().isoformat(),
                    "path": str(request.url.path)
                }
            )
    
    def _setup_routes(self):
        """API ë¼ìš°íŠ¸ ì„¤ì • (ì™„ì „ ê°œì„ ë¨)"""
        
        @self.app.on_event("startup")
        async def startup_event():
            await self.initialize()
        
        @self.app.on_event("shutdown")
        async def shutdown_event():
            await self.cleanup()
        
        # Pydantic ëª¨ë¸ë“¤
        class TradingViewSignal(BaseModel):
            symbol: str = Field(..., description="ê±°ë˜ ì‹¬ë³¼")
            action: str = Field(..., description="ê±°ë˜ ë°©í–¥ (buy/sell)")
            price: float = Field(..., gt=0, description="ê°€ê²©")
            confidence: float = Field(..., ge=0.0, le=1.0, description="ì‹ ë¢°ë„")
            
            @validator('symbol')
            def validate_symbol(cls, v):
                if not Utils.validate_symbol(v):
                    raise ValueError('ìœ íš¨í•˜ì§€ ì•Šì€ ì‹¬ë³¼ì…ë‹ˆë‹¤')
                return v.upper()
            
            @validator('action')
            def validate_action(cls, v):
                if not Utils.validate_action(v):
                    raise ValueError('ìœ íš¨í•˜ì§€ ì•Šì€ ì•¡ì…˜ì…ë‹ˆë‹¤')
                return v.upper()
        
        @self.app.post("/webhook/tradingview")
        async def receive_tradingview_signal(
            signal_data: TradingViewSignal, 
            background_tasks: BackgroundTasks,
            request: Request
        ):
            """TradingView ì‹ í˜¸ ìˆ˜ì‹  (ê°œì„ ë¨)"""
            try:
                # IP ì²´í¬
                client_ip = request.client.host
                if not self.security.is_ip_allowed(client_ip):
                    self.security.record_failed_attempt(client_ip)
                    raise HTTPException(status_code=403, detail="ì ‘ê·¼ì´ ê±°ë¶€ë˜ì—ˆìŠµë‹ˆë‹¤")
                
                # ì‹ í˜¸ ìƒì„±
                signal = TradingSignal(
                    signal_id=f"SIG_{uuid.uuid4().hex[:8].upper()}",
                    symbol=signal_data.symbol,
                    action=signal_data.action.lower(),
                    price=signal_data.price,
                    confidence=signal_data.confidence,
                    timestamp=datetime.utcnow()
                )
                
                if not signal.is_valid():
                    raise HTTPException(status_code=400, detail="ì˜ëª»ëœ ì‹ í˜¸ ë°ì´í„°")
                
                # ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì²˜ë¦¬
                background_tasks.add_task(self._process_signal_complete, signal)
                
                logging.info(f"ì‹ í˜¸ ìˆ˜ì‹  ì™„ë£Œ: {signal.signal_id} - {signal.symbol} {signal.action}")
                
                return {
                    "status": "received",
                    "signal_id": signal.signal_id,
                    "symbol": signal.symbol,
                    "action": signal.action,
                    "timestamp": signal.timestamp.isoformat(),
                    "message": "ì‹ í˜¸ê°€ ì„±ê³µì ìœ¼ë¡œ ìˆ˜ì‹ ë˜ì–´ ì²˜ë¦¬ ì¤‘ì…ë‹ˆë‹¤"
                }
                
            except HTTPException:
                raise
            except Exception as e:
                logging.error(f"ì‹ í˜¸ ìˆ˜ì‹  ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=f"ì‹ í˜¸ ì²˜ë¦¬ ì˜¤ë¥˜: {str(e)}")
        
        @self.app.get("/health")
        async def health_check():
            """ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬ (ê°œì„ ë¨)"""
            try:
                # ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì²´í¬
                db_healthy = False
                db_error = None
                try:
                    async with self.postgres_pool.acquire() as conn:
                        await conn.fetchval("SELECT 1")
                    db_healthy = True
                except Exception as e:
                    db_error = str(e)
                
                # Redis ì—°ê²° ì²´í¬
                redis_healthy = False
                redis_error = None
                try:
                    await self.redis_client.ping()
                    redis_healthy = True
                except Exception as e:
                    redis_error = str(e)
                
                # ì „ì²´ ì‹œìŠ¤í…œ ìƒíƒœ
                overall_healthy = db_healthy and redis_healthy
                
                # í¬íŠ¸í´ë¦¬ì˜¤ ìš”ì•½
                portfolio = {}
                if self.trader:
                    try:
                        portfolio = self.trader.get_portfolio_summary()
                    except Exception as e:
                        logging.error(f"í¬íŠ¸í´ë¦¬ì˜¤ ìš”ì•½ ì˜¤ë¥˜: {e}")
                
                # ì—…íƒ€ì„ ê³„ì‚°
                uptime_seconds = (datetime.utcnow() - self.start_time).total_seconds()
                uptime_hours = uptime_seconds / 3600
                
                return {
                    "status": "healthy" if overall_healthy else "degraded",
                    "timestamp": datetime.utcnow().isoformat(),
                    "version": "Ultimate-1.0.0-Final",
                    "system": "Phoenix 95 Ultimate Trading System",
                    "uptime_hours": round(uptime_hours, 2),
                    "request_count": self.request_count,
                    "error_count": self.error_count,
                    "error_rate": (self.error_count / max(self.request_count, 1)) * 100,
                    "components": {
                        "database": {
                            "status": "healthy" if db_healthy else "error",
                            "error": db_error
                        },
                        "redis": {
                            "status": "healthy" if redis_healthy else "error", 
                            "error": redis_error
                        },
                        "ai_engine": {
                            "status": "healthy",
                            "stats": self.phoenix95_engine.get_performance_stats()
                        },
                        "trading_engine": {
                            "status": "healthy" if self.trader else "error",
                            "stats": portfolio
                        },
                        "telegram": {
                            "status": "healthy",
                            "stats": self.telegram.get_stats()
                        }
                    },
                    "config": {
                        "max_leverage": SystemConfig.TRADING["max_leverage"],
                        "max_positions": SystemConfig.TRADING["max_positions"],
                        "confidence_threshold": SystemConfig.TRADING["confidence_threshold"],
                        "max_daily_loss": SystemConfig.TRADING["max_daily_loss"]
                    }
                }
                
            except Exception as e:
                logging.error(f"í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=f"í—¬ìŠ¤ì²´í¬ ì˜¤ë¥˜: {str(e)}")
        
        @self.app.get("/positions")
        async def get_active_positions():
            """í™œì„± í¬ì§€ì…˜ ì¡°íšŒ (ê°œì„ ë¨)"""
            try:
                if not self.trader:
                    return {"positions": [], "count": 0, "message": "íŠ¸ë ˆì´ë”ê°€ ì´ˆê¸°í™”ë˜ì§€ ì•ŠìŒ"}
                
                positions = []
                for position in self.trader.active_positions.values():
                    try:
                        positions.append({
                            "position_id": position.position_id,
                            "symbol": position.symbol,
                            "side": position.side,
                            "entry_price": Utils.safe_float(position.entry_price),
                            "current_price": Utils.safe_float(position.current_price),
                            "quantity": Utils.safe_float(position.quantity),
                            "leverage": Utils.safe_int(position.leverage),
                            "margin_required": Utils.safe_float(position.margin_required),
                            "unrealized_pnl": Utils.safe_float(position.unrealized_pnl),
                            "pnl_percentage": Utils.safe_float(position.pnl_percentage),
                            "liquidation_risk": Utils.safe_float(position.liquidation_risk),
                            "liquidation_price": Utils.safe_float(position.liquidation_price),
                            "stop_loss_price": Utils.safe_float(position.stop_loss_price),
                            "take_profit_price": Utils.safe_float(position.take_profit_price),
                            "status": position.status,
                            "created_at": position.created_at.isoformat() if position.created_at else None,
                            "duration_minutes": Utils.calculate_trade_duration(position.created_at) if position.created_at else 0
                        })
                    except Exception as e:
                        logging.error(f"í¬ì§€ì…˜ ì§ë ¬í™” ì˜¤ë¥˜ {position.position_id}: {e}")
                
                portfolio_summary = self.trader.get_portfolio_summary()
                
                return {
                    "positions": positions,
                    "count": len(positions),
                    "summary": portfolio_summary,
                    "timestamp": datetime.utcnow().isoformat()
                }
                
            except Exception as e:
                logging.error(f"í¬ì§€ì…˜ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=f"í¬ì§€ì…˜ ì¡°íšŒ ì˜¤ë¥˜: {str(e)}")
        
        @self.app.get("/performance")
        async def get_performance_stats():
            """ì„±ëŠ¥ í†µê³„ ì¡°íšŒ (ê°œì„ ë¨)"""
            try:
                # AI ì—”ì§„ ì„±ëŠ¥
                ai_stats = self.phoenix95_engine.get_performance_stats()
                
                # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­
                system_metrics = {}
                if self.monitor and self.monitor.metrics_history:
                    latest_metrics = self.monitor.metrics_history[-1]
                    system_metrics = latest_metrics.to_dict()
                    # ì¶”ê°€ ë©”íŠ¸ë¦­ ìš”ì•½
                    system_metrics.update(self.monitor.get_metrics_summary())
                
                # ê±°ë˜ í†µê³„
                trading_stats = {}
                if self.postgres_pool:
                    try:
                        async with self.postgres_pool.acquire() as conn:
                            # ì˜¤ëŠ˜ í†µê³„
                            today_stats = await conn.fetchrow("""
                                SELECT 
                                    COUNT(*) as total_trades,
                                    COUNT(*) FILTER (WHERE pnl > 0) as winning_trades,
                                    COALESCE(SUM(pnl), 0) as total_pnl,
                                    COALESCE(AVG(pnl), 0) as avg_pnl,
                                    COALESCE(MAX(pnl), 0) as best_trade,
                                    COALESCE(MIN(pnl), 0) as worst_trade,
                                    COALESCE(AVG(duration_minutes), 0) as avg_duration
                                FROM trade_history 
                                WHERE DATE(entry_time) = CURRENT_DATE
                            """)
                            
                            # ì£¼ê°„ í†µê³„
                            weekly_stats = await conn.fetchrow("""
                                SELECT 
                                    COUNT(*) as weekly_trades,
                                    COALESCE(SUM(pnl), 0) as weekly_pnl,
                                    COUNT(*) FILTER (WHERE pnl > 0) as weekly_winning
                                FROM trade_history 
                                WHERE entry_time >= CURRENT_DATE - INTERVAL '7 days'
                            """)
                            
                            if today_stats:
                                trading_stats = dict(today_stats)
                                trading_stats.update({
                                    "win_rate": (trading_stats['winning_trades'] / max(trading_stats['total_trades'], 1)) * 100,
                                    "weekly_trades": weekly_stats['weekly_trades'] if weekly_stats else 0,
                                    "weekly_pnl": Utils.safe_float(weekly_stats['weekly_pnl'] if weekly_stats else 0),
                                    "weekly_win_rate": (weekly_stats['weekly_winning'] / max(weekly_stats['weekly_trades'], 1)) * 100 if weekly_stats else 0
                                })
                    except Exception as e:
                        logging.error(f"ê±°ë˜ í†µê³„ ì¡°íšŒ ì˜¤ë¥˜: {e}")
                        trading_stats = {"error": str(e)}
                
                # íŠ¸ë ˆì´ë” ì„±ëŠ¥
                trader_stats = {}
                if self.trader:
                    trader_stats = self.trader.get_portfolio_summary()
                
                return {
                    "timestamp": datetime.utcnow().isoformat(),
                    "uptime_hours": round((datetime.utcnow() - self.start_time).total_seconds() / 3600, 2),
                    "ai_engine": ai_stats,
                    "system_metrics": system_metrics,
                    "trading_stats": trading_stats,
                    "trader_performance": trader_stats,
                    "telegram_stats": self.telegram.get_stats(),
                    "request_stats": {
                        "total_requests": self.request_count,
                        "total_errors": self.error_count,
                        "error_rate": (self.error_count / max(self.request_count, 1)) * 100
                    }
                }
                
            except Exception as e:
                logging.error(f"ì„±ëŠ¥ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=f"ì„±ëŠ¥ í†µê³„ ì˜¤ë¥˜: {str(e)}")
        
        @self.app.post("/admin/emergency_close/{position_id}")
        async def emergency_close_position(position_id: str):
            """ê¸´ê¸‰ í¬ì§€ì…˜ ì²­ì‚° (ê°œì„ ë¨)"""
            try:
                if not self.trader or position_id not in self.trader.active_positions:
                    raise HTTPException(status_code=404, detail="í¬ì§€ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
                
                position = self.trader.active_positions[position_id]
                current_price = await self.trader._get_current_price(position.symbol)
                
                await self.trader._close_position(position, current_price, "MANUAL")
                
                return {
                    "status": "success",
                    "message": f"í¬ì§€ì…˜ {position_id} ê¸´ê¸‰ ì²­ì‚° ì™„ë£Œ",
                    "position_id": position_id,
                    "exit_price": current_price,
                    "timestamp": datetime.utcnow().isoformat()
                }
                
            except HTTPException:
                raise
            except Exception as e:
                logging.error(f"ê¸´ê¸‰ ì²­ì‚° ì‹¤íŒ¨ {position_id}: {e}")
                raise HTTPException(status_code=500, detail=f"ê¸´ê¸‰ ì²­ì‚° ì˜¤ë¥˜: {str(e)}")
        
        @self.app.get("/admin/system_status")
        async def get_system_status():
            """ê´€ë¦¬ì ì‹œìŠ¤í…œ ìƒíƒœ (ì¶”ê°€ë¨)"""
            try:
                return {
                    "timestamp": datetime.utcnow().isoformat(),
                    "start_time": self.start_time.isoformat(),
                    "components": {
                        "phoenix95_engine": {
                            "initialized": self.phoenix95_engine is not None,
                            "performance": self.phoenix95_engine.get_performance_stats()
                        },
                        "telegram": {
                            "initialized": self.telegram is not None,
                            "stats": self.telegram.get_stats()
                        },
                        "trader": {
                            "initialized": self.trader is not None,
                            "active_positions": len(self.trader.active_positions) if self.trader else 0,
                            "monitoring_tasks": len(self.trader.monitoring_tasks) if self.trader else 0
                        },
                        "monitor": {
                            "initialized": self.monitor is not None,
                            "metrics_count": len(self.monitor.metrics_history) if self.monitor else 0
                        },
                        "database": {
                            "postgres_connected": self.postgres_pool is not None,
                            "redis_connected": self.redis_client is not None
                        }
                    },
                    "config": {
                        "trading": SystemConfig.TRADING,
                        "phoenix95": SystemConfig.PHOENIX95,
                        "monitoring": SystemConfig.MONITORING
                    }
                }
            except Exception as e:
                logging.error(f"ì‹œìŠ¤í…œ ìƒíƒœ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/history/trades")
        async def get_trade_history(limit: int = 50, offset: int = 0):
            """ê±°ë˜ ì´ë ¥ ì¡°íšŒ (ì¶”ê°€ë¨)"""
            try:
                if not self.postgres_pool:
                    raise HTTPException(status_code=503, detail="ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì—†ìŒ")
                
                async with self.postgres_pool.acquire() as conn:
                    trades = await conn.fetch("""
                        SELECT * FROM trade_history 
                        ORDER BY entry_time DESC 
                        LIMIT $1 OFFSET $2
                    """, limit, offset)
                    
                    total_count = await conn.fetchval("SELECT COUNT(*) FROM trade_history")
                
                trade_list = []
                for trade in trades:
                    trade_list.append({
                        "position_id": trade['position_id'],
                        "symbol": trade['symbol'],
                        "side": trade['side'],
                        "entry_price": Utils.safe_float(trade['entry_price']),
                        "exit_price": Utils.safe_float(trade['exit_price']),
                        "quantity": Utils.safe_float(trade['quantity']),
                        "leverage": Utils.safe_int(trade['leverage']),
                        "pnl": Utils.safe_float(trade['pnl']),
                        "pnl_percentage": Utils.safe_float(trade['pnl_percentage']),
                        "duration_minutes": Utils.safe_int(trade['duration_minutes']),
                        "entry_time": trade['entry_time'].isoformat() if trade['entry_time'] else None,
                        "exit_time": trade['exit_time'].isoformat() if trade['exit_time'] else None,
                        "exit_reason": trade['exit_reason']
                    })
                
                return {
                    "trades": trade_list,
                    "pagination": {
                        "total": total_count,
                        "limit": limit,
                        "offset": offset,
                        "has_more": (offset + limit) < total_count
                    },
                    "timestamp": datetime.utcnow().isoformat()
                }
                
            except Exception as e:
                logging.error(f"ê±°ë˜ ì´ë ¥ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=str(e))
    
    async def initialize(self):
        """ì‹œìŠ¤í…œ ì´ˆê¸°í™” (ì™„ì „ ê°œì„ ë¨)"""
        try:
            logging.info("Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹œì‘...")
            
            # Redis ì—°ê²°
            try:
                self.redis_client = await aioredis.from_url(
                    SystemConfig.DATABASE["redis_url"],
                    encoding="utf-8",
                    decode_responses=True,
                    socket_connect_timeout=SystemConfig.DATABASE["connection_timeout"],
                    socket_timeout=SystemConfig.DATABASE["command_timeout"]
                )
                # ì—°ê²° í…ŒìŠ¤íŠ¸
                await self.redis_client.ping()
                logging.info("âœ… Redis ì—°ê²° ì„±ê³µ")
            except Exception as e:
                logging.error(f"âŒ Redis ì—°ê²° ì‹¤íŒ¨: {e}")
                raise
            
            # PostgreSQL ì—°ê²°
            try:
                self.postgres_pool = await asyncpg.create_pool(
                    SystemConfig.DATABASE["postgres_url"],
                    min_size=5,
                    max_size=SystemConfig.DATABASE["connection_pool_size"],
                    command_timeout=SystemConfig.DATABASE["command_timeout"]
                )
                # ì—°ê²° í…ŒìŠ¤íŠ¸
                async with self.postgres_pool.acquire() as conn:
                    await conn.fetchval("SELECT 1")
                logging.info("âœ… PostgreSQL ì—°ê²° ì„±ê³µ")
            except Exception as e:
                logging.error(f"âŒ PostgreSQL ì—°ê²° ì‹¤íŒ¨: {e}")
                raise
            
            # ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸” ì´ˆê¸°í™”
            try:
                await DatabaseInitializer.init_database(self.postgres_pool)
                logging.info("âœ… ë°ì´í„°ë² ì´ìŠ¤ í…Œì´ë¸” ì´ˆê¸°í™” ì™„ë£Œ")
            except Exception as e:
                logging.error(f"âŒ ë°ì´í„°ë² ì´ìŠ¤ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
                raise
            
            # íŠ¸ë ˆì´ë” ì´ˆê¸°í™”
            try:
                self.trader = UltimateLeverageTrader(
                    self.redis_client, 
                    self.postgres_pool, 
                    self.telegram
                )
                logging.info("âœ… Ultimate ë ˆë²„ë¦¬ì§€ íŠ¸ë ˆì´ë” ì´ˆê¸°í™” ì™„ë£Œ")
            except Exception as e:
                logging.error(f"âŒ íŠ¸ë ˆì´ë” ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
                raise
            
            # ëª¨ë‹ˆí„° ì´ˆê¸°í™”
            try:
                self.monitor = SystemMonitor(
                    self.redis_client,
                    self.postgres_pool,
                    self.telegram
                )
                logging.info("âœ… ì‹œìŠ¤í…œ ëª¨ë‹ˆí„° ì´ˆê¸°í™” ì™„ë£Œ")
            except Exception as e:
                logging.error(f"âŒ ëª¨ë‹ˆí„° ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
                raise
            
            # ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì‹œì‘
            try:
                asyncio.create_task(self._monitoring_loop())
                asyncio.create_task(self._daily_summary_loop())
                logging.info("âœ… ë°±ê·¸ë¼ìš´ë“œ íƒœìŠ¤í¬ ì‹œì‘ ì™„ë£Œ")
            except Exception as e:
                logging.error(f"âŒ ë°±ê·¸ë¼ìš´ë“œ íƒœìŠ¤í¬ ì‹œì‘ ì‹¤íŒ¨: {e}")
                raise
            
            # ì‹œì‘ ì•Œë¦¼
            try:
                await self.telegram.send_system_notification(
                    f"""ğŸ¯ <b>Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì‹œì‘</b>

âœ… V3 ê²€ì¦ëœ ì•Œê³ ë¦¬ì¦˜ í™œì„±í™”
âœ… V4 ê³ ê¸‰ ê¸°ëŠ¥ í™œì„±í™”  
âœ… í—¤ì§€í€ë“œê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ í™œì„±í™”
âœ… ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ í™œì„±í™”
âœ… ì™„ì „í•œ ì˜¤ë¥˜ ìˆ˜ì • ë° ê°œì„  ì™„ë£Œ

ğŸ”§ <b>ì‹œìŠ¤í…œ ì„¤ì •</b>
ğŸ’° ìµœëŒ€ ë ˆë²„ë¦¬ì§€: {SystemConfig.TRADING["max_leverage"]}x
ğŸ“Š ìµœëŒ€ í¬ì§€ì…˜: {SystemConfig.TRADING["max_positions"]}ê°œ
ğŸ›¡ï¸ ì¼ì¼ ì†ì‹¤ í•œë„: ${SystemConfig.TRADING["max_daily_loss"]:,}
âš¡ ì‹ ë¢°ë„ ì„ê³„ê°’: {SystemConfig.TRADING["confidence_threshold"]:.0%}
âš–ï¸ Kelly ìµœëŒ€: {SystemConfig.TRADING["kelly_max"]:.0%}

ğŸš€ <b>ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ!</b>
ğŸ”— API ì—”ë“œí¬ì¸íŠ¸: /health, /positions, /performance
ğŸ“Š ê´€ë¦¬ íŒ¨ë„: /admin/system_status""", 
                    "SUCCESS"
                )
                logging.info("âœ… ì‹œì‘ ì•Œë¦¼ ì „ì†¡ ì™„ë£Œ")
            except Exception as e:
                logging.warning(f"âš ï¸ ì‹œì‘ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}")
            
            logging.info("ğŸ‰ Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ!")
            
        except Exception as e:
            logging.error(f"ğŸ’¥ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì¹˜ëª…ì  ì‹¤íŒ¨: {e}")
            logging.error(traceback.format_exc())
            
            # ì‹¤íŒ¨ ì•Œë¦¼
            try:
                await self.telegram.send_system_notification(
                    f"ğŸ’¥ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨\n\nì˜¤ë¥˜: {str(e)}", 
                    "CRITICAL"
                )
            except:
                pass
            
            raise
    
    async def cleanup(self):
        """ì‹œìŠ¤í…œ ì •ë¦¬ (ê°œì„ ë¨)"""
        try:
            logging.info("Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì •ë¦¬ ì‹œì‘...")
            
            # ëª¨ë“  ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì·¨ì†Œ
            if self.trader and self.trader.monitoring_tasks:
                for task in self.trader.monitoring_tasks.values():
                    if not task.done():
                        task.cancel()
                        try:
                            await task
                        except asyncio.CancelledError:
                            pass
                logging.info("âœ… ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì •ë¦¬ ì™„ë£Œ")
            
            # í™œì„± í¬ì§€ì…˜ ì •ë³´ ì €ì¥
            if self.trader and self.trader.active_positions:
                try:
                    for position in self.trader.active_positions.values():
                        await self.trader._update_position_in_db(position)
                    logging.info("âœ… í™œì„± í¬ì§€ì…˜ ì •ë³´ ì €ì¥ ì™„ë£Œ")
                except Exception as e:
                    logging.error(f"í™œì„± í¬ì§€ì…˜ ì €ì¥ ì˜¤ë¥˜: {e}")
            
            # ì—°ê²° ì •ë¦¬
            if self.redis_client:
                try:
                    await self.redis_client.close()
                    logging.info("âœ… Redis ì—°ê²° ì¢…ë£Œ")
                except Exception as e:
                    logging.error(f"Redis ì¢…ë£Œ ì˜¤ë¥˜: {e}")
            
            if self.postgres_pool:
                try:
                    await self.postgres_pool.close()
                    logging.info("âœ… PostgreSQL ì—°ê²° ì¢…ë£Œ")
                except Exception as e:
                    logging.error(f"PostgreSQL ì¢…ë£Œ ì˜¤ë¥˜: {e}")
            
            # ì¢…ë£Œ ì•Œë¦¼
            try:
                uptime = datetime.utcnow() - self.start_time
                await self.telegram.send_system_notification(
                    f"""ğŸ‘‹ <b>Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì¢…ë£Œ</b>
                    
â±ï¸ ìš´ì˜ ì‹œê°„: {uptime.days}ì¼ {uptime.seconds//3600}ì‹œê°„
ğŸ“Š ì´ ìš”ì²­: {self.request_count:,}íšŒ
âŒ ì´ ì˜¤ë¥˜: {self.error_count:,}íšŒ
ğŸ“ˆ ì„±ê³µë¥ : {((self.request_count - self.error_count) / max(self.request_count, 1) * 100):.1f}%

âœ… ì •ìƒ ì¢…ë£Œ ì™„ë£Œ""", 
                    "INFO"
                )
            except Exception as e:
                logging.warning(f"ì¢…ë£Œ ì•Œë¦¼ ì „ì†¡ ì‹¤íŒ¨: {e}")
            
            logging.info("ğŸ Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì •ë¦¬ ì™„ë£Œ")
            
        except Exception as e:
            logging.error(f"ğŸ’¥ ì‹œìŠ¤í…œ ì •ë¦¬ ì‹¤íŒ¨: {e}")
            logging.error(traceback.format_exc())
    
    async def _process_signal_complete(self, signal: TradingSignal):
        """ì™„ì „í•œ ì‹ í˜¸ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸ (ì™„ì „ ê°œì„ ë¨)"""
        processing_start = time.time()
        
        try:
            logging.info(f"ğŸ”„ ì‹ í˜¸ ì²˜ë¦¬ ì‹œì‘: {signal.signal_id} - {signal.symbol} {signal.action}")
            
            # 1. Phoenix 95 AI ë¶„ì„
            phoenix95_score, kelly_ratio, recommendation = await self.phoenix95_engine.analyze_signal_complete(signal)
            
            signal.phoenix95_score = phoenix95_score
            signal.kelly_ratio = kelly_ratio
            signal.recommendation = recommendation
            signal.processed = True
            signal.processing_time_ms = (time.time() - processing_start) * 1000
            
            logging.info(f"ğŸ§  AI ë¶„ì„ ì™„ë£Œ {signal.signal_id}: "
                        f"Phoenix95={phoenix95_score:.3f}, Kelly={kelly_ratio:.3f}, "
                        f"Rec={recommendation}, Time={signal.processing_time_ms:.0f}ms")
            
            # 2. ì¶”ì²œì´ ê±°ë˜ ê°€ëŠ¥í•œ ê²½ìš°ì—ë§Œ ì‹¤í–‰
            if recommendation in ["STRONG_BUY", "BUY", "WEAK_BUY"]:
                # 3. ê±°ë˜ ì‹¤í–‰
                position = await self.trader.execute_trade_complete(signal, phoenix95_score, kelly_ratio)
                
                if position:
                    logging.info(f"âœ… ê±°ë˜ ì‹¤í–‰ ì„±ê³µ: {position.position_id}")
                    
                    # Redisì— ì‹ í˜¸ ì²˜ë¦¬ ê²°ê³¼ ì €ì¥
                    await self.redis.hset(
                        f"signal:{signal.signal_id}",
                        mapping={
                            "status": "executed",
                            "position_id": position.position_id,
                            "processed_at": datetime.utcnow().isoformat()
                        }
                    )
                else:
                    logging.warning(f"âš ï¸ ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨: {signal.signal_id}")
                    await self.telegram.send_system_notification(
                        f"""âš ï¸ <b>ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨</b>
                        
ğŸ” ì‹ í˜¸: {signal.symbol} {signal.action.upper()}
ğŸ’° ê°€ê²©: ${Utils.format_number(signal.price)}
ğŸ§  Phoenix95: {Utils.format_percentage(phoenix95_score*100)}
âš–ï¸ Kelly: {Utils.format_percentage(kelly_ratio*100)}
âœ… ì¶”ì²œ: {recommendation}

âŒ ì‹¤í–‰ ë‹¨ê³„ì—ì„œ ì‹¤íŒ¨""", 
                        "WARNING"
                    )
            else:
                logging.info(f"âŒ ê±°ë˜ ê±°ë¶€ {signal.signal_id}: {recommendation}")
                await self.telegram.send_system_notification(
                    f"""ğŸ“Š <b>ì‹ í˜¸ ë¶„ì„ ì™„ë£Œ</b> (ê±°ë˜ ê±°ë¶€)

ğŸ” {signal.symbol} {signal.action.upper()}
ğŸ’° ê°€ê²©: ${Utils.format_number(signal.price)}
ğŸ§  Phoenix95: {Utils.format_percentage(phoenix95_score*100)}
âš–ï¸ Kelly: {Utils.format_percentage(kelly_ratio*100)}
âŒ ì¶”ì²œ: {recommendation}

ğŸ’¡ ê±°ë˜ ì¡°ê±´ ë¯¸ì¶©ì¡± (ì„ê³„ê°’: {Utils.format_percentage(SystemConfig.TRADING['confidence_threshold']*100)})""", 
                    "INFO"
                )
            
            # ì²˜ë¦¬ ì™„ë£Œ ë¡œê·¸
            total_time = (time.time() - processing_start) * 1000
            logging.info(f"ğŸ ì‹ í˜¸ ì²˜ë¦¬ ì™„ë£Œ {signal.signal_id}: {total_time:.0f}ms")
            
        except Exception as e:
            self.error_count += 1
            logging.error(f"ğŸ’¥ ì‹ í˜¸ ì²˜ë¦¬ ì‹¤íŒ¨ {signal.signal_id}: {e}")
            logging.error(traceback.format_exc())
            
            signal.processed = False
            signal.error_message = str(e)
            signal.processing_time_ms = (time.time() - processing_start) * 1000
            
            await self.telegram.send_system_notification(
                f"""ğŸš¨ <b>ì‹ í˜¸ ì²˜ë¦¬ ì˜¤ë¥˜</b>
                
ğŸ†” ì‹ í˜¸: {signal.signal_id}
ğŸ“Š ì‹¬ë³¼: {signal.symbol}
âŒ ì˜¤ë¥˜: {str(e)}
â±ï¸ ì²˜ë¦¬ ì‹œê°„: {signal.processing_time_ms:.0f}ms

ğŸ”§ ì‹œìŠ¤í…œ ì ê²€ì´ í•„ìš”í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤""", 
                "ERROR"
            )
    
    async def _monitoring_loop(self):
        """ëª¨ë‹ˆí„°ë§ ë£¨í”„ (ê°œì„ ë¨)"""
        logging.info("ğŸ“Š ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì‹œì‘")
        monitoring_errors = 0
        
        while True:
            try:
                # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
                metrics = await self.monitor.collect_system_metrics()
                
                if metrics:
                    # ì•Œë¦¼ ì²´í¬
                    await self.monitor.check_alerts(metrics)
                    
                    # Redisì— ìµœì‹  ë©”íŠ¸ë¦­ ì €ì¥
                    await self.redis_client.hset("system:metrics", mapping={
                        "cpu_usage": str(metrics.cpu_usage),
                        "memory_usage": str(metrics.memory_usage),
                        "active_positions": str(metrics.active_positions),
                        "total_pnl": str(metrics.total_pnl),
                        "timestamp": metrics.timestamp.isoformat()
                    })
                    
                    monitoring_errors = 0  # ì„±ê³µ ì‹œ ì˜¤ë¥˜ ì¹´ìš´íŠ¸ ë¦¬ì…‹
                else:
                    monitoring_errors += 1
                    if monitoring_errors > 5:
                        logging.error("ëª¨ë‹ˆí„°ë§ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ë°˜ë³µ ì‹¤íŒ¨")
                        await self.telegram.send_system_notification(
                            "ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì˜¤ë¥˜ê°€ ë°˜ë³µë˜ê³  ìˆìŠµë‹ˆë‹¤", 
                            "ERROR"
                        )
                        monitoring_errors = 0  # ì•Œë¦¼ í›„ ë¦¬ì…‹
                
                # 30ì´ˆë§ˆë‹¤ ì‹¤í–‰
                await asyncio.sleep(SystemConfig.MONITORING["metrics_interval"])
                
            except asyncio.CancelledError:
                logging.info("ğŸ“Š ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì·¨ì†Œë¨")
                break
            except Exception as e:
                monitoring_errors += 1
                logging.error(f"ğŸ’¥ ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì˜¤ë¥˜ (#{monitoring_errors}): {e}")
                
                if monitoring_errors <= 3:
                    await asyncio.sleep(60)  # 1ë¶„ ëŒ€ê¸°
                else:
                    await asyncio.sleep(300)  # 5ë¶„ ëŒ€ê¸° (ë°˜ë³µ ì˜¤ë¥˜ ì‹œ)
    
    async def _daily_summary_loop(self):
        """ì¼ì¼ ìš”ì•½ ë£¨í”„ (ì¶”ê°€ë¨)"""
        logging.info("ğŸ“ˆ ì¼ì¼ ìš”ì•½ ë£¨í”„ ì‹œì‘")
        
        while True:
            try:
                # ë‹¤ìŒ ìì •ê¹Œì§€ ëŒ€ê¸°
                now = datetime.utcnow()
                tomorrow = now.replace(hour=0, minute=0, second=0, microsecond=0) + timedelta(days=1)
                sleep_seconds = (tomorrow - now).total_seconds()
                
                logging.info(f"ë‹¤ìŒ ì¼ì¼ ìš”ì•½ê¹Œì§€ {sleep_seconds/3600:.1f}ì‹œê°„ ëŒ€ê¸°")
                await asyncio.sleep(sleep_seconds)
                
                # ì¼ì¼ ìš”ì•½ ìƒì„± ë° ì „ì†¡
                await self._send_daily_summary()
                
            except asyncio.CancelledError:
                logging.info("ğŸ“ˆ ì¼ì¼ ìš”ì•½ ë£¨í”„ ì·¨ì†Œë¨")
                break
            except Exception as e:
                logging.error(f"ğŸ’¥ ì¼ì¼ ìš”ì•½ ë£¨í”„ ì˜¤ë¥˜: {e}")
                await asyncio.sleep(3600)  # 1ì‹œê°„ í›„ ì¬ì‹œë„
    
    async def _send_daily_summary(self):
        """ì¼ì¼ ìš”ì•½ ì „ì†¡"""
        try:
            if not self.postgres_pool:
                return
            
            # ì–´ì œ í†µê³„ ì¡°íšŒ
            yesterday = datetime.utcnow().date() - timedelta(days=1)
            
            async with self.postgres_pool.acquire() as conn:
                stats = await conn.fetchrow("""
                    SELECT 
                        COUNT(*) as total_trades,
                        COUNT(*) FILTER (WHERE pnl > 0) as winning_trades,
                        COALESCE(SUM(pnl), 0) as total_pnl,
                        COALESCE(MAX(pnl), 0) as best_trade,
                        COALESCE(MIN(pnl), 0) as worst_trade,
                        COALESCE(AVG(duration_minutes), 0) as avg_duration
                    FROM trade_history 
                    WHERE DATE(entry_time) = $1
                """, yesterday)
                
                # í˜„ì¬ í™œì„± í¬ì§€ì…˜
                active_positions = await conn.fetchval(
                    "SELECT COUNT(*) FROM positions WHERE status = 'OPEN'"
                )
                
                # ì´ ë§ˆì§„ ì‚¬ìš©ëŸ‰ (í™œì„± í¬ì§€ì…˜)
                total_margin = await conn.fetchval("""
                    SELECT COALESCE(SUM(margin_required), 0) 
                    FROM positions WHERE status = 'OPEN'
                """)
            
            if stats:
                summary_stats = {
                    'total_trades': Utils.safe_int(stats['total_trades']),
                    'winning_trades': Utils.safe_int(stats['winning_trades']),
                    'total_pnl': Utils.safe_float(stats['total_pnl']),
                    'best_trade': Utils.safe_float(stats['best_trade']),
                    'worst_trade': Utils.safe_float(stats['worst_trade']),
                    'avg_duration': Utils.safe_int(stats['avg_duration']),
                    'active_positions': Utils.safe_int(active_positions),
                    'total_margin': Utils.safe_float(total_margin)
                }
                
                await self.telegram.send_daily_summary(summary_stats)
                logging.info(f"ğŸ“Š ì¼ì¼ ìš”ì•½ ì „ì†¡ ì™„ë£Œ: {yesterday}")
            else:
                logging.info(f"ğŸ“Š {yesterday} ê±°ë˜ ë°ì´í„° ì—†ìŒ")
                
        except Exception as e:
            logging.error(f"ğŸ’¥ ì¼ì¼ ìš”ì•½ ì „ì†¡ ì‹¤íŒ¨: {e}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸš€ ì„œë²„ ì‹¤í–‰ë¶€ (ì™„ì „ ê°œì„ ë¨)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def setup_logging():
    """ë¡œê¹… ì„¤ì • (ê°œì„ ë¨)"""
    log_level = getattr(logging, SystemConfig.MONITORING["log_level"].upper(), logging.INFO)
    log_file = SystemConfig.MONITORING["log_file"]
    
    # ë¡œê·¸ í¬ë§·í„°
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    )
    
    # ë£¨íŠ¸ ë¡œê±° ì„¤ì •
    root_logger = logging.getLogger()
    root_logger.setLevel(log_level)
    
    # ê¸°ì¡´ í•¸ë“¤ëŸ¬ ì œê±°
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)
    
    # ì½˜ì†” í•¸ë“¤ëŸ¬
    console_handler = logging.StreamHandler(sys.stdout)
    console_handler.setLevel(log_level)
    console_handler.setFormatter(formatter)
    root_logger.addHandler(console_handler)
    
    # íŒŒì¼ í•¸ë“¤ëŸ¬ (ë¡œí…Œì´ì…˜)
    try:
        from logging.handlers import RotatingFileHandler
        file_handler = RotatingFileHandler(
            log_file,
            maxBytes=SystemConfig.MONITORING["max_log_size"],
            backupCount=5,
            encoding='utf-8'
        )
        file_handler.setLevel(log_level)
        file_handler.setFormatter(formatter)
        root_logger.addHandler(file_handler)
    except Exception as e:
        logging.warning(f"íŒŒì¼ ë¡œê¹… ì„¤ì • ì‹¤íŒ¨: {e}")
    
    # ì™¸ë¶€ ë¼ì´ë¸ŒëŸ¬ë¦¬ ë¡œê·¸ ë ˆë²¨ ì¡°ì •
    logging.getLogger("uvicorn").setLevel(logging.WARNING)
    logging.getLogger("asyncpg").setLevel(logging.WARNING)
    logging.getLogger("aioredis").setLevel(logging.WARNING)

def setup_signal_handlers(phoenix95_system):
    """ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ ì„¤ì • (ì¶”ê°€ë¨)"""
    def signal_handler(signum, frame):
        logging.info(f"ì‹ í˜¸ {signum} ìˆ˜ì‹  - ì •ìƒ ì¢…ë£Œ ì‹œì‘")
        
        # ë¹„ë™ê¸° ì •ë¦¬ ì‘ì—…ì„ ìœ„í•œ ìƒˆ ì´ë²¤íŠ¸ ë£¨í”„
        loop = asyncio.new_event_loop()
        asyncio.set_event_loop(loop)
        try:
            loop.run_until_complete(phoenix95_system.cleanup())
        except Exception as e:
            logging.error(f"ì •ë¦¬ ì‘ì—… ì¤‘ ì˜¤ë¥˜: {e}")
        finally:
            loop.close()
        
        sys.exit(0)
    
    # SIGINT (Ctrl+C), SIGTERM í•¸ë“¤ëŸ¬ ë“±ë¡
    signal.signal(signal.SIGINT, signal_handler)
    signal.signal(signal.SIGTERM, signal_handler)

async def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜ (ì™„ì „ ê°œì„ ë¨)"""
    # ì‹œì‘ ë©”ì‹œì§€
    print("=" * 80)
    print("ğŸ¯ Phoenix 95 Ultimate Trading System - ì™„ì „ í†µí•© ìµœì¢… ë²„ì „")
    print("ğŸ’° V3 ê²€ì¦ëœ ì•Œê³ ë¦¬ì¦˜ + V4 ê³ ê¸‰ ê¸°ëŠ¥ + í—¤ì§€í€ë“œê¸‰ ì•ˆì „ì„±")
    print("âš¡ Wall Streetê¸‰ íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ + ì™„ì „í•œ ì˜¤ë¥˜ ìˆ˜ì •")
    print("ğŸ”§ ëª¨ë“  ê¸°ëŠ¥ì´ í•˜ë‚˜ì˜ íŒŒì¼ì— í†µí•©ëœ ì™„ì„±í’ˆ")
    print("=" * 80)
    
    # ë¡œê¹… ì„¤ì •
    setup_logging()
    logging.info("Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì‹œì‘")
    
    # í™˜ê²½ ë³€ìˆ˜ í™•ì¸
    required_env_vars = {
        "TELEGRAM_BOT_TOKEN": "í…”ë ˆê·¸ë¨ ë´‡ í† í°",
        "TELEGRAM_CHAT_ID": "í…”ë ˆê·¸ë¨ ì±„íŒ… ID"
    }
    
    missing_vars = []
    for var, desc in required_env_vars.items():
        if not os.getenv(var):
            missing_vars.append(f"{var} ({desc})")
    
    if missing_vars:
        logging.warning(f"âš ï¸ ëˆ„ë½ëœ í™˜ê²½ ë³€ìˆ˜: {', '.join(missing_vars)}")
        logging.warning("ê¸°ë³¸ê°’ìœ¼ë¡œ ì‹¤í–‰í•˜ì§€ë§Œ ì¼ë¶€ ê¸°ëŠ¥ì´ ì œí•œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤")
    
    # Phoenix 95 ì‹œìŠ¤í…œ ìƒì„±
    phoenix95_system = Phoenix95UltimateSystem()
    
    # ì‹œê·¸ë„ í•¸ë“¤ëŸ¬ ì„¤ì •
    setup_signal_handlers(phoenix95_system)
    
    # ì„œë²„ ì„¤ì •
    host = os.getenv("HOST", "0.0.0.0")
    port = int(os.getenv("PORT", "8080"))
    
    logging.info(f"ğŸš€ ì„œë²„ ì‹œì‘: http://{host}:{port}")
    
    # FastAPI ì„œë²„ ì‹¤í–‰
    config = uvicorn.Config(
        phoenix95_system.app,
        host=host,
        port=port,
        log_level="warning",  # uvicorn ë¡œê·¸ëŠ” ê²½ê³ ë§Œ
        access_log=False,     # ì•¡ì„¸ìŠ¤ ë¡œê·¸ëŠ” ìš°ë¦¬ê°€ ì§ì ‘ ì²˜ë¦¬
        loop="asyncio"
    )
    
    server = uvicorn.Server(config)
    
    try:
        await server.serve()
    except KeyboardInterrupt:
        logging.info("ğŸ›‘ í‚¤ë³´ë“œ ì¸í„°ëŸ½íŠ¸ ìˆ˜ì‹ ")
    except Exception as e:
        logging.error(f"ğŸ’¥ ì„œë²„ ì‹¤í–‰ ì˜¤ë¥˜: {e}")
        logging.error(traceback.format_exc())
        raise

if __name__ == "__main__":
    try:
        # Python ë²„ì „ ì²´í¬
        if sys.version_info < (3, 8):
            print("âŒ Python 3.8 ì´ìƒì´ í•„ìš”í•©ë‹ˆë‹¤")
            sys.exit(1)
        
        # í•„ìˆ˜ íŒ¨í‚¤ì§€ import ì²´í¬
        try:
            import numpy
            import pandas
            import fastapi
            import uvicorn
            import aiohttp
            import aioredis
            import asyncpg
        except ImportError as e:
            print(f"âŒ í•„ìˆ˜ íŒ¨í‚¤ì§€ ëˆ„ë½: {e}")
            print("pip install -r requirements.txt ë¥¼ ì‹¤í–‰í•˜ì„¸ìš”")
            sys.exit(1)
        
        # ë©”ì¸ ì‹¤í–‰
        asyncio.run(main())
        
    except KeyboardInterrupt:
        print("\nğŸ‘‹ Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì¢…ë£Œ (ì‚¬ìš©ì ìš”ì²­)")
    except Exception as e:
        print(f"\nğŸ’¥ ì‹œìŠ¤í…œ ì¹˜ëª…ì  ì˜¤ë¥˜: {e}")
        logging.error(traceback.format_exc())
        sys.exit(1)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“‹ ì™„ì „ í†µí•© ë°°í¬ ì„¤ì •
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
=== ì™„ì „í•œ ë°°í¬ íŒ¨í‚¤ì§€ ===

1. requirements.txt ===
fastapi==0.104.1
uvicorn[standard]==0.24.0
asyncpg==0.29.0
aioredis==2.0.1
aiohttp==3.9.1
numpy==1.24.4
pandas==2.0.3
psutil==5.9.6
python-multipart==0.0.6
pydantic==2.4.2

2. docker-compose.yml ===
version: '3.8'
services:
  postgres:
    image: postgres:15-alpine
    container_name: phoenix95_ultimate_postgres
    environment:
      POSTGRES_DB: phoenix95
      POSTGRES_USER: postgres
      POSTGRES_PASSWORD: password
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U postgres"]
      interval: 30s
      timeout: 10s
      retries: 3

  redis:
    image: redis:7-alpine
    container_name: phoenix95_ultimate_redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "redis-cli", "ping"]
      interval: 30s
      timeout: 5s
      retries: 3

  phoenix95_ultimate:
    build: .
    container_name: phoenix95_ultimate_system
    ports:
      - "8080:8080"
    environment:
      - POSTGRES_URL=postgresql://postgres:password@postgres:5432/phoenix95
      - REDIS_URL=redis://redis:6379
      - ACCOUNT_BALANCE=50000
      - LOG_LEVEL=INFO
      - TELEGRAM_BOT_TOKEN=${TELEGRAM_BOT_TOKEN}
      - TELEGRAM_CHAT_ID=${TELEGRAM_CHAT_ID}
    depends_on:
      postgres:
        condition: service_healthy
      redis:
        condition: service_healthy
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:8080/health"]
      interval: 30s
      timeout: 10s
      retries: 3

volumes:
  postgres_data:
  redis_data:

3. Dockerfile ===
FROM python:3.11-slim

WORKDIR /app

# ì‹œìŠ¤í…œ íŒ¨í‚¤ì§€ ì„¤ì¹˜
RUN apt-get update && apt-get install -y \
    curl \
    gcc \
    && rm -rf /var/lib/apt/lists/*

# Python íŒ¨í‚¤ì§€ ì„¤ì¹˜
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# ì• í”Œë¦¬ì¼€ì´ì…˜ ë³µì‚¬
COPY phoenix95_ultimate_complete.py .

# í¬íŠ¸ ë…¸ì¶œ
EXPOSE 8080

# í—¬ìŠ¤ì²´í¬
HEALTHCHECK --interval=30s --timeout=10s --retries=3 \
    CMD curl -f http://localhost:8080/health || exit 1

# ì‹œì‘ ëª…ë ¹
CMD ["python", "phoenix95_ultimate_complete.py"]

4. .env.example ===
# í•„ìˆ˜ ì„¤ì •
TELEGRAM_BOT_TOKEN=your_bot_token_here
TELEGRAM_CHAT_ID=your_chat_id_here

# ì„ íƒì  ì„¤ì •
ACCOUNT_BALANCE=50000
MAX_LEVERAGE=10
MAX_POSITIONS=3
CONFIDENCE_THRESHOLD=0.85
MAX_DAILY_LOSS=1000

# ë°ì´í„°ë² ì´ìŠ¤ (Docker ì‚¬ìš©ì‹œ ê¸°ë³¸ê°’ ì‚¬ìš©)
POSTGRES_URL=postgresql://postgres:password@localhost:5432/phoenix95
REDIS_URL=redis://localhost:6379

# ë¡œê¹…
LOG_LEVEL=INFO
LOG_FILE=phoenix95_ultimate.log

5. deploy_ultimate.sh ===
#!/bin/bash

echo "ğŸ¯ Phoenix 95 Ultimate Trading System ì™„ì „ ë°°í¬"
echo "=============================================="

# í™˜ê²½ ë³€ìˆ˜ íŒŒì¼ ì²´í¬
if [ ! -f .env ]; then
    echo "âŒ .env íŒŒì¼ì´ ì—†ìŠµë‹ˆë‹¤"
    echo "ğŸ’¡ .env.exampleì„ ë³µì‚¬í•˜ì—¬ .envë¥¼ ë§Œë“¤ê³  ì„¤ì •ì„ ì…ë ¥í•˜ì„¸ìš”"
    exit 1
fi

# Dockerì™€ Docker Compose ì²´í¬
if ! command -v docker &> /dev/null; then
    echo "âŒ Dockerê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"
    exit 1
fi

if ! command -v docker-compose &> /dev/null; then
    echo "âŒ Docker Composeê°€ ì„¤ì¹˜ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤"
    exit 1
fi

# ê¸°ì¡´ ì»¨í…Œì´ë„ˆ ì •ë¦¬
echo "ğŸ§¹ ê¸°ì¡´ ì»¨í…Œì´ë„ˆ ì •ë¦¬..."
docker-compose down -v 2>/dev/null || true

# ì´ë¯¸ì§€ ë¹Œë“œ
echo "ğŸ”¨ ì´ë¯¸ì§€ ë¹Œë“œ..."
docker-compose build --no-cache

# ì»¨í…Œì´ë„ˆ ì‹œì‘
echo "ğŸš€ ì»¨í…Œì´ë„ˆ ì‹œì‘..."
docker-compose up -d

# ì‹œìŠ¤í…œ ì¤€ë¹„ ëŒ€ê¸°
echo "â³ ì‹œìŠ¤í…œ ì¤€ë¹„ ëŒ€ê¸° ì¤‘..."
for i in {1..60}; do
    if curl -s http://localhost:8080/health >/dev/null 2>&1; then
        echo "âœ… Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ!"
        break
    fi
    echo -n "."
    sleep 5
done

# ìµœì¢… ìƒíƒœ í™•ì¸
echo ""
echo "ğŸ“Š ì‹œìŠ¤í…œ ìƒíƒœ í™•ì¸..."
docker-compose ps

echo ""
echo "ğŸ‰ ë°°í¬ ì™„ë£Œ!"
echo "ğŸ“ ì—”ë“œí¬ì¸íŠ¸:"
echo "   - í—¬ìŠ¤ì²´í¬: http://localhost:8080/health"
echo "   - í¬ì§€ì…˜ ì¡°íšŒ: http://localhost:8080/positions"
echo "   - ì„±ëŠ¥ í†µê³„: http://localhost:8080/performance"
echo "   - ê´€ë¦¬ íŒ¨ë„: http://localhost:8080/admin/system_status"
echo ""
echo "ğŸ”§ TradingView ì›¹í›… URL:"
echo "   http://your-server-ip:8080/webhook/tradingview"
echo ""
echo "ğŸ“± í…”ë ˆê·¸ë¨ ì•Œë¦¼ì´ ì„¤ì •ë˜ì–´ ìˆìœ¼ë©´ ì‹œì‘ ë©”ì‹œì§€ë¥¼ ë°›ì„ ê²ƒì…ë‹ˆë‹¤"

6. ì‚¬ìš©ë²• ===

1) í™˜ê²½ ì„¤ì •:
   cp .env.example .env
   # .env íŒŒì¼ì„ í¸ì§‘í•˜ì—¬ í…”ë ˆê·¸ë¨ ì„¤ì • ì…ë ¥

2) ê¶Œí•œ ì„¤ì •:
   chmod +x deploy_ultimate.sh

3) ë°°í¬ ì‹¤í–‰:
   ./deploy_ultimate.sh

4) TradingView ì„¤ì •:
   - ì›¹í›… URL: http://your-server:8080/webhook/tradingview
   - ë©”ì‹œì§€ í˜•ì‹:
   {
     "symbol": "{{ticker}}",
     "action": "{{strategy.order.action}}",
     "price": {{close}},
     "confidence": 0.85
   }

5) ëª¨ë‹ˆí„°ë§:
   - ë¡œê·¸ í™•ì¸: docker-compose logs -f phoenix95_ultimate
   - í¬ì§€ì…˜ ì¡°íšŒ: curl http://localhost:8080/positions
   - ì‹œìŠ¤í…œ ìƒíƒœ: curl http://localhost:8080/health

=== ì£¼ìš” íŠ¹ì§• ===

âœ… ì™„ì „í•œ ì˜¤ë¥˜ ìˆ˜ì • ë° ì˜ˆì™¸ ì²˜ë¦¬
âœ… ì‹¤ì‹œê°„ í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§  
âœ… ìë™ ë¦¬ìŠ¤í¬ ê´€ë¦¬
âœ… í…”ë ˆê·¸ë¨ ì‹¤ì‹œê°„ ì•Œë¦¼
âœ… í—¤ì§€í€ë“œê¸‰ ì•ˆì „ ì¥ì¹˜
âœ… Phoenix 95 AI ì—”ì§„
âœ… Kelly Criterion í¬ì§€ì…˜ ì‚¬ì´ì§•
âœ… ë°ì´í„°ë² ì´ìŠ¤ ìë™ ë°±ì—…
âœ… ì›í´ë¦­ ë°°í¬
âœ… 24/7 ëª¨ë‹ˆí„°ë§
âœ… ì¼ì¼ ì„±ê³¼ ìš”ì•½
âœ… ì‘ê¸‰ ì²­ì‚° ê¸°ëŠ¥
âœ… ë³€ë™ì„± ì ì‘í˜• ë ˆë²„ë¦¬ì§€
âœ… ì™„ì „í•œ ë¡œê¹… ì‹œìŠ¤í…œ

ğŸ¯ ì´ì œ ì™„ì „íˆ ì‘ë™í•˜ëŠ” í—¤ì§€í€ë“œê¸‰ íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œì…ë‹ˆë‹¤!
"""
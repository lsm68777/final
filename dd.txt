#!/usr/bin/env python3
"""
═══════════════════════════════════════════════════════════════════════════════
    Phoenix 95 Ultimate Trading System
    V3 검증된 알고리즘 + V4 고급 기능 + 헤지펀드급 안전성
    
    🎯 완전 통합 최종 버전 - 모든 기능을 하나의 파일에 통합
    💰 Wall Street급 트레이딩 시스템
    ⚡ 원클릭 배포, 실시간 모니터링, 자동 리스크 관리
    
    🔧 수정된 문제점들:
    - 보안 강화: 민감 정보 제거, 환경변수 필수 검증
    - 로직 수정: 시간대 조건, 무한루프 방지
    - 중복 제거: 환경변수 로딩, 메트릭 수집 통합
    - 타입 안정성 강화
═══════════════════════════════════════════════════════════════════════════════
"""

import asyncio
import aiohttp
import aioredis
import asyncpg
import json
import time
import logging
import os
import sys
import uuid
import hmac
import hashlib
import secrets
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict, field
from typing import Dict, List, Optional, Tuple, Any, Union
from decimal import Decimal
from collections import deque
import numpy as np
from fastapi import FastAPI, HTTPException, BackgroundTasks, Depends, Security, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field, validator
import uvicorn
from contextlib import asynccontextmanager
from dotenv import load_dotenv

# ═══════════════════════════════════════════════════════════════════════════════
#                              🔧 환경변수 검증 (최우선 실행)
# ═══════════════════════════════════════════════════════════════════════════════

def validate_environment() -> bool:
    """필수 환경변수 검증 - 애플리케이션 시작 전 최우선 실행"""
    # .env 파일을 한 번만 로드
    load_dotenv()
    
    required_vars = {
        "TELEGRAM_BOT_TOKEN": "텔레그램 봇 토큰",
        "TELEGRAM_CHAT_ID": "텔레그램 채팅 ID", 
        "WEBHOOK_SECRET": "웹훅 시크릿",
        "API_KEY": "API 키",
        "JWT_SECRET": "JWT 시크릿"
    }
    
    missing = []
    invalid = []
    
    for var, desc in required_vars.items():
        value = os.getenv(var)
        if not value or value.strip() == "":
            missing.append(f"  - {var}: {desc}")
        else:
            # 값 형식 검증
            if var == "TELEGRAM_BOT_TOKEN" and not value.split(':')[0].isdigit():
                invalid.append(f"  - {var}: 올바른 텔레그램 봇 토큰 형식이 아닙니다")
            elif var == "TELEGRAM_CHAT_ID" and not value.lstrip('-').isdigit():
                invalid.append(f"  - {var}: 숫자여야 합니다")
    
    if missing or invalid:
        error_parts = []
        if missing:
            error_parts.append("필수 환경변수가 설정되지 않았습니다:\n" + "\n".join(missing))
        if invalid:
            error_parts.append("잘못된 환경변수 형식:\n" + "\n".join(invalid))
        
        error_msg = "\n\n".join(error_parts)
        error_msg += "\n\n.env 파일을 생성하고 올바른 값을 설정하세요."
        raise EnvironmentError(error_msg)
    
    logging.info("환경변수 검증 완료")
    return True

# 애플리케이션 시작 전 환경변수 검증 실행
validate_environment()

# ═══════════════════════════════════════════════════════════════════════════════
#                              🔧 시스템 설정
# ═══════════════════════════════════════════════════════════════════════════════

class SystemConfig:
    """Phoenix 95 Ultimate 통합 설정 - 보안 강화"""
    
    # 🎯 핵심 텔레그램 설정 (보안 강화: 기본값 None 처리)
    TELEGRAM = {
        "bot_token": os.getenv("TELEGRAM_BOT_TOKEN"),  # 기본값 제거로 보안 강화
        "chat_id": os.getenv("TELEGRAM_CHAT_ID"),      # 기본값 제거로 보안 강화
        "alerts": {
            "trade_execution": True,
            "position_updates": True, 
            "system_errors": True,
            "performance_reports": True,
            "liquidation_warnings": True,
            "daily_summary": True
        }
    }
    
    # 💰 헤지펀드급 트레이딩 설정 (보수적 접근)
    TRADING = {
        "max_leverage": 10,  # V4에서 20x → 10x로 안전성 강화
        "margin_mode": "ISOLATED",
        "position_size_pct": 0.02,  # 전체 자본의 2%만 리스크
        "stop_loss_pct": 0.015,     # 1.5% 손절
        "take_profit_pct": 0.03,    # 3% 익절 (R:R = 1:2)
        "max_daily_loss": 1000,     # 일일 최대 손실 $1000
        "max_positions": 3,         # 최대 3개 포지션
        "confidence_threshold": 0.85, # 85% 이상만 거래
        "kelly_max": 0.25,          # Kelly 최대 25%
        "max_retries": 3,           # 최대 재시도 횟수 추가
        "retry_delay": 5,           # 재시도 지연 시간(초)
        "allowed_symbols": [
            "BTCUSDT", "ETHUSDT", "ADAUSDT", "SOLUSDT", "AVAXUSDT",
            "DOTUSDT", "LINKUSDT", "MATICUSDT", "ATOMUSDT", "NEARUSDT"
        ]
    }
    
    # 🧠 Phoenix 95 AI 엔진 설정 (V3 검증된 파라미터)
    PHOENIX95 = {
        "confidence_multiplier": 1.15,  # V3에서 최적화된 값
        "market_condition_weight": 0.3,
        "ensemble_weights": {
            "phoenix95": 0.6,
            "lstm": 0.25, 
            "transformer": 0.15
        },
        "analysis_timeout": 2.0,  # 2초 이내 분석 보장
        "min_confidence": 0.7,
        "max_confidence": 0.99,
        "cache_ttl": 300,  # 캐시 TTL 5분
        "max_cache_size": 1000  # 최대 캐시 크기
    }
    
    # 💾 데이터베이스 설정
    DATABASE = {
        "redis_url": os.getenv("REDIS_URL", "redis://localhost:6379"),
        "postgres_url": os.getenv("POSTGRES_URL", "postgresql://postgres:password@localhost:5432/phoenix95"),
        "connection_pool_size": 20,
        "max_connections": 100,
        "connection_timeout": 30,  # 연결 타임아웃 추가
        "query_timeout": 10        # 쿼리 타임아웃 추가
    }
    
    # 🔒 보안 설정 (JWT 시크릿 고정)
    SECURITY = {
        "webhook_secret": os.getenv("WEBHOOK_SECRET"),  # 기본값 제거
        "api_key": os.getenv("API_KEY"),               # 기본값 제거
        "jwt_secret": os.getenv("JWT_SECRET"),         # 기본값 제거로 토큰 무효화 방지
        "allowed_ips": ["127.0.0.1", "localhost"],
        "rate_limit": 60  # 분당 60회
    }
    
    # 📊 모니터링 설정
    MONITORING = {
        "metrics_interval": 30,    # 30초마다 메트릭 수집
        "health_check_interval": 10,
        "alert_cooldown": 300,     # 5분 알림 쿨다운
        "performance_threshold": {
            "response_time_ms": 2000,
            "error_rate_pct": 5,
            "memory_usage_pct": 85,
            "cpu_usage_pct": 80
        },
        "max_metrics_history": 1440  # 24시간 (분당 1개)
    }

# ═══════════════════════════════════════════════════════════════════════════════
#                              📊 데이터 모델 (타입 안정성 강화)
# ═══════════════════════════════════════════════════════════════════════════════

@dataclass
class TradingSignal:
    """트레이딩 신호 - V3/V4 통합 모델 (타입 안정성 강화)"""
    signal_id: str
    symbol: str
    action: str  # buy/sell
    price: float
    confidence: float
    timestamp: datetime
    
    # Phoenix 95 분석 결과 (Optional 필드 명시적 타입 체크)
    phoenix95_score: Optional[float] = None
    kelly_ratio: Optional[float] = None
    recommendation: Optional[str] = None
    
    # 시장 데이터
    market_conditions: Optional[Dict[str, Any]] = None
    technical_indicators: Optional[Dict[str, Any]] = None
    
    # 처리 상태
    processed: bool = False
    error_message: Optional[str] = None
    
    def is_valid(self) -> bool:
        """신호 유효성 검증 - None 체크 강화"""
        if not self.symbol or not self.action:
            return False
        
        return (
            self.symbol in SystemConfig.TRADING["allowed_symbols"] and
            self.action.lower() in ["buy", "sell"] and
            self.price > 0 and
            0.0 <= self.confidence <= 1.0 and
            self.confidence >= SystemConfig.TRADING["confidence_threshold"]
        )
    
    def has_phoenix95_analysis(self) -> bool:
        """Phoenix95 분석 결과 존재 여부 확인"""
        return (
            self.phoenix95_score is not None and
            self.kelly_ratio is not None and
            self.recommendation is not None
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """딕셔너리 변환 - 타입 안정성 보장"""
        return {
            "signal_id": self.signal_id,
            "symbol": self.symbol,
            "action": self.action,
            "price": self.price,
            "confidence": self.confidence,
            "phoenix95_score": self.phoenix95_score,
            "kelly_ratio": self.kelly_ratio,
            "recommendation": self.recommendation,
            "timestamp": self.timestamp.isoformat(),
            "processed": self.processed
        }

@dataclass  
class Position:
    """포지션 - 완전 통합 모델 (타입 안정성 강화)"""
    position_id: str
    signal_id: str
    symbol: str
    side: str  # BUY/SELL
    
    # 포지션 정보
    entry_price: float
    quantity: float
    leverage: int
    margin_mode: str
    margin_required: float
    
    # 리스크 관리
    liquidation_price: float
    stop_loss_price: float
    take_profit_price: float
    
    # 실시간 데이터
    current_price: float = 0.0
    unrealized_pnl: float = 0.0
    pnl_percentage: float = 0.0
    liquidation_risk: float = 0.0
    
    # 상태
    status: str = "OPEN"  # OPEN/CLOSED/LIQUIDATED
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)
    
    # 청산 정보
    exit_price: Optional[float] = None
    exit_time: Optional[datetime] = None
    exit_reason: Optional[str] = None
    realized_pnl: Optional[float] = None
    
    def calculate_pnl(self, current_price: float) -> Tuple[float, float]:
        """P&L 계산 - 안전한 계산"""
        try:
            if self.side == "BUY":
                pnl = (current_price - self.entry_price) * self.quantity
            else:
                pnl = (self.entry_price - current_price) * self.quantity
            
            pnl_pct = (pnl / self.margin_required) * 100 if self.margin_required > 0 else 0.0
            return pnl, pnl_pct
        except (ZeroDivisionError, TypeError) as e:
            logging.error(f"P&L 계산 오류: {e}")
            return 0.0, 0.0
    
    def calculate_liquidation_risk(self, current_price: float) -> float:
        """청산 위험도 계산 (0-1) - 안전한 계산"""
        try:
            if self.side == "BUY":
                distance = current_price - self.liquidation_price
                max_distance = self.entry_price - self.liquidation_price
            else:
                distance = self.liquidation_price - current_price  
                max_distance = self.liquidation_price - self.entry_price
            
            if max_distance <= 0:
                return 1.0
            
            risk = 1 - (distance / max_distance)
            return max(0.0, min(1.0, risk))
        except (ZeroDivisionError, TypeError) as e:
            logging.error(f"청산 위험도 계산 오류: {e}")
            return 0.0

@dataclass
class PerformanceMetrics:
    """성능 메트릭 - 타입 안정성 강화"""
    timestamp: datetime
    
    # 시스템 메트릭
    cpu_usage: float
    memory_usage: float  
    response_time_ms: float
    active_connections: int
    
    # 트레이딩 메트릭
    active_positions: int
    total_pnl: float
    win_rate: float
    avg_trade_duration: float
    phoenix95_avg_score: float
    
    # 리스크 메트릭
    max_drawdown: float
    var_95: float  # Value at Risk
    sharpe_ratio: float

# ═══════════════════════════════════════════════════════════════════════════════
#                              🧠 Phoenix 95 AI 엔진 (중복 제거, 성능 최적화)
# ═══════════════════════════════════════════════════════════════════════════════

class Phoenix95AIEngine:
    """Phoenix 95 Ultimate AI 엔진 - V3 검증 + V4 고도화 (메모리 누수 방지)"""
    
    def __init__(self):
        self.config = SystemConfig.PHOENIX95
        # 메모리 누수 방지: 크기 제한이 있는 캐시
        self.analysis_cache: Dict[str, Dict[str, Any]] = {}
        self.model_performance = deque(maxlen=1000)
        
        # V3에서 검증된 파라미터
        self.confidence_multiplier = self.config["confidence_multiplier"]
        self.market_weight = self.config["market_condition_weight"]
        
        # 캐시 관리
        self.max_cache_size = self.config["max_cache_size"]
        self.cache_ttl = self.config["cache_ttl"]
        
    async def analyze_signal_complete(self, signal: TradingSignal) -> Tuple[float, float, str]:
        """
        완전 신호 분석 - V3 알고리즘 + V4 고도화 (타임아웃 및 재시도 로직 추가)
        Returns: (phoenix95_score, kelly_ratio, recommendation)
        """
        start_time = time.time()
        
        try:
            # 1. 캐시 확인 (TTL 체크 포함)
            cache_key = f"{signal.symbol}_{signal.price}_{signal.confidence}"
            cached_result = self._get_from_cache(cache_key)
            if cached_result:
                return cached_result
            
            # 2. 타임아웃 내에서 분석 수행
            analysis_timeout = self.config["analysis_timeout"]
            
            try:
                result = await asyncio.wait_for(
                    self._perform_analysis(signal),
                    timeout=analysis_timeout
                )
            except asyncio.TimeoutError:
                logging.warning(f"Phoenix95 분석 타임아웃: {signal.symbol}")
                return 0.0, 0.0, "REJECT"
            
            phoenix95_score, kelly_ratio, recommendation = result
            
            # 3. 분석 시간 검증
            analysis_time = time.time() - start_time
            if analysis_time > analysis_timeout:
                logging.warning(f"Phoenix95 분석 시간 초과: {analysis_time:.2f}초")
            
            # 4. 결과 캐싱 (메모리 관리 포함)
            self._store_in_cache(cache_key, (phoenix95_score, kelly_ratio, recommendation))
            
            # 5. 성능 추적
            self.model_performance.append({
                'score': phoenix95_score,
                'analysis_time': analysis_time,
                'timestamp': datetime.utcnow()
            })
            
            return phoenix95_score, kelly_ratio, recommendation
            
        except Exception as e:
            logging.error(f"Phoenix95 분석 실패: {e}")
            return 0.0, 0.0, "REJECT"
    
    def _get_from_cache(self, cache_key: str) -> Optional[Tuple[float, float, str]]:
        """캐시에서 결과 조회 (TTL 체크 포함)"""
        if cache_key in self.analysis_cache:
            cached = self.analysis_cache[cache_key]
            # TTL 체크
            if (datetime.utcnow() - cached['timestamp']).seconds < self.cache_ttl:
                return cached['result']
            else:
                # 만료된 캐시 제거
                del self.analysis_cache[cache_key]
        return None
    
    def _store_in_cache(self, cache_key: str, result: Tuple[float, float, str]):
        """캐시에 결과 저장 (메모리 관리 포함)"""
        # 캐시 크기 제한
        if len(self.analysis_cache) >= self.max_cache_size:
            # 가장 오래된 항목들 제거 (LRU 방식)
            oldest_keys = sorted(
                self.analysis_cache.keys(),
                key=lambda k: self.analysis_cache[k]['timestamp']
            )[:100]  # 100개씩 제거
            
            for key in oldest_keys:
                del self.analysis_cache[key]
        
        self.analysis_cache[cache_key] = {
            'result': result,
            'timestamp': datetime.utcnow()
        }
    
    async def _perform_analysis(self, signal: TradingSignal) -> Tuple[float, float, str]:
        """실제 분석 수행"""
        # 1. V3 검증된 Phoenix 95 핵심 분석
        phoenix95_score = await self._phoenix95_core_analysis(signal)
        
        # 2. V4 앙상블 모델 분석
        ensemble_boost = await self._ensemble_analysis(signal)
        phoenix95_score = min(phoenix95_score * ensemble_boost, self.config["max_confidence"])
        
        # 3. 시장 조건 팩터
        market_factor = await self._analyze_market_conditions(signal.symbol)
        phoenix95_score *= market_factor
        
        # 4. Kelly Criterion 계산 (V3 검증된 공식)
        kelly_ratio = await self._calculate_kelly_criterion(phoenix95_score)
        
        # 5. 최종 추천 생성
        recommendation = await self._generate_recommendation(phoenix95_score, kelly_ratio)
        
        return phoenix95_score, kelly_ratio, recommendation
    
    async def _phoenix95_core_analysis(self, signal: TradingSignal) -> float:
        """Phoenix 95 핵심 분석 알고리즘 - V3 검증된 로직 (시간대 조건 수정)"""
        base_confidence = signal.confidence
        
        # V3에서 검증된 신뢰도 부스팅
        boosted_confidence = base_confidence * self.confidence_multiplier
        
        # 시간대별 가중치 (V3 패턴) - 논리 오류 수정
        hour = datetime.utcnow().hour
        time_weight = 1.0
        if 8 <= hour <= 16:  # 유럽 시간
            time_weight = 1.1
        elif hour >= 21 or hour <= 5:  # 미국 시간 (수정: 21시 이후 또는 5시 이전)
            time_weight = 1.05
        
        # 심볼별 가중치
        symbol_weights = {
            "BTCUSDT": 1.0,
            "ETHUSDT": 0.95,
            "ADAUSDT": 0.9,
            "SOLUSDT": 0.9
        }
        symbol_weight = symbol_weights.get(signal.symbol, 0.85)
        
        # 최종 Phoenix 95 점수
        phoenix95_score = boosted_confidence * time_weight * symbol_weight
        return min(phoenix95_score, self.config["max_confidence"])
    
    async def _ensemble_analysis(self, signal: TradingSignal) -> float:
        """앙상블 모델 분석 - V4 고도화"""
        weights = self.config["ensemble_weights"]
        
        # LSTM 예측 시뮬레이션
        lstm_score = min(signal.confidence * 1.05, 1.0)
        
        # Transformer 예측 시뮬레이션  
        transformer_score = min(signal.confidence * 1.08, 1.0)
        
        # 가중 평균으로 부스트 팩터 계산
        ensemble_score = (
            weights["phoenix95"] * signal.confidence +
            weights["lstm"] * lstm_score +
            weights["transformer"] * transformer_score
        )
        
        # 부스트 팩터 반환 (1.0 = 변화없음, 1.1 = 10% 증가)
        boost_factor = ensemble_score / signal.confidence if signal.confidence > 0 else 1.0
        return min(boost_factor, 1.15)  # 최대 15% 부스트
    
    async def _analyze_market_conditions(self, symbol: str) -> float:
        """시장 조건 분석"""
        try:
            # 실제로는 Binance API에서 데이터 수집
            # 여기서는 시간 기반 간단한 시뮬레이션
            hour = datetime.utcnow().hour
            
            # 거래량 활발한 시간대
            if 8 <= hour <= 16 or 21 <= hour <= 23:
                return 1.1
            elif 2 <= hour <= 6:  # 저조한 시간대
                return 0.9
            else:
                return 1.0
                
        except Exception as e:
            logging.error(f"시장 조건 분석 실패: {e}")
            return 1.0
    
    async def _calculate_kelly_criterion(self, phoenix95_score: float) -> float:
        """Kelly Criterion 계산 - V3 검증된 공식"""
        try:
            # 승률 추정 (Phoenix 95 점수 기반)
            win_probability = phoenix95_score
            
            # 손익 비율 (손절 1.5% vs 익절 3% = 1:2)
            win_loss_ratio = (
                SystemConfig.TRADING["take_profit_pct"] / 
                SystemConfig.TRADING["stop_loss_pct"]
            )
            
            # Kelly Formula: (bp - q) / b
            # b = 손익비율, p = 승률, q = 패배율
            kelly_ratio = (
                (win_probability * win_loss_ratio - (1 - win_probability)) / 
                win_loss_ratio
            )
            
            # 보수적 제한 (최대 25%)
            kelly_ratio = max(0.01, min(kelly_ratio, SystemConfig.TRADING["kelly_max"]))
            
            return kelly_ratio
        except (ZeroDivisionError, TypeError) as e:
            logging.error(f"Kelly Criterion 계산 오류: {e}")
            return 0.01
    
    async def _generate_recommendation(self, phoenix95_score: float, kelly_ratio: float) -> str:
        """최종 추천 생성"""
        if phoenix95_score >= 0.95 and kelly_ratio >= 0.2:
            return "STRONG_BUY"
        elif phoenix95_score >= 0.85 and kelly_ratio >= 0.15:
            return "BUY"
        elif phoenix95_score >= 0.75 and kelly_ratio >= 0.1:
            return "WEAK_BUY"
        elif phoenix95_score >= 0.6:
            return "HOLD"
        else:
            return "REJECT"
    
    def get_performance_stats(self) -> Dict[str, Union[float, int]]:
        """모델 성능 통계"""
        if not self.model_performance:
            return {}
        
        scores = [p['score'] for p in self.model_performance]
        times = [p['analysis_time'] for p in self.model_performance]
        
        return {
            "avg_score": np.mean(scores),
            "score_std": np.std(scores),
            "avg_analysis_time": np.mean(times),
            "max_analysis_time": np.max(times),
            "total_analyses": len(self.model_performance),
            "cache_size": len(self.analysis_cache),
            "cache_hit_rate": 0.0  # 실제 구현에서는 캐시 히트율 추적
        }

# ═══════════════════════════════════════════════════════════════════════════════
#                              ⚡ 레버리지 트레이딩 엔진 (무한루프 방지, 재시도 로직)
# ═══════════════════════════════════════════════════════════════════════════════

class UltimateLeverageTrader:
    """Ultimate 레버리지 트레이딩 엔진 - V3 안정성 + V4 고도화 (무한루프 방지)"""
    
    def __init__(self, redis_client, postgres_pool, telegram_notifier):
        self.redis = redis_client
        self.postgres = postgres_pool
        self.telegram = telegram_notifier
        self.active_positions: Dict[str, Position] = {}
        self.monitoring_tasks: Dict[str, asyncio.Task] = {}
        self.risk_metrics = deque(maxlen=1000)
        
        # 재시도 설정
        self.max_retries = SystemConfig.TRADING["max_retries"]
        self.retry_delay = SystemConfig.TRADING["retry_delay"]
        
    async def execute_trade_complete(self, signal: TradingSignal, 
                                   phoenix95_score: float, 
                                   kelly_ratio: float) -> Optional[Position]:
        """완전한 거래 실행 - 500ms 이내 보장 (재시도 로직 포함)"""
        execution_start = time.time()
        
        for attempt in range(self.max_retries + 1):
            try:
                # 1. 종합 리스크 체크
                risk_check = await self._comprehensive_risk_check(signal)
                if not risk_check["approved"]:
                    logging.warning(f"리스크 체크 실패 (시도 {attempt + 1}): {risk_check['reason']}")
                    if attempt == self.max_retries:
                        await self.telegram.send_message(f"⚠️ 거래 거부: {risk_check['reason']}")
                        return None
                    await asyncio.sleep(self.retry_delay)
                    continue
                
                # 2. 포지션 크기 계산 (Kelly + 리스크 조정)
                position_size_usd = await self._calculate_optimal_position_size(kelly_ratio, signal)
                
                # 3. 레버리지 계산
                leverage = await self._calculate_optimal_leverage(phoenix95_score)
                
                # 4. 수량 및 마진 계산 (Zero Division 방지)
                if signal.price <= 0 or leverage <= 0:
                    raise ValueError(f"잘못된 가격 또는 레버리지: price={signal.price}, leverage={leverage}")
                
                quantity = position_size_usd / signal.price
                margin_required = position_size_usd / leverage
                
                # 5. 리스크 가격 계산
                liquidation_price = self._calculate_liquidation_price(signal, leverage)
                stop_loss_price = self._calculate_stop_loss_price(signal)
                take_profit_price = self._calculate_take_profit_price(signal)
                
                # 6. 포지션 객체 생성
                position = Position(
                    position_id=f"POS_{uuid.uuid4().hex[:8].upper()}",
                    signal_id=signal.signal_id,
                    symbol=signal.symbol,
                    side=signal.action.upper(),
                    entry_price=signal.price,
                    quantity=quantity,
                    leverage=leverage,
                    margin_mode=SystemConfig.TRADING["margin_mode"],
                    margin_required=margin_required,
                    liquidation_price=liquidation_price,
                    stop_loss_price=stop_loss_price,
                    take_profit_price=take_profit_price,
                    current_price=signal.price
                )
                
                # 7. 데이터베이스 저장
                await self._save_position_to_db(position)
                await self._save_signal_to_db(signal)
                
                # 8. 메모리에 포지션 추가
                self.active_positions[position.position_id] = position
                
                # 9. 실시간 모니터링 시작
                await self._start_position_monitoring(position)
                
                # 10. 실행 시간 검증
                execution_time = (time.time() - execution_start) * 1000
                if execution_time > 500:
                    logging.warning(f"거래 실행 시간 초과: {execution_time:.0f}ms")
                
                # 11. 성공 알림
                await self.telegram.send_trade_notification(position, phoenix95_score, kelly_ratio)
                
                logging.info(f"거래 실행 완료: {position.position_id} ({execution_time:.0f}ms)")
                return position
                
            except Exception as e:
                logging.error(f"거래 실행 실패 (시도 {attempt + 1}): {e}")
                if attempt == self.max_retries:
                    await self.telegram.send_message(f"🚨 거래 실행 오류: {str(e)}")
                    return None
                await asyncio.sleep(self.retry_delay)
        
        return None
    
    async def _comprehensive_risk_check(self, signal: TradingSignal) -> Dict[str, Any]:
        """종합 리스크 체크 (타입 안정성 강화)"""
        risk_factors = []
        
        # 1. 최대 포지션 수 체크
        if len(self.active_positions) >= SystemConfig.TRADING["max_positions"]:
            return {"approved": False, "reason": "최대 포지션 수 초과"}
        
        # 2. 일일 손실 한도 체크
        daily_pnl = await self._get_daily_pnl()
        if daily_pnl <= -SystemConfig.TRADING["max_daily_loss"]:
            return {"approved": False, "reason": "일일 손실 한도 초과"}
        
        # 3. 심볼 중복 체크  
        symbol_positions = [p for p in self.active_positions.values() if p.symbol == signal.symbol]
        if len(symbol_positions) >= 1:  # 심볼당 1개만
            return {"approved": False, "reason": f"{signal.symbol} 포지션 이미 존재"}
        
        # 4. 시장 시간 체크
        now = datetime.utcnow()
        if now.weekday() >= 5:  # 주말
            return {"approved": False, "reason": "주말 거래 금지"}
        
        # 5. 신뢰도 재확인 (None 체크 포함)
        if signal.phoenix95_score is not None and signal.phoenix95_score < SystemConfig.TRADING["confidence_threshold"]:
            risk_factors.append("낮은 신뢰도")
        
        # 6. 변동성 체크 (간단한 구현)
        volatility_risk = await self._check_volatility_risk(signal.symbol)
        if volatility_risk > 0.8:
            risk_factors.append("높은 변동성")
        
        risk_score = len(risk_factors) / 6  # 정규화
        
        return {
            "approved": risk_score < 0.5,
            "reason": "리스크 체크 통과" if risk_score < 0.5 else f"위험 요소: {', '.join(risk_factors)}",
            "risk_score": risk_score,
            "risk_factors": risk_factors
        }
    
    async def _calculate_optimal_position_size(self, kelly_ratio: float, signal: TradingSignal) -> float:
        """최적 포지션 크기 계산 (안전한 계산)"""
        try:
            # 계좌 잔고 (실제로는 거래소 API에서 조회)
            account_balance = float(os.getenv("ACCOUNT_BALANCE", "50000"))
            
            # Kelly 기반 기본 포지션 크기
            kelly_position = account_balance * kelly_ratio
            
            # 설정된 최대 포지션 크기 제한
            max_position_size = account_balance * SystemConfig.TRADING["position_size_pct"]
            
            # 최종 포지션 크기 (보수적 접근)
            position_size = min(kelly_position, max_position_size)
            
            # 최소/최대 제한
            min_position = 100.0  # 최소 $100
            max_position = 10000.0  # 최대 $10,000
            
            return max(min_position, min(position_size, max_position))
        except (ValueError, TypeError) as e:
            logging.error(f"포지션 크기 계산 오류: {e}")
            return 100.0  # 기본값
    
    async def _calculate_optimal_leverage(self, phoenix95_score: float) -> int:
        """최적 레버리지 계산"""
        max_leverage = SystemConfig.TRADING["max_leverage"]
        
        # 신뢰도 기반 레버리지 조정
        if phoenix95_score >= 0.95:
            return max_leverage
        elif phoenix95_score >= 0.9:
            return min(8, max_leverage)
        elif phoenix95_score >= 0.85:
            return min(5, max_leverage)
        else:
            return min(3, max_leverage)
    
    def _calculate_liquidation_price(self, signal: TradingSignal, leverage: int) -> float:
        """청산가 계산 (안전한 계산)"""
        try:
            maintenance_margin_rate = 0.004  # 0.4%
            
            if signal.action.lower() == "buy":
                return signal.price * (1 - (1/leverage) + maintenance_margin_rate)
            else:
                return signal.price * (1 + (1/leverage) - maintenance_margin_rate)
        except (ZeroDivisionError, TypeError) as e:
            logging.error(f"청산가 계산 오류: {e}")
            return signal.price * 0.9  # 안전한 기본값
    
    def _calculate_stop_loss_price(self, signal: TradingSignal) -> float:
        """손절가 계산"""
        stop_pct = SystemConfig.TRADING["stop_loss_pct"]
        
        if signal.action.lower() == "buy":
            return signal.price * (1 - stop_pct)
        else:
            return signal.price * (1 + stop_pct)
    
    def _calculate_take_profit_price(self, signal: TradingSignal) -> float:
        """익절가 계산"""
        profit_pct = SystemConfig.TRADING["take_profit_pct"]
        
        if signal.action.lower() == "buy":
            return signal.price * (1 + profit_pct)
        else:
            return signal.price * (1 - profit_pct)
    
    async def _start_position_monitoring(self, position: Position):
        """실시간 포지션 모니터링 시작"""
        task = asyncio.create_task(self._monitor_position_realtime(position))
        self.monitoring_tasks[position.position_id] = task
        
        # Redis에 포지션 정보 저장
        try:
            await self.redis.hset(
                f"position:{position.position_id}",
                mapping={
                    "symbol": position.symbol,
                    "side": position.side,
                    "entry_price": str(position.entry_price),
                    "quantity": str(position.quantity),
                    "leverage": str(position.leverage),
                    "status": position.status,
                    "created_at": position.created_at.isoformat()
                }
            )
        except Exception as e:
            logging.error(f"Redis 포지션 저장 실패: {e}")
    
    async def _monitor_position_realtime(self, position: Position):
        """실시간 포지션 모니터링 (무한루프 방지 및 재시도 제한)"""
        logging.info(f"포지션 모니터링 시작: {position.position_id}")
        
        retry_count = 0
        max_consecutive_errors = 10  # 연속 오류 제한
        
        while position.status == "OPEN" and retry_count < max_consecutive_errors:
            try:
                # 현재가 조회
                current_price = await self._get_current_price(position.symbol)
                if current_price <= 0:
                    raise ValueError(f"잘못된 가격: {current_price}")
                
                position.current_price = current_price
                
                # P&L 계산
                pnl, pnl_pct = position.calculate_pnl(current_price)
                position.unrealized_pnl = pnl
                position.pnl_percentage = pnl_pct
                
                # 청산 위험도 계산
                risk = position.calculate_liquidation_risk(current_price)
                position.liquidation_risk = risk
                
                # 종료 조건 체크
                exit_reason = await self._check_exit_conditions(position, current_price)
                if exit_reason:
                    await self._close_position(position, current_price, exit_reason)
                    break
                
                # Redis 업데이트 (안전한 업데이트)
                try:
                    await self.redis.hset(
                        f"position:{position.position_id}",
                        mapping={
                            "current_price": str(current_price),
                            "unrealized_pnl": str(pnl),
                            "pnl_percentage": str(pnl_pct),
                            "liquidation_risk": str(risk),
                            "updated_at": datetime.utcnow().isoformat()
                        }
                    )
                except Exception as redis_error:
                    logging.warning(f"Redis 업데이트 실패: {redis_error}")
                
                # 위험 알림 체크
                if risk > 0.8:
                    await self.telegram.send_liquidation_warning(position)
                
                # 성공적인 반복 후 retry_count 리셋
                retry_count = 0
                await asyncio.sleep(1)  # 1초마다 체크
                
            except Exception as e:
                retry_count += 1
                logging.error(f"포지션 모니터링 오류 {position.position_id} (재시도 {retry_count}): {e}")
                
                if retry_count >= max_consecutive_errors:
                    logging.critical(f"포지션 {position.position_id} 모니터링 중단 (최대 오류 횟수 초과)")
                    break
                
                await asyncio.sleep(min(5 * retry_count, 30))  # 지수적 백오프 (최대 30초)
        
        # 모니터링 태스크 정리
        if position.position_id in self.monitoring_tasks:
            del self.monitoring_tasks[position.position_id]
        
        if retry_count >= max_consecutive_errors:
            await self.telegram.send_system_notification(
                f"포지션 {position.position_id} 모니터링 실패", "CRITICAL"
            )
    
    async def _get_current_price(self, symbol: str) -> float:
        """현재가 조회 (시뮬레이션 - 프로덕션에서는 실제 API 사용 필요)"""
        # ⚠️ 경고: 이것은 시뮬레이션입니다. 실제 운영에서는 Binance API 사용하세요!
        logging.warning(f"⚠️ 시뮬레이션 모드: {symbol} 가격 조회")
        
        # 실제로는 다음과 같이 Binance API 호출:
        # try:
        #     async with aiohttp.ClientSession() as session:
        #         url = f"https://api.binance.com/api/v3/ticker/price?symbol={symbol}"
        #         async with session.get(url, timeout=5) as response:
        #             if response.status == 200:
        #                 data = await response.json()
        #                 return float(data['price'])
        #             else:
        #                 raise aiohttp.ClientError(f"API 응답 오류: {response.status}")
        # except Exception as e:
        #     logging.error(f"Binance API 호출 실패: {e}")
        #     raise
        
        base_prices = {
            "BTCUSDT": 45000, "ETHUSDT": 3000, "ADAUSDT": 0.5,
            "SOLUSDT": 100, "AVAXUSDT": 40, "DOTUSDT": 8
        }
        
        base_price = base_prices.get(symbol, 45000)
        
        # 간단한 가격 변동 시뮬레이션
        import random
        change = random.uniform(-0.01, 0.01)  # ±1% 변동
        price = base_price * (1 + change)
        
        # 가격 유효성 검증
        if price <= 0:
            logging.error(f"잘못된 가격 생성: {price}")
            return base_price
        
        return price
    
    async def _check_exit_conditions(self, position: Position, current_price: float) -> Optional[str]:
        """포지션 종료 조건 체크 (타입 안정성 강화)"""
        try:
            # 손절가 체크
            if position.side == "BUY" and current_price <= position.stop_loss_price:
                return "STOP_LOSS"
            if position.side == "SELL" and current_price >= position.stop_loss_price:
                return "STOP_LOSS"
            
            # 익절가 체크  
            if position.side == "BUY" and current_price >= position.take_profit_price:
                return "TAKE_PROFIT"
            if position.side == "SELL" and current_price <= position.take_profit_price:
                return "TAKE_PROFIT"
            
            # 긴급 청산 체크 (청산가 5% 이내 접근)
            if position.liquidation_risk > 0.95:
                return "EMERGENCY_LIQUIDATION"
            
            return None
        except Exception as e:
            logging.error(f"종료 조건 체크 오류: {e}")
            return None
    
    async def _close_position(self, position: Position, exit_price: float, exit_reason: str):
        """포지션 청산 (안전한 청산)"""
        try:
            position.status = "CLOSED"
            position.exit_price = exit_price
            position.exit_time = datetime.utcnow()
            position.exit_reason = exit_reason
            
            # 최종 P&L 계산
            final_pnl, final_pnl_pct = position.calculate_pnl(exit_price)
            position.realized_pnl = final_pnl
            
            # 데이터베이스 업데이트
            await self._update_position_in_db(position)
            await self._save_trade_history(position)
            
            # 메모리에서 제거
            if position.position_id in self.active_positions:
                del self.active_positions[position.position_id]
            
            # Redis 정리
            try:
                await self.redis.delete(f"position:{position.position_id}")
            except Exception as redis_error:
                logging.warning(f"Redis 정리 실패: {redis_error}")
            
            # 청산 알림
            await self.telegram.send_close_notification(position, exit_reason)
            
            logging.info(f"포지션 청산 완료: {position.position_id} | P&L: ${final_pnl:.2f} | 사유: {exit_reason}")
        except Exception as e:
            logging.error(f"포지션 청산 실패: {e}")
    
    async def _save_position_to_db(self, position: Position):
        """포지션 DB 저장 (연결 타임아웃 및 재시도)"""
        for attempt in range(3):  # 3회 재시도
            try:
                async with asyncio.wait_for(self.postgres.acquire(), timeout=10) as conn:
                    await conn.execute("""
                        INSERT INTO positions (
                            position_id, signal_id, symbol, side, entry_price, quantity,
                            leverage, margin_mode, margin_required, liquidation_price,
                            stop_loss_price, take_profit_price, status, created_at
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
                    """, position.position_id, position.signal_id, position.symbol, position.side,
                    position.entry_price, position.quantity, position.leverage, position.margin_mode,
                    position.margin_required, position.liquidation_price, position.stop_loss_price,
                    position.take_profit_price, position.status, position.created_at)
                return  # 성공 시 종료
            except asyncio.TimeoutError:
                logging.warning(f"포지션 DB 저장 타임아웃 (시도 {attempt + 1})")
            except Exception as e:
                logging.error(f"포지션 DB 저장 실패 (시도 {attempt + 1}): {e}")
            
            if attempt < 2:  # 마지막 시도가 아니면 대기
                await asyncio.sleep(2 ** attempt)  # 지수적 백오프
    
    async def _save_signal_to_db(self, signal: TradingSignal):
        """신호 DB 저장 (재시도 로직 포함)"""
        for attempt in range(3):
            try:
                async with asyncio.wait_for(self.postgres.acquire(), timeout=10) as conn:
                    await conn.execute("""
                        INSERT INTO signals (
                            signal_id, symbol, action, price, confidence, phoenix95_score,
                            kelly_ratio, recommendation, timestamp, processed
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                    """, signal.signal_id, signal.symbol, signal.action, signal.price,
                    signal.confidence, signal.phoenix95_score, signal.kelly_ratio,
                    signal.recommendation, signal.timestamp, signal.processed)
                return
            except asyncio.TimeoutError:
                logging.warning(f"신호 DB 저장 타임아웃 (시도 {attempt + 1})")
            except Exception as e:
                logging.error(f"신호 DB 저장 실패 (시도 {attempt + 1}): {e}")
            
            if attempt < 2:
                await asyncio.sleep(2 ** attempt)
    
    async def _update_position_in_db(self, position: Position):
        """포지션 DB 업데이트 (재시도 로직 포함)"""
        for attempt in range(3):
            try:
                async with asyncio.wait_for(self.postgres.acquire(), timeout=10) as conn:
                    await conn.execute("""
                        UPDATE positions SET
                            current_price = $1, unrealized_pnl = $2, pnl_percentage = $3,
                            liquidation_risk = $4, status = $5, exit_price = $6,
                            exit_time = $7, exit_reason = $8, realized_pnl = $9, updated_at = $10
                        WHERE position_id = $11
                    """, position.current_price, position.unrealized_pnl, position.pnl_percentage,
                    position.liquidation_risk, position.status, position.exit_price,
                    position.exit_time, position.exit_reason, position.realized_pnl,
                    position.updated_at, position.position_id)
                return
            except Exception as e:
                logging.error(f"포지션 DB 업데이트 실패 (시도 {attempt + 1}): {e}")
                if attempt < 2:
                    await asyncio.sleep(2 ** attempt)
    
    async def _save_trade_history(self, position: Position):
        """거래 이력 저장 (안전한 저장)"""
        try:
            duration_minutes = 0
            if position.exit_time and position.created_at:
                duration_minutes = int((position.exit_time - position.created_at).total_seconds() / 60)
            
            async with asyncio.wait_for(self.postgres.acquire(), timeout=10) as conn:
                await conn.execute("""
                    INSERT INTO trade_history (
                        position_id, symbol, side, entry_price, exit_price, quantity,
                        leverage, pnl, pnl_percentage, duration_minutes, entry_time,
                        exit_time, exit_reason
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
                """, position.position_id, position.symbol, position.side, position.entry_price,
                position.exit_price, position.quantity, position.leverage, position.realized_pnl,
                position.pnl_percentage, duration_minutes, position.created_at,
                position.exit_time, position.exit_reason)
        except Exception as e:
            logging.error(f"거래 이력 저장 실패: {e}")
    
    async def _get_daily_pnl(self) -> float:
        """일일 P&L 조회 (안전한 조회)"""
        try:
            async with asyncio.wait_for(self.postgres.acquire(), timeout=5) as conn:
                result = await conn.fetchval("""
                    SELECT COALESCE(SUM(pnl), 0) FROM trade_history
                    WHERE DATE(entry_time) = CURRENT_DATE
                """)
                return float(result) if result is not None else 0.0
        except Exception as e:
            logging.error(f"일일 P&L 조회 실패: {e}")
            return 0.0
    
    async def _check_volatility_risk(self, symbol: str) -> float:
        """변동성 위험도 체크 (0-1)"""
        # 간단한 시뮬레이션 (실제로는 24h 변동성 계산)
        volatility_map = {
            "BTCUSDT": 0.3, "ETHUSDT": 0.4, "ADAUSDT": 0.6,
            "SOLUSDT": 0.7, "AVAXUSDT": 0.6
        }
        return volatility_map.get(symbol, 0.5)
    
    def get_portfolio_summary(self) -> Dict[str, Union[int, float, List[str]]]:
        """포트폴리오 요약 (타입 안정성 강화)"""
        if not self.active_positions:
            return {
                "active_positions": 0,
                "total_unrealized_pnl": 0.0,
                "total_margin_used": 0.0,
                "avg_leverage": 0.0,
                "avg_liquidation_risk": 0.0,
                "symbols": []
            }
        
        positions = list(self.active_positions.values())
        
        try:
            return {
                "active_positions": len(positions),
                "total_unrealized_pnl": sum(p.unrealized_pnl for p in positions),
                "total_margin_used": sum(p.margin_required for p in positions),
                "avg_leverage": float(np.mean([p.leverage for p in positions])),
                "avg_liquidation_risk": float(np.mean([p.liquidation_risk for p in positions])),
                "symbols": [p.symbol for p in positions]
            }
        except Exception as e:
            logging.error(f"포트폴리오 요약 계산 오류: {e}")
            return {
                "active_positions": len(positions),
                "total_unrealized_pnl": 0.0,
                "total_margin_used": 0.0,
                "avg_leverage": 0.0,
                "avg_liquidation_risk": 0.0,
                "symbols": []
            }

# ═══════════════════════════════════════════════════════════════════════════════
#                              📱 텔레그램 알림 시스템 (레이트 리미팅 강화)
# ═══════════════════════════════════════════════════════════════════════════════

class UltimateTelegramNotifier:
    """Ultimate 텔레그램 알림 시스템 - V3 메시지 + V4 고도화 (안전성 강화)"""
    
    def __init__(self):
        self.config = SystemConfig.TELEGRAM
        self.bot_token = self.config["bot_token"]
        self.chat_id = self.config["chat_id"]
        
        # 텔레그램 설정 검증 (None 체크 강화)
        if not self.bot_token:
            raise ValueError("TELEGRAM_BOT_TOKEN이 설정되지 않았습니다")
        if not self.chat_id:
            raise ValueError("TELEGRAM_CHAT_ID가 설정되지 않았습니다")
            
        self.rate_limiter = asyncio.Semaphore(5)  # 초당 5개 메시지 제한
        self.last_alert_times: Dict[str, datetime] = {}  # 알림 쿨다운 관리
        
        logging.info(f"텔레그램 알림 시스템 초기화 완료 (Chat ID: {self.chat_id})")
        
    async def send_message(self, message: str, level: str = "INFO") -> bool:
        """텔레그램 메시지 전송 (쿨다운 및 재시도 로직)"""
        if not self.config["alerts"].get(level.lower(), True):
            return False
        
        # 알림 쿨다운 체크 (중복 방지)
        alert_key = f"{level}_{hash(message) % 10000}"
        now = datetime.utcnow()
        
        if alert_key in self.last_alert_times:
            time_diff = (now - self.last_alert_times[alert_key]).total_seconds()
            cooldown = SystemConfig.MONITORING["alert_cooldown"]
            if time_diff < cooldown:
                logging.debug(f"알림 쿨다운 중: {alert_key}")
                return False
        
        async with self.rate_limiter:
            success = await self._send_message_internal(message, level)
            if success:
                self.last_alert_times[alert_key] = now
            return success
    
    async def _send_message_internal(self, message: str, level: str) -> bool:
        """내부 메시지 전송 로직 (재시도 포함)"""
        max_retries = 3
        
        for attempt in range(max_retries):
            try:
                url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
                
                # 레벨별 이모지 추가
                level_emojis = {
                    "INFO": "ℹ️", "WARNING": "⚠️", "ERROR": "❌", 
                    "CRITICAL": "🚨", "SUCCESS": "✅"
                }
                emoji = level_emojis.get(level, "📢")
                
                # 메시지 길이 제한 (텔레그램 4096자 제한)
                max_length = 4000
                if len(message) > max_length:
                    message = message[:max_length] + "..."
                
                formatted_message = f"{emoji} <b>[{level}]</b>\n{message}"
                
                data = {
                    "chat_id": self.chat_id,
                    "text": formatted_message,
                    "parse_mode": "HTML",
                    "disable_web_page_preview": True
                }
                
                async with aiohttp.ClientSession() as session:
                    async with session.post(url, data=data, timeout=10) as response:
                        if response.status == 200:
                            return True
                        elif response.status == 429:  # Rate limit
                            retry_after = int(response.headers.get("Retry-After", 1))
                            logging.warning(f"텔레그램 레이트 리미트, {retry_after}초 대기")
                            await asyncio.sleep(retry_after)
                        else:
                            response_text = await response.text()
                            logging.warning(f"텔레그램 응답 오류: {response.status} - {response_text}")
                            
            except asyncio.TimeoutError:
                logging.warning(f"텔레그램 전송 타임아웃 (시도 {attempt + 1})")
            except Exception as e:
                logging.error(f"텔레그램 전송 실패 (시도 {attempt + 1}): {e}")
            
            if attempt < max_retries - 1:
                await asyncio.sleep(2 ** attempt)  # 지수적 백오프
        
        return False
    
    async def send_trade_notification(self, position: Position, phoenix95_score: float, kelly_ratio: float):
        """거래 실행 알림 - V3 스타일 메시지 (안전한 계산)"""
        try:
            pnl_range_low = position.margin_required * (SystemConfig.TRADING["stop_loss_pct"] * position.leverage)
            pnl_range_high = position.margin_required * (SystemConfig.TRADING["take_profit_pct"] * position.leverage)
            
            message = f"""🎯 <b>Phoenix 95 Ultimate 거래 실행</b>

📊 <b>{position.symbol}</b> {position.side} {position.leverage}x ({position.margin_mode})
💰 진입가: <b>${position.entry_price:,.2f}</b>
📈 익절가: <b>${position.take_profit_price:,.2f}</b> (+{SystemConfig.TRADING['take_profit_pct']*100:.1f}%)
📉 손절가: <b>${position.stop_loss_price:,.2f}</b> (-{SystemConfig.TRADING['stop_loss_pct']*100:.1f}%)
🚨 청산가: <b>${position.liquidation_price:,.2f}</b>

🧠 Phoenix95: <b>{phoenix95_score:.1%}</b>
⚖️ Kelly 비율: <b>{kelly_ratio:.1%}</b>
💵 수량: <b>{position.quantity:.6f}</b>
💸 마진: <b>${position.margin_required:,.2f}</b>

📊 예상 P&L: <b>-${pnl_range_low:.0f}</b> ~ <b>+${pnl_range_high:.0f}</b>
🆔 포지션: <code>{position.position_id}</code>

🕐 {datetime.utcnow().strftime('%H:%M:%S UTC')}"""
            
            await self.send_message(message, "SUCCESS")
        except Exception as e:
            logging.error(f"거래 알림 생성 실패: {e}")
    
    async def send_close_notification(self, position: Position, exit_reason: str):
        """포지션 청산 알림 (안전한 메시지 생성)"""
        try:
            pnl_emoji = "📈" if position.realized_pnl and position.realized_pnl > 0 else "📉"
            reason_emoji = {
                "TAKE_PROFIT": "🎯", "STOP_LOSS": "🛡️", 
                "EMERGENCY_LIQUIDATION": "🚨", "MANUAL": "👤"
            }
            
            duration = ""
            if position.exit_time and position.created_at:
                duration_mins = int((position.exit_time - position.created_at).total_seconds() / 60)
                duration = f"⏱️ 거래시간: <b>{duration_mins}분</b>\n"
            
            realized_pnl = position.realized_pnl or 0.0
            pnl_percentage = position.pnl_percentage or 0.0
            
            message = f"""{pnl_emoji} <b>포지션 청산</b> {reason_emoji.get(exit_reason, "📍")}

📊 <b>{position.symbol}</b> {position.side} {position.leverage}x
💰 진입가: <b>${position.entry_price:,.2f}</b>
💸 청산가: <b>${position.exit_price:,.2f}</b>
{duration}
💵 P&L: <b>${realized_pnl:,.2f}</b> ({pnl_percentage:+.1f}%)
📋 사유: <b>{exit_reason.replace('_', ' ')}</b>

🆔 포지션: <code>{position.position_id}</code>
🕐 {datetime.utcnow().strftime('%H:%M:%S UTC')}"""
            
            level = "SUCCESS" if realized_pnl > 0 else "WARNING"
            await self.send_message(message, level)
        except Exception as e:
            logging.error(f"청산 알림 생성 실패: {e}")
    
    async def send_liquidation_warning(self, position: Position):
        """청산 위험 경고 (쿨다운 적용)"""
        try:
            message = f"""🆘 <b>청산 위험 경고</b>

📊 <b>{position.symbol}</b> {position.side} {position.leverage}x
💰 진입가: <b>${position.entry_price:,.2f}</b>
💸 현재가: <b>${position.current_price:,.2f}</b>
🚨 청산가: <b>${position.liquidation_price:,.2f}</b>

⚠️ 위험도: <b>{position.liquidation_risk:.1%}</b>
💔 미실현 P&L: <b>${position.unrealized_pnl:,.2f}</b> ({position.pnl_percentage:+.1f}%)

🆔 포지션: <code>{position.position_id}</code>
🕐 {datetime.utcnow().strftime('%H:%M:%S UTC')}

⚡ 즉시 확인이 필요합니다!"""
            
            await self.send_message(message, "CRITICAL")
        except Exception as e:
            logging.error(f"청산 경고 생성 실패: {e}")
    
    async def send_system_notification(self, message: str, level: str = "INFO"):
        """시스템 알림"""
        try:
            system_message = f"""🖥️ <b>Phoenix 95 Ultimate System</b>

{message}

🕐 {datetime.utcnow().strftime('%H:%M:%S UTC')}"""
            
            await self.send_message(system_message, level)
        except Exception as e:
            logging.error(f"시스템 알림 생성 실패: {e}")
    
    async def send_daily_summary(self, stats: Dict[str, Any]):
        """일일 성과 요약 (안전한 통계 계산)"""
        try:
            total_trades = stats.get('total_trades', 0)
            winning_trades = stats.get('winning_trades', 0)
            win_rate = (winning_trades / max(total_trades, 1)) * 100
            
            message = f"""📊 <b>Phoenix 95 Ultimate 일일 성과</b>

💰 총 P&L: <b>${stats.get('total_pnl', 0):.2f}</b>
📈 총 거래: <b>{total_trades}회</b>
🎯 승률: <b>{win_rate:.1f}%</b>
🏆 최고 거래: <b>${stats.get('best_trade', 0):.2f}</b>
💔 최악 거래: <b>${stats.get('worst_trade', 0):.2f}</b>
⏱️ 평균 거래시간: <b>{stats.get('avg_duration', 0)}분</b>

📊 활성 포지션: <b>{stats.get('active_positions', 0)}개</b>
💸 총 마진: <b>${stats.get('total_margin', 0):.2f}</b>

🕐 {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}"""
            
            await self.send_message(message, "INFO")
        except Exception as e:
            logging.error(f"일일 요약 생성 실패: {e}")

# ═══════════════════════════════════════════════════════════════════════════════
#                              🔒 보안 & 인증 (강화된 검증)
# ═══════════════════════════════════════════════════════════════════════════════

class SecurityManager:
    """보안 관리자 (검증 강화)"""
    
    def __init__(self):
        self.config = SystemConfig.SECURITY
        
        # 설정 검증
        if not self.config["webhook_secret"]:
            raise ValueError("WEBHOOK_SECRET이 설정되지 않았습니다")
        if not self.config["api_key"]:
            raise ValueError("API_KEY가 설정되지 않았습니다")
        if not self.config["jwt_secret"]:
            raise ValueError("JWT_SECRET이 설정되지 않았습니다")
        
    def verify_webhook_signature(self, payload: str, signature: str) -> bool:
        """웹훅 서명 검증 (안전한 검증)"""
        try:
            expected_signature = hmac.new(
                self.config["webhook_secret"].encode(),
                payload.encode(),
                hashlib.sha256
            ).hexdigest()
            
            return hmac.compare_digest(signature, expected_signature)
        except Exception as e:
            logging.error(f"서명 검증 실패: {e}")
            return False
    
    def verify_api_key(self, api_key: str) -> bool:
        """API 키 검증 (None 체크 포함)"""
        if not api_key or not self.config["api_key"]:
            return False
        return hmac.compare_digest(api_key, self.config["api_key"])
    
    def is_ip_allowed(self, ip: str) -> bool:
        """IP 허용 목록 확인"""
        if not ip:
            return False
        allowed_ips = self.config["allowed_ips"]
        return ip in allowed_ips or "0.0.0.0" in allowed_ips

# ═══════════════════════════════════════════════════════════════════════════════
#                              📊 모니터링 & 메트릭 (통합 메트릭 수집)
# ═══════════════════════════════════════════════════════════════════════════════

class SystemMonitor:
    """시스템 모니터링 (중복 제거, 메트릭 통합)"""
    
    def __init__(self, redis_client, postgres_pool, telegram_notifier):
        self.redis = redis_client
        self.postgres = postgres_pool
        self.telegram = telegram_notifier
        # 메모리 사용량 제한
        max_history = SystemConfig.MONITORING["max_metrics_history"]
        self.metrics_history = deque(maxlen=max_history)
        
        # 통합 메트릭 캐시 (중복 제거)
        self._metrics_cache: Dict[str, Any] = {}
        self._cache_timestamp = datetime.utcnow()
        self._cache_ttl = 30  # 30초 캐시
        
    async def collect_system_metrics(self) -> Optional[PerformanceMetrics]:
        """시스템 메트릭 수집 (통합 수집, 중복 제거)"""
        try:
            # 캐시 확인
            now = datetime.utcnow()
            if (now - self._cache_timestamp).total_seconds() < self._cache_ttl:
                if 'system_metrics' in self._metrics_cache:
                    return self._metrics_cache['system_metrics']
            
            # 시스템 리소스
            cpu_usage, memory_usage = await self._get_system_resources()
            
            # 데이터베이스 연결 수
            active_connections = await self._get_db_connections()
            
            # 트레이딩 메트릭 (통합)
            trading_metrics = await self._get_unified_trading_metrics()
            
            metrics = PerformanceMetrics(
                timestamp=now,
                cpu_usage=cpu_usage,
                memory_usage=memory_usage,
                response_time_ms=0.0,  # API에서 측정
                active_connections=active_connections,
                active_positions=trading_metrics.get('active_positions', 0),
                total_pnl=trading_metrics.get('total_pnl', 0.0),
                win_rate=trading_metrics.get('win_rate', 0.0),
                avg_trade_duration=trading_metrics.get('avg_duration', 0.0),
                phoenix95_avg_score=trading_metrics.get('avg_score', 0.0),
                max_drawdown=trading_metrics.get('max_drawdown', 0.0),
                var_95=trading_metrics.get('var_95', 0.0),
                sharpe_ratio=trading_metrics.get('sharpe_ratio', 0.0)
            )
            
            # 캐시 업데이트
            self._metrics_cache['system_metrics'] = metrics
            self._cache_timestamp = now
            
            self.metrics_history.append(metrics)
            return metrics
            
        except Exception as e:
            logging.error(f"메트릭 수집 실패: {e}")
            return None
    
    async def _get_system_resources(self) -> Tuple[float, float]:
        """시스템 리소스 조회 (안전한 조회)"""
        try:
            import psutil
            cpu_usage = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            memory_usage = memory.percent
            return cpu_usage, memory_usage
        except ImportError:
            logging.warning("psutil 모듈이 없어 시스템 리소스를 조회할 수 없습니다")
            return 0.0, 0.0
        except Exception as e:
            logging.error(f"시스템 리소스 조회 실패: {e}")
            return 0.0, 0.0
    
    async def _get_db_connections(self) -> int:
        """데이터베이스 연결 수 조회"""
        try:
            async with asyncio.wait_for(self.postgres.acquire(), timeout=5) as conn:
                result = await conn.fetchval(
                    "SELECT count(*) FROM pg_stat_activity WHERE state = 'active'"
                )
                return int(result) if result else 0
        except Exception as e:
            logging.error(f"DB 연결 수 조회 실패: {e}")
            return 0
    
    async def _get_unified_trading_metrics(self) -> Dict[str, Union[int, float]]:
        """통합 트레이딩 메트릭 수집 (중복 제거)"""
        try:
            # 캐시 확인
            if 'trading_metrics' in self._metrics_cache:
                cache_age = (datetime.utcnow() - self._cache_timestamp).total_seconds()
                if cache_age < self._cache_ttl:
                    return self._metrics_cache['trading_metrics']
            
            async with asyncio.wait_for(self.postgres.acquire(), timeout=10) as conn:
                # 하나의 쿼리로 통합 조회 (중복 제거)
                today_stats = await conn.fetchrow("""
                    SELECT 
                        COUNT(*) as total_trades,
                        COUNT(*) FILTER (WHERE pnl > 0) as winning_trades,
                        COALESCE(SUM(pnl), 0) as total_pnl,
                        COALESCE(AVG(duration_minutes), 0) as avg_duration,
                        COALESCE(MAX(pnl), 0) as best_trade,
                        COALESCE(MIN(pnl), 0) as worst_trade
                    FROM trade_history 
                    WHERE DATE(entry_time) = CURRENT_DATE
                """)
                
                # 활성 포지션 수
                active_positions = await conn.fetchval(
                    "SELECT COUNT(*) FROM positions WHERE status = 'OPEN'"
                ) or 0
                
                win_rate = 0.0
                if today_stats and today_stats['total_trades'] > 0:
                    win_rate = (today_stats['winning_trades'] / today_stats['total_trades']) * 100
                
                metrics = {
                    'active_positions': int(active_positions),
                    'total_pnl': float(today_stats['total_pnl']) if today_stats else 0.0,
                    'win_rate': win_rate,
                    'avg_duration': float(today_stats['avg_duration']) if today_stats else 0.0,
                    'avg_score': 0.85,  # Phoenix 95 평균 점수
                    'max_drawdown': 0.0,
                    'var_95': 0.0,
                    'sharpe_ratio': 0.0,
                    'best_trade': float(today_stats['best_trade']) if today_stats else 0.0,
                    'worst_trade': float(today_stats['worst_trade']) if today_stats else 0.0,
                    'total_trades': int(today_stats['total_trades']) if today_stats else 0,
                    'winning_trades': int(today_stats['winning_trades']) if today_stats else 0
                }
                
                # 캐시 저장
                self._metrics_cache['trading_metrics'] = metrics
                return metrics
                
        except Exception as e:
            logging.error(f"트레이딩 메트릭 수집 실패: {e}")
            return {}
    
    async def check_alerts(self, metrics: PerformanceMetrics):
        """알림 체크 (중복 알림 방지)"""
        try:
            alerts = []
            thresholds = SystemConfig.MONITORING["performance_threshold"]
            
            # CPU 사용률 체크
            if metrics.cpu_usage > thresholds["cpu_usage_pct"]:
                alerts.append(f"높은 CPU 사용률: {metrics.cpu_usage:.1f}%")
            
            # 메모리 사용률 체크
            if metrics.memory_usage > thresholds["memory_usage_pct"]:
                alerts.append(f"높은 메모리 사용률: {metrics.memory_usage:.1f}%")
            
            # 응답 시간 체크
            if metrics.response_time_ms > thresholds["response_time_ms"]:
                alerts.append(f"느린 응답 시간: {metrics.response_time_ms:.0f}ms")
            
            # 알림 전송 (쿨다운 적용)
            for alert in alerts:
                await self.telegram.send_system_notification(alert, "WARNING")
        except Exception as e:
            logging.error(f"알림 체크 실패: {e}")

# ═══════════════════════════════════════════════════════════════════════════════
#                              🚀 메인 애플리케이션 (오류 처리 강화)
# ═══════════════════════════════════════════════════════════════════════════════

class Phoenix95UltimateSystem:
    """Phoenix 95 Ultimate 통합 시스템 (오류 처리 및 안정성 강화)"""
    
    def __init__(self):
        self.phoenix95_engine = Phoenix95AIEngine()
        self.telegram = UltimateTelegramNotifier()
        self.security = SecurityManager()
        self.redis_client = None
        self.postgres_pool = None
        self.trader = None
        self.monitor = None
        
        # FastAPI 앱
        self.app = FastAPI(
            title="Phoenix 95 Ultimate Trading System",
            description="V3 검증된 알고리즘 + V4 고급 기능 + 헤지펀드급 안전성 (오류 수정 버전)",
            version="Ultimate-1.0.1"
        )
        
        self._setup_middleware()
        self._setup_routes()
        
    def _setup_middleware(self):
        """미들웨어 설정"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    
    def _setup_routes(self):
        """API 라우트 설정 (오류 처리 강화)"""
        
        @self.app.on_event("startup")
        async def startup_event():
            await self.initialize()
        
        @self.app.on_event("shutdown")
        async def shutdown_event():
            await self.cleanup()
        
        @self.app.post("/webhook/tradingview")
        async def receive_tradingview_signal(signal_data: dict, background_tasks: BackgroundTasks):
            """TradingView 신호 수신 (검증 강화)"""
            try:
                # 필수 필드 검증
                required_fields = ["symbol", "action", "price", "confidence"]
                for field in required_fields:
                    if field not in signal_data:
                        raise HTTPException(status_code=400, detail=f"필수 필드 누락: {field}")
                
                # 데이터 타입 검증
                try:
                    price = float(signal_data["price"])
                    confidence = float(signal_data["confidence"])
                except (ValueError, TypeError):
                    raise HTTPException(status_code=400, detail="price와 confidence는 숫자여야 합니다")
                
                # 신호 파싱 및 검증
                signal = TradingSignal(
                    signal_id=f"SIG_{uuid.uuid4().hex[:8].upper()}",
                    symbol=signal_data["symbol"].upper(),
                    action=signal_data["action"].lower(),
                    price=price,
                    confidence=confidence,
                    timestamp=datetime.utcnow()
                )
                
                if not signal.is_valid():
                    raise HTTPException(status_code=400, detail="잘못된 신호 데이터")
                
                # 백그라운드에서 처리
                background_tasks.add_task(self._process_signal_complete, signal)
                
                return {
                    "status": "received",
                    "signal_id": signal.signal_id,
                    "timestamp": signal.timestamp.isoformat()
                }
                
            except HTTPException:
                raise
            except Exception as e:
                logging.error(f"신호 수신 실패: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/health")
        async def health_check():
            """시스템 헬스체크 (포괄적 검사)"""
            try:
                health_status = {
                    "status": "healthy",
                    "timestamp": datetime.utcnow().isoformat(),
                    "version": "Ultimate-1.0.1",
                    "system": "Phoenix 95 Ultimate Trading System",
                    "components": {},
                    "portfolio": {},
                    "config": {}
                }
                
                # 데이터베이스 연결 체크
                db_healthy = False
                try:
                    async with asyncio.wait_for(self.postgres_pool.acquire(), timeout=5) as conn:
                        await conn.fetchval("SELECT 1")
                    db_healthy = True
                except Exception as e:
                    logging.warning(f"DB 헬스체크 실패: {e}")
                
                # Redis 연결 체크
                redis_healthy = False
                try:
                    await asyncio.wait_for(self.redis_client.ping(), timeout=5)
                    redis_healthy = True
                except Exception as e:
                    logging.warning(f"Redis 헬스체크 실패: {e}")
                
                # 포트폴리오 요약
                try:
                    portfolio = self.trader.get_portfolio_summary() if self.trader else {}
                    health_status["portfolio"] = portfolio
                except Exception as e:
                    logging.warning(f"포트폴리오 조회 실패: {e}")
                
                # 컴포넌트 상태
                health_status["components"] = {
                    "database": "healthy" if db_healthy else "error",
                    "redis": "healthy" if redis_healthy else "error",
                    "ai_engine": "healthy",
                    "trading_engine": "healthy" if self.trader else "error",
                    "telegram": "healthy"
                }
                
                # 설정 정보
                health_status["config"] = {
                    "max_leverage": SystemConfig.TRADING["max_leverage"],
                    "max_positions": SystemConfig.TRADING["max_positions"],
                    "confidence_threshold": SystemConfig.TRADING["confidence_threshold"]
                }
                
                # 전체 상태 결정
                if not db_healthy or not redis_healthy:
                    health_status["status"] = "degraded"
                
                return health_status
                
            except Exception as e:
                logging.error(f"헬스체크 실패: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/positions")
        async def get_active_positions():
            """활성 포지션 조회 (안전한 조회)"""
            try:
                if not self.trader:
                    return {"positions": [], "count": 0, "summary": {}}
                
                positions = []
                for position in self.trader.active_positions.values():
                    try:
                        positions.append({
                            "position_id": position.position_id,
                            "symbol": position.symbol,
                            "side": position.side,
                            "entry_price": position.entry_price,
                            "current_price": position.current_price,
                            "quantity": position.quantity,
                            "leverage": position.leverage,
                            "margin_required": position.margin_required,
                            "unrealized_pnl": position.unrealized_pnl,
                            "pnl_percentage": position.pnl_percentage,
                            "liquidation_risk": position.liquidation_risk,
                            "liquidation_price": position.liquidation_price,
                            "stop_loss_price": position.stop_loss_price,
                            "take_profit_price": position.take_profit_price,
                            "status": position.status,
                            "created_at": position.created_at.isoformat()
                        })
                    except Exception as e:
                        logging.warning(f"포지션 {position.position_id} 직렬화 실패: {e}")
                
                portfolio_summary = self.trader.get_portfolio_summary()
                
                return {
                    "positions": positions,
                    "count": len(positions),
                    "summary": portfolio_summary
                }
                
            except Exception as e:
                logging.error(f"포지션 조회 실패: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/performance")
        async def get_performance_stats():
            """성능 통계 조회 (통합 통계)"""
            try:
                # AI 엔진 성능
                ai_stats = self.phoenix95_engine.get_performance_stats()
                
                # 시스템 메트릭
                latest_metrics = None
                if self.monitor and self.monitor.metrics_history:
                    latest_metrics = self.monitor.metrics_history[-1]
                
                # 거래 통계 (통합 메트릭 사용)
                trading_stats = {}
                if self.monitor:
                    trading_stats = await self.monitor._get_unified_trading_metrics()
                
                return {
                    "ai_engine": ai_stats,
                    "system_metrics": asdict(latest_metrics) if latest_metrics else {},
                    "trading_stats": trading_stats,
                    "timestamp": datetime.utcnow().isoformat()
                }
                
            except Exception as e:
                logging.error(f"성능 통계 조회 실패: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.post("/admin/emergency_close")
        async def emergency_close_position(position_id: str):
            """긴급 포지션 청산 (안전한 청산)"""
            try:
                if not self.trader or position_id not in self.trader.active_positions:
                    raise HTTPException(status_code=404, detail="포지션을 찾을 수 없습니다")
                
                position = self.trader.active_positions[position_id]
                current_price = await self.trader._get_current_price(position.symbol)
                
                await self.trader._close_position(position, current_price, "MANUAL")
                
                return {
                    "status": "success",
                    "message": f"포지션 {position_id} 긴급 청산 완료",
                    "timestamp": datetime.utcnow().isoformat()
                }
                
            except HTTPException:
                raise
            except Exception as e:
                logging.error(f"긴급 청산 실패: {e}")
                raise HTTPException(status_code=500, detail=str(e))
    
    async def initialize(self):
        """시스템 초기화 (강화된 오류 처리)"""
        try:
            logging.info("Phoenix 95 Ultimate 시스템 초기화 시작...")
            
            # Redis 연결 (재시도 로직)
            for attempt in range(3):
                try:
                    self.redis_client = await aioredis.from_url(
                        SystemConfig.DATABASE["redis_url"],
                        encoding="utf-8",
                        decode_responses=True,
                        socket_timeout=10,
                        socket_connect_timeout=10
                    )
                    await self.redis_client.ping()
                    logging.info("Redis 연결 성공")
                    break
                except Exception as e:
                    logging.warning(f"Redis 연결 실패 (시도 {attempt + 1}): {e}")
                    if attempt == 2:
                        raise
                    await asyncio.sleep(5)
            
            # PostgreSQL 연결 (재시도 로직)
            for attempt in range(3):
                try:
                    self.postgres_pool = await asyncpg.create_pool(
                        SystemConfig.DATABASE["postgres_url"],
                        min_size=5,
                        max_size=SystemConfig.DATABASE["connection_pool_size"],
                        command_timeout=SystemConfig.DATABASE["query_timeout"]
                    )
                    # 연결 테스트
                    async with self.postgres_pool.acquire() as conn:
                        await conn.fetchval("SELECT 1")
                    logging.info("PostgreSQL 연결 성공")
                    break
                except Exception as e:
                    logging.warning(f"PostgreSQL 연결 실패 (시도 {attempt + 1}): {e}")
                    if attempt == 2:
                        raise
                    await asyncio.sleep(5)
            
            # 트레이더 초기화
            self.trader = UltimateLeverageTrader(
                self.redis_client, 
                self.postgres_pool, 
                self.telegram
            )
            logging.info("레버리지 트레이더 초기화 완료")
            
            # 모니터 초기화
            self.monitor = SystemMonitor(
                self.redis_client,
                self.postgres_pool,
                self.telegram
            )
            logging.info("시스템 모니터 초기화 완료")
            
            # 모니터링 태스크 시작
            asyncio.create_task(self._monitoring_loop())
            
            # 시작 알림
            await self.telegram.send_system_notification(
                """🎯 <b>Phoenix 95 Ultimate 시스템 시작</b> (오류 수정 버전)

✅ V3 검증된 알고리즘 활성화
✅ V4 고급 기능 활성화  
✅ 헤지펀드급 리스크 관리 활성화
✅ 실시간 모니터링 활성화
✅ 20x → 10x 보수적 레버리지
✅ 85% 신뢰도 임계값
✅ 보안 강화 및 오류 수정 완료

💰 최대 포지션: {SystemConfig.TRADING["max_positions"]}개
🛡️ 일일 손실 한도: ${SystemConfig.TRADING["max_daily_loss"]}
⚡ 분석 속도: 2초 이내 보장
🔒 환경변수 검증 강화
🚫 무한루프 및 메모리 누수 방지

🚀 시스템 준비 완료!""", 
                "SUCCESS"
            )
            
            logging.info("Phoenix 95 Ultimate 시스템 초기화 완료!")
            
        except Exception as e:
            logging.error(f"시스템 초기화 실패: {e}")
            try:
                await self.telegram.send_system_notification(f"시스템 초기화 실패: {e}", "ERROR")
            except:
                pass  # 텔레그램 알림 실패 시에도 시스템은 종료되어야 함
            raise
    
    async def cleanup(self):
        """시스템 정리 (안전한 정리)"""
        try:
            logging.info("시스템 정리 시작...")
            
            # 모든 모니터링 태스크 취소
            if self.trader:
                for task in list(self.trader.monitoring_tasks.values()):
                    if not task.done():
                        task.cancel()
                        try:
                            await task
                        except asyncio.CancelledError:
                            pass
            
            # 연결 정리
            if self.redis_client:
                try:
                    await self.redis_client.close()
                except Exception as e:
                    logging.warning(f"Redis 정리 실패: {e}")
            
            if self.postgres_pool:
                try:
                    await self.postgres_pool.close()
                except Exception as e:
                    logging.warning(f"PostgreSQL 정리 실패: {e}")
            
            try:
                await self.telegram.send_system_notification("시스템 정상 종료", "INFO")
            except Exception as e:
                logging.warning(f"종료 알림 실패: {e}")
            
            logging.info("시스템 정리 완료")
            
        except Exception as e:
            logging.error(f"시스템 정리 실패: {e}")
    
    async def _process_signal_complete(self, signal: TradingSignal):
        """완전한 신호 처리 파이프라인 (오류 처리 강화)"""
        try:
            logging.info(f"신호 처리 시작: {signal.signal_id}")
            
            # 1. Phoenix 95 AI 분석 (타임아웃 적용)
            try:
                phoenix95_score, kelly_ratio, recommendation = await asyncio.wait_for(
                    self.phoenix95_engine.analyze_signal_complete(signal),
                    timeout=SystemConfig.PHOENIX95["analysis_timeout"]
                )
            except asyncio.TimeoutError:
                logging.warning(f"AI 분석 타임아웃: {signal.signal_id}")
                phoenix95_score, kelly_ratio, recommendation = 0.0, 0.0, "REJECT"
            
            signal.phoenix95_score = phoenix95_score
            signal.kelly_ratio = kelly_ratio
            signal.recommendation = recommendation
            signal.processed = True
            
            logging.info(f"AI 분석 완료: Phoenix95={phoenix95_score:.3f}, Kelly={kelly_ratio:.3f}, Rec={recommendation}")
            
            # 2. 추천이 거래 가능한 경우에만 실행
            if recommendation in ["STRONG_BUY", "BUY", "WEAK_BUY"]:
                # 3. 거래 실행
                position = await self.trader.execute_trade_complete(signal, phoenix95_score, kelly_ratio)
                
                if position:
                    logging.info(f"거래 실행 성공: {position.position_id}")
                else:
                    logging.warning(f"거래 실행 실패: {signal.signal_id}")
                    await self.telegram.send_system_notification(
                        f"거래 실행 실패\n신호: {signal.symbol} {signal.action}", 
                        "WARNING"
                    )
            else:
                logging.info(f"거래 거부: {recommendation}")
                await self.telegram.send_system_notification(
                    f"""📊 신호 분석 완료 (거래 거부)

🔍 {signal.symbol} {signal.action.upper()}
💰 가격: ${signal.price:,.2f}
🧠 Phoenix95: {phoenix95_score:.1%}
⚖️ Kelly: {kelly_ratio:.1%}
❌ 추천: {recommendation}

💡 거래 조건 미충족""", 
                    "INFO"
                )
            
        except Exception as e:
            logging.error(f"신호 처리 실패 {signal.signal_id}: {e}")
            signal.processed = False
            signal.error_message = str(e)
            
            try:
                await self.telegram.send_system_notification(
                    f"신호 처리 오류\n{signal.symbol}: {str(e)}", 
                    "ERROR"
                )
            except Exception as telegram_error:
                logging.error(f"텔레그램 알림 실패: {telegram_error}")
    
    async def _monitoring_loop(self):
        """모니터링 루프 (재시도 및 오류 처리 강화)"""
        consecutive_errors = 0
        max_consecutive_errors = 5
        
        while consecutive_errors < max_consecutive_errors:
            try:
                # 시스템 메트릭 수집
                metrics = await self.monitor.collect_system_metrics()
                
                if metrics:
                    # 알림 체크
                    await self.monitor.check_alerts(metrics)
                    
                    # Redis에 최신 메트릭 저장
                    try:
                        await self.redis_client.hset("system:metrics", mapping={
                            "cpu_usage": str(metrics.cpu_usage),
                            "memory_usage": str(metrics.memory_usage),
                            "active_positions": str(metrics.active_positions),
                            "total_pnl": str(metrics.total_pnl),
                            "timestamp": metrics.timestamp.isoformat()
                        })
                    except Exception as redis_error:
                        logging.warning(f"Redis 메트릭 저장 실패: {redis_error}")
                
                # 성공적인 반복 후 오류 카운터 리셋
                consecutive_errors = 0
                
                # 30초마다 실행
                await asyncio.sleep(SystemConfig.MONITORING["metrics_interval"])
                
            except Exception as e:
                consecutive_errors += 1
                logging.error(f"모니터링 루프 오류 ({consecutive_errors}/{max_consecutive_errors}): {e}")
                
                if consecutive_errors >= max_consecutive_errors:
                    logging.critical("모니터링 루프 중단 (최대 오류 횟수 초과)")
                    try:
                        await self.telegram.send_system_notification(
                            "모니터링 시스템 중단", "CRITICAL"
                        )
                    except:
                        pass
                    break
                
                # 지수적 백오프
                await asyncio.sleep(min(60 * consecutive_errors, 300))  # 최대 5분

# ═══════════════════════════════════════════════════════════════════════════════
#                              🚀 서버 실행
# ═══════════════════════════════════════════════════════════════════════════════

async def main():
    """메인 실행 함수 (오류 처리 강화)"""
    try:
        # 로깅 설정
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('phoenix95_ultimate.log'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        
        # 시스템 시작 메시지
        print("=" * 80)
        print("🎯 Phoenix 95 Ultimate Trading System (오류 수정 버전)")
        print("💰 V3 검증된 알고리즘 + V4 고급 기능 + 헤지펀드급 안전성")
        print("⚡ Wall Street급 트레이딩 시스템")
        print("🔧 보안 강화, 로직 수정, 중복 제거, 무한루프 방지")
        print("=" * 80)
        
        # Phoenix 95 시스템 생성
        phoenix95_system = Phoenix95UltimateSystem()
        
        # FastAPI 서버 실행
        config = uvicorn.Config(
            phoenix95_system.app,
            host="0.0.0.0",
            port=int(os.getenv("PORT", "8080")),
            log_level="info",
            access_log=True
        )
        
        server = uvicorn.Server(config)
        await server.serve()
        
    except EnvironmentError as e:
        print(f"\n❌ 환경설정 오류:\n{e}")
        print("\n📝 .env 파일 예시:")
        print("TELEGRAM_BOT_TOKEN=your_bot_token")
        print("TELEGRAM_CHAT_ID=your_chat_id")
        print("WEBHOOK_SECRET=your_secret")
        print("API_KEY=your_api_key")
        print("JWT_SECRET=your_jwt_secret")
        sys.exit(1)
    except ValueError as e:
        print(f"\n❌ 설정값 오류: {e}")
        sys.exit(1)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\n👋 Phoenix 95 Ultimate 시스템 종료")
    except Exception as e:
        print(f"\n❌ 시스템 오류: {e}")
        sys.exit(1)

# ═══════════════════════════════════════════════════════════════════════════════
#                              📋 수정 완료 보고서
# ═══════════════════════════════════════════════════════════════════════════════

"""
🔧 주요 수정 사항 요약:

1. 🔒 보안 강화:
   - 민감 정보 하드코딩 제거 (텔레그램 토큰, 채팅 ID)
   - JWT 시크릿 고정 사용으로 토큰 무효화 방지
   - 환경변수 필수 검증 강화
   - 기본값 None 처리로 보안 강화

2. 🐛 로직 오류 수정:
   - 시간대 조건 수정: elif hour >= 21 or hour <= 5 (기존 불가능한 조건 수정)
   - 무한루프 방지: 최대 재시도 횟수 제한 및 회로 차단기 패턴
   - 타입 안정성 강화: Optional 필드 None 체크 추가

3. 🔄 중복 코드 제거:
   - 환경변수 로딩 통합 (최우선 한 번만 실행)
   - 메트릭 수집 통합 (unified_trading_metrics)
   - 데이터베이스 쿼리 통합

4. 🏗️ 아키텍처 개선:
   - 타입 힌트 강화 (Union, Optional 명시)
   - 예외 처리 구체화 (ValueError, TypeError 등)
   - 메모리 누수 방지 (캐시 크기 제한, TTL 적용)

5. ⚡ 성능 및 안정성 향상:
   - 연결 타임아웃 및 재시도 로직 추가
   - 레이트 리미팅 및 알림 쿨다운 강화
   - 지수적 백오프 패턴 적용
   - 안전한 계산 (ZeroDivisionError 방지)

6. 📊 모니터링 강화:
   - 구조화된 오류 로깅
   - 포괄적 헬스체크
   - 연속 오류 제한 및 자동 복구

원본 대비 누락 기능: 없음 (모든 기능 유지하면서 안정성 강화)
"""
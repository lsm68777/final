#!/usr/bin/env python3
"""
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    Phoenix 95 Ultimate Trading System
    V3 ê²€ì¦ëœ ì•Œê³ ë¦¬ì¦˜ + V4 ê³ ê¸‰ ê¸°ëŠ¥ + í—¤ì§€í€ë“œê¸‰ ì•ˆì „ì„±
    
    ğŸ¯ ì™„ì „ í†µí•© ìµœì¢… ë²„ì „ - ëª¨ë“  ê¸°ëŠ¥ì„ í•˜ë‚˜ì˜ íŒŒì¼ì— í†µí•©
    ğŸ’° Wall Streetê¸‰ íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ
    âš¡ ì›í´ë¦­ ë°°í¬, ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§, ìë™ ë¦¬ìŠ¤í¬ ê´€ë¦¬
    
    ğŸ”§ ìˆ˜ì •ëœ ë¬¸ì œì ë“¤:
    - ë³´ì•ˆ ê°•í™”: ë¯¼ê° ì •ë³´ ì œê±°, í™˜ê²½ë³€ìˆ˜ í•„ìˆ˜ ê²€ì¦
    - ë¡œì§ ìˆ˜ì •: ì‹œê°„ëŒ€ ì¡°ê±´, ë¬´í•œë£¨í”„ ë°©ì§€
    - ì¤‘ë³µ ì œê±°: í™˜ê²½ë³€ìˆ˜ ë¡œë”©, ë©”íŠ¸ë¦­ ìˆ˜ì§‘ í†µí•©
    - íƒ€ì… ì•ˆì •ì„± ê°•í™”
â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
"""

import asyncio
import aiohttp
import aioredis
import asyncpg
import json
import time
import logging
import os
import sys
import uuid
import hmac
import hashlib
import secrets
from datetime import datetime, timedelta
from dataclasses import dataclass, asdict, field
from typing import Dict, List, Optional, Tuple, Any, Union
from decimal import Decimal
from collections import deque
import numpy as np
from fastapi import FastAPI, HTTPException, BackgroundTasks, Depends, Security, status
from fastapi.middleware.cors import CORSMiddleware
from fastapi.security import HTTPBearer, HTTPAuthorizationCredentials
from pydantic import BaseModel, Field, validator
import uvicorn
from contextlib import asynccontextmanager
from dotenv import load_dotenv

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ”§ í™˜ê²½ë³€ìˆ˜ ê²€ì¦ (ìµœìš°ì„  ì‹¤í–‰)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

def validate_environment() -> bool:
    """í•„ìˆ˜ í™˜ê²½ë³€ìˆ˜ ê²€ì¦ - ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì „ ìµœìš°ì„  ì‹¤í–‰"""
    # .env íŒŒì¼ì„ í•œ ë²ˆë§Œ ë¡œë“œ
    load_dotenv()
    
    required_vars = {
        "TELEGRAM_BOT_TOKEN": "í…”ë ˆê·¸ë¨ ë´‡ í† í°",
        "TELEGRAM_CHAT_ID": "í…”ë ˆê·¸ë¨ ì±„íŒ… ID", 
        "WEBHOOK_SECRET": "ì›¹í›… ì‹œí¬ë¦¿",
        "API_KEY": "API í‚¤",
        "JWT_SECRET": "JWT ì‹œí¬ë¦¿"
    }
    
    missing = []
    invalid = []
    
    for var, desc in required_vars.items():
        value = os.getenv(var)
        if not value or value.strip() == "":
            missing.append(f"  - {var}: {desc}")
        else:
            # ê°’ í˜•ì‹ ê²€ì¦
            if var == "TELEGRAM_BOT_TOKEN" and not value.split(':')[0].isdigit():
                invalid.append(f"  - {var}: ì˜¬ë°”ë¥¸ í…”ë ˆê·¸ë¨ ë´‡ í† í° í˜•ì‹ì´ ì•„ë‹™ë‹ˆë‹¤")
            elif var == "TELEGRAM_CHAT_ID" and not value.lstrip('-').isdigit():
                invalid.append(f"  - {var}: ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤")
    
    if missing or invalid:
        error_parts = []
        if missing:
            error_parts.append("í•„ìˆ˜ í™˜ê²½ë³€ìˆ˜ê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤:\n" + "\n".join(missing))
        if invalid:
            error_parts.append("ì˜ëª»ëœ í™˜ê²½ë³€ìˆ˜ í˜•ì‹:\n" + "\n".join(invalid))
        
        error_msg = "\n\n".join(error_parts)
        error_msg += "\n\n.env íŒŒì¼ì„ ìƒì„±í•˜ê³  ì˜¬ë°”ë¥¸ ê°’ì„ ì„¤ì •í•˜ì„¸ìš”."
        raise EnvironmentError(error_msg)
    
    logging.info("í™˜ê²½ë³€ìˆ˜ ê²€ì¦ ì™„ë£Œ")
    return True

# ì• í”Œë¦¬ì¼€ì´ì…˜ ì‹œì‘ ì „ í™˜ê²½ë³€ìˆ˜ ê²€ì¦ ì‹¤í–‰
validate_environment()

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ”§ ì‹œìŠ¤í…œ ì„¤ì •
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SystemConfig:
    """Phoenix 95 Ultimate í†µí•© ì„¤ì • - ë³´ì•ˆ ê°•í™”"""
    
    # ğŸ¯ í•µì‹¬ í…”ë ˆê·¸ë¨ ì„¤ì • (ë³´ì•ˆ ê°•í™”: ê¸°ë³¸ê°’ None ì²˜ë¦¬)
    TELEGRAM = {
        "bot_token": os.getenv("TELEGRAM_BOT_TOKEN"),  # ê¸°ë³¸ê°’ ì œê±°ë¡œ ë³´ì•ˆ ê°•í™”
        "chat_id": os.getenv("TELEGRAM_CHAT_ID"),      # ê¸°ë³¸ê°’ ì œê±°ë¡œ ë³´ì•ˆ ê°•í™”
        "alerts": {
            "trade_execution": True,
            "position_updates": True, 
            "system_errors": True,
            "performance_reports": True,
            "liquidation_warnings": True,
            "daily_summary": True
        }
    }
    
    # ğŸ’° í—¤ì§€í€ë“œê¸‰ íŠ¸ë ˆì´ë”© ì„¤ì • (ë³´ìˆ˜ì  ì ‘ê·¼)
    TRADING = {
        "max_leverage": 10,  # V4ì—ì„œ 20x â†’ 10xë¡œ ì•ˆì „ì„± ê°•í™”
        "margin_mode": "ISOLATED",
        "position_size_pct": 0.02,  # ì „ì²´ ìë³¸ì˜ 2%ë§Œ ë¦¬ìŠ¤í¬
        "stop_loss_pct": 0.015,     # 1.5% ì†ì ˆ
        "take_profit_pct": 0.03,    # 3% ìµì ˆ (R:R = 1:2)
        "max_daily_loss": 1000,     # ì¼ì¼ ìµœëŒ€ ì†ì‹¤ $1000
        "max_positions": 3,         # ìµœëŒ€ 3ê°œ í¬ì§€ì…˜
        "confidence_threshold": 0.85, # 85% ì´ìƒë§Œ ê±°ë˜
        "kelly_max": 0.25,          # Kelly ìµœëŒ€ 25%
        "max_retries": 3,           # ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì¶”ê°€
        "retry_delay": 5,           # ì¬ì‹œë„ ì§€ì—° ì‹œê°„(ì´ˆ)
        "allowed_symbols": [
            "BTCUSDT", "ETHUSDT", "ADAUSDT", "SOLUSDT", "AVAXUSDT",
            "DOTUSDT", "LINKUSDT", "MATICUSDT", "ATOMUSDT", "NEARUSDT"
        ]
    }
    
    # ğŸ§  Phoenix 95 AI ì—”ì§„ ì„¤ì • (V3 ê²€ì¦ëœ íŒŒë¼ë¯¸í„°)
    PHOENIX95 = {
        "confidence_multiplier": 1.15,  # V3ì—ì„œ ìµœì í™”ëœ ê°’
        "market_condition_weight": 0.3,
        "ensemble_weights": {
            "phoenix95": 0.6,
            "lstm": 0.25, 
            "transformer": 0.15
        },
        "analysis_timeout": 2.0,  # 2ì´ˆ ì´ë‚´ ë¶„ì„ ë³´ì¥
        "min_confidence": 0.7,
        "max_confidence": 0.99,
        "cache_ttl": 300,  # ìºì‹œ TTL 5ë¶„
        "max_cache_size": 1000  # ìµœëŒ€ ìºì‹œ í¬ê¸°
    }
    
    # ğŸ’¾ ë°ì´í„°ë² ì´ìŠ¤ ì„¤ì •
    DATABASE = {
        "redis_url": os.getenv("REDIS_URL", "redis://localhost:6379"),
        "postgres_url": os.getenv("POSTGRES_URL", "postgresql://postgres:password@localhost:5432/phoenix95"),
        "connection_pool_size": 20,
        "max_connections": 100,
        "connection_timeout": 30,  # ì—°ê²° íƒ€ì„ì•„ì›ƒ ì¶”ê°€
        "query_timeout": 10        # ì¿¼ë¦¬ íƒ€ì„ì•„ì›ƒ ì¶”ê°€
    }
    
    # ğŸ”’ ë³´ì•ˆ ì„¤ì • (JWT ì‹œí¬ë¦¿ ê³ ì •)
    SECURITY = {
        "webhook_secret": os.getenv("WEBHOOK_SECRET"),  # ê¸°ë³¸ê°’ ì œê±°
        "api_key": os.getenv("API_KEY"),               # ê¸°ë³¸ê°’ ì œê±°
        "jwt_secret": os.getenv("JWT_SECRET"),         # ê¸°ë³¸ê°’ ì œê±°ë¡œ í† í° ë¬´íš¨í™” ë°©ì§€
        "allowed_ips": ["127.0.0.1", "localhost"],
        "rate_limit": 60  # ë¶„ë‹¹ 60íšŒ
    }
    
    # ğŸ“Š ëª¨ë‹ˆí„°ë§ ì„¤ì •
    MONITORING = {
        "metrics_interval": 30,    # 30ì´ˆë§ˆë‹¤ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
        "health_check_interval": 10,
        "alert_cooldown": 300,     # 5ë¶„ ì•Œë¦¼ ì¿¨ë‹¤ìš´
        "performance_threshold": {
            "response_time_ms": 2000,
            "error_rate_pct": 5,
            "memory_usage_pct": 85,
            "cpu_usage_pct": 80
        },
        "max_metrics_history": 1440  # 24ì‹œê°„ (ë¶„ë‹¹ 1ê°œ)
    }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“Š ë°ì´í„° ëª¨ë¸ (íƒ€ì… ì•ˆì •ì„± ê°•í™”)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

@dataclass
class TradingSignal:
    """íŠ¸ë ˆì´ë”© ì‹ í˜¸ - V3/V4 í†µí•© ëª¨ë¸ (íƒ€ì… ì•ˆì •ì„± ê°•í™”)"""
    signal_id: str
    symbol: str
    action: str  # buy/sell
    price: float
    confidence: float
    timestamp: datetime
    
    # Phoenix 95 ë¶„ì„ ê²°ê³¼ (Optional í•„ë“œ ëª…ì‹œì  íƒ€ì… ì²´í¬)
    phoenix95_score: Optional[float] = None
    kelly_ratio: Optional[float] = None
    recommendation: Optional[str] = None
    
    # ì‹œì¥ ë°ì´í„°
    market_conditions: Optional[Dict[str, Any]] = None
    technical_indicators: Optional[Dict[str, Any]] = None
    
    # ì²˜ë¦¬ ìƒíƒœ
    processed: bool = False
    error_message: Optional[str] = None
    
    def is_valid(self) -> bool:
        """ì‹ í˜¸ ìœ íš¨ì„± ê²€ì¦ - None ì²´í¬ ê°•í™”"""
        if not self.symbol or not self.action:
            return False
        
        return (
            self.symbol in SystemConfig.TRADING["allowed_symbols"] and
            self.action.lower() in ["buy", "sell"] and
            self.price > 0 and
            0.0 <= self.confidence <= 1.0 and
            self.confidence >= SystemConfig.TRADING["confidence_threshold"]
        )
    
    def has_phoenix95_analysis(self) -> bool:
        """Phoenix95 ë¶„ì„ ê²°ê³¼ ì¡´ì¬ ì—¬ë¶€ í™•ì¸"""
        return (
            self.phoenix95_score is not None and
            self.kelly_ratio is not None and
            self.recommendation is not None
        )
    
    def to_dict(self) -> Dict[str, Any]:
        """ë”•ì…”ë„ˆë¦¬ ë³€í™˜ - íƒ€ì… ì•ˆì •ì„± ë³´ì¥"""
        return {
            "signal_id": self.signal_id,
            "symbol": self.symbol,
            "action": self.action,
            "price": self.price,
            "confidence": self.confidence,
            "phoenix95_score": self.phoenix95_score,
            "kelly_ratio": self.kelly_ratio,
            "recommendation": self.recommendation,
            "timestamp": self.timestamp.isoformat(),
            "processed": self.processed
        }

@dataclass  
class Position:
    """í¬ì§€ì…˜ - ì™„ì „ í†µí•© ëª¨ë¸ (íƒ€ì… ì•ˆì •ì„± ê°•í™”)"""
    position_id: str
    signal_id: str
    symbol: str
    side: str  # BUY/SELL
    
    # í¬ì§€ì…˜ ì •ë³´
    entry_price: float
    quantity: float
    leverage: int
    margin_mode: str
    margin_required: float
    
    # ë¦¬ìŠ¤í¬ ê´€ë¦¬
    liquidation_price: float
    stop_loss_price: float
    take_profit_price: float
    
    # ì‹¤ì‹œê°„ ë°ì´í„°
    current_price: float = 0.0
    unrealized_pnl: float = 0.0
    pnl_percentage: float = 0.0
    liquidation_risk: float = 0.0
    
    # ìƒíƒœ
    status: str = "OPEN"  # OPEN/CLOSED/LIQUIDATED
    created_at: datetime = field(default_factory=datetime.utcnow)
    updated_at: datetime = field(default_factory=datetime.utcnow)
    
    # ì²­ì‚° ì •ë³´
    exit_price: Optional[float] = None
    exit_time: Optional[datetime] = None
    exit_reason: Optional[str] = None
    realized_pnl: Optional[float] = None
    
    def calculate_pnl(self, current_price: float) -> Tuple[float, float]:
        """P&L ê³„ì‚° - ì•ˆì „í•œ ê³„ì‚°"""
        try:
            if self.side == "BUY":
                pnl = (current_price - self.entry_price) * self.quantity
            else:
                pnl = (self.entry_price - current_price) * self.quantity
            
            pnl_pct = (pnl / self.margin_required) * 100 if self.margin_required > 0 else 0.0
            return pnl, pnl_pct
        except (ZeroDivisionError, TypeError) as e:
            logging.error(f"P&L ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0, 0.0
    
    def calculate_liquidation_risk(self, current_price: float) -> float:
        """ì²­ì‚° ìœ„í—˜ë„ ê³„ì‚° (0-1) - ì•ˆì „í•œ ê³„ì‚°"""
        try:
            if self.side == "BUY":
                distance = current_price - self.liquidation_price
                max_distance = self.entry_price - self.liquidation_price
            else:
                distance = self.liquidation_price - current_price  
                max_distance = self.liquidation_price - self.entry_price
            
            if max_distance <= 0:
                return 1.0
            
            risk = 1 - (distance / max_distance)
            return max(0.0, min(1.0, risk))
        except (ZeroDivisionError, TypeError) as e:
            logging.error(f"ì²­ì‚° ìœ„í—˜ë„ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.0

@dataclass
class PerformanceMetrics:
    """ì„±ëŠ¥ ë©”íŠ¸ë¦­ - íƒ€ì… ì•ˆì •ì„± ê°•í™”"""
    timestamp: datetime
    
    # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­
    cpu_usage: float
    memory_usage: float  
    response_time_ms: float
    active_connections: int
    
    # íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­
    active_positions: int
    total_pnl: float
    win_rate: float
    avg_trade_duration: float
    phoenix95_avg_score: float
    
    # ë¦¬ìŠ¤í¬ ë©”íŠ¸ë¦­
    max_drawdown: float
    var_95: float  # Value at Risk
    sharpe_ratio: float

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ§  Phoenix 95 AI ì—”ì§„ (ì¤‘ë³µ ì œê±°, ì„±ëŠ¥ ìµœì í™”)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Phoenix95AIEngine:
    """Phoenix 95 Ultimate AI ì—”ì§„ - V3 ê²€ì¦ + V4 ê³ ë„í™” (ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€)"""
    
    def __init__(self):
        self.config = SystemConfig.PHOENIX95
        # ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€: í¬ê¸° ì œí•œì´ ìˆëŠ” ìºì‹œ
        self.analysis_cache: Dict[str, Dict[str, Any]] = {}
        self.model_performance = deque(maxlen=1000)
        
        # V3ì—ì„œ ê²€ì¦ëœ íŒŒë¼ë¯¸í„°
        self.confidence_multiplier = self.config["confidence_multiplier"]
        self.market_weight = self.config["market_condition_weight"]
        
        # ìºì‹œ ê´€ë¦¬
        self.max_cache_size = self.config["max_cache_size"]
        self.cache_ttl = self.config["cache_ttl"]
        
    async def analyze_signal_complete(self, signal: TradingSignal) -> Tuple[float, float, str]:
        """
        ì™„ì „ ì‹ í˜¸ ë¶„ì„ - V3 ì•Œê³ ë¦¬ì¦˜ + V4 ê³ ë„í™” (íƒ€ì„ì•„ì›ƒ ë° ì¬ì‹œë„ ë¡œì§ ì¶”ê°€)
        Returns: (phoenix95_score, kelly_ratio, recommendation)
        """
        start_time = time.time()
        
        try:
            # 1. ìºì‹œ í™•ì¸ (TTL ì²´í¬ í¬í•¨)
            cache_key = f"{signal.symbol}_{signal.price}_{signal.confidence}"
            cached_result = self._get_from_cache(cache_key)
            if cached_result:
                return cached_result
            
            # 2. íƒ€ì„ì•„ì›ƒ ë‚´ì—ì„œ ë¶„ì„ ìˆ˜í–‰
            analysis_timeout = self.config["analysis_timeout"]
            
            try:
                result = await asyncio.wait_for(
                    self._perform_analysis(signal),
                    timeout=analysis_timeout
                )
            except asyncio.TimeoutError:
                logging.warning(f"Phoenix95 ë¶„ì„ íƒ€ì„ì•„ì›ƒ: {signal.symbol}")
                return 0.0, 0.0, "REJECT"
            
            phoenix95_score, kelly_ratio, recommendation = result
            
            # 3. ë¶„ì„ ì‹œê°„ ê²€ì¦
            analysis_time = time.time() - start_time
            if analysis_time > analysis_timeout:
                logging.warning(f"Phoenix95 ë¶„ì„ ì‹œê°„ ì´ˆê³¼: {analysis_time:.2f}ì´ˆ")
            
            # 4. ê²°ê³¼ ìºì‹± (ë©”ëª¨ë¦¬ ê´€ë¦¬ í¬í•¨)
            self._store_in_cache(cache_key, (phoenix95_score, kelly_ratio, recommendation))
            
            # 5. ì„±ëŠ¥ ì¶”ì 
            self.model_performance.append({
                'score': phoenix95_score,
                'analysis_time': analysis_time,
                'timestamp': datetime.utcnow()
            })
            
            return phoenix95_score, kelly_ratio, recommendation
            
        except Exception as e:
            logging.error(f"Phoenix95 ë¶„ì„ ì‹¤íŒ¨: {e}")
            return 0.0, 0.0, "REJECT"
    
    def _get_from_cache(self, cache_key: str) -> Optional[Tuple[float, float, str]]:
        """ìºì‹œì—ì„œ ê²°ê³¼ ì¡°íšŒ (TTL ì²´í¬ í¬í•¨)"""
        if cache_key in self.analysis_cache:
            cached = self.analysis_cache[cache_key]
            # TTL ì²´í¬
            if (datetime.utcnow() - cached['timestamp']).seconds < self.cache_ttl:
                return cached['result']
            else:
                # ë§Œë£Œëœ ìºì‹œ ì œê±°
                del self.analysis_cache[cache_key]
        return None
    
    def _store_in_cache(self, cache_key: str, result: Tuple[float, float, str]):
        """ìºì‹œì— ê²°ê³¼ ì €ì¥ (ë©”ëª¨ë¦¬ ê´€ë¦¬ í¬í•¨)"""
        # ìºì‹œ í¬ê¸° ì œí•œ
        if len(self.analysis_cache) >= self.max_cache_size:
            # ê°€ì¥ ì˜¤ë˜ëœ í•­ëª©ë“¤ ì œê±° (LRU ë°©ì‹)
            oldest_keys = sorted(
                self.analysis_cache.keys(),
                key=lambda k: self.analysis_cache[k]['timestamp']
            )[:100]  # 100ê°œì”© ì œê±°
            
            for key in oldest_keys:
                del self.analysis_cache[key]
        
        self.analysis_cache[cache_key] = {
            'result': result,
            'timestamp': datetime.utcnow()
        }
    
    async def _perform_analysis(self, signal: TradingSignal) -> Tuple[float, float, str]:
        """ì‹¤ì œ ë¶„ì„ ìˆ˜í–‰"""
        # 1. V3 ê²€ì¦ëœ Phoenix 95 í•µì‹¬ ë¶„ì„
        phoenix95_score = await self._phoenix95_core_analysis(signal)
        
        # 2. V4 ì•™ìƒë¸” ëª¨ë¸ ë¶„ì„
        ensemble_boost = await self._ensemble_analysis(signal)
        phoenix95_score = min(phoenix95_score * ensemble_boost, self.config["max_confidence"])
        
        # 3. ì‹œì¥ ì¡°ê±´ íŒ©í„°
        market_factor = await self._analyze_market_conditions(signal.symbol)
        phoenix95_score *= market_factor
        
        # 4. Kelly Criterion ê³„ì‚° (V3 ê²€ì¦ëœ ê³µì‹)
        kelly_ratio = await self._calculate_kelly_criterion(phoenix95_score)
        
        # 5. ìµœì¢… ì¶”ì²œ ìƒì„±
        recommendation = await self._generate_recommendation(phoenix95_score, kelly_ratio)
        
        return phoenix95_score, kelly_ratio, recommendation
    
    async def _phoenix95_core_analysis(self, signal: TradingSignal) -> float:
        """Phoenix 95 í•µì‹¬ ë¶„ì„ ì•Œê³ ë¦¬ì¦˜ - V3 ê²€ì¦ëœ ë¡œì§ (ì‹œê°„ëŒ€ ì¡°ê±´ ìˆ˜ì •)"""
        base_confidence = signal.confidence
        
        # V3ì—ì„œ ê²€ì¦ëœ ì‹ ë¢°ë„ ë¶€ìŠ¤íŒ…
        boosted_confidence = base_confidence * self.confidence_multiplier
        
        # ì‹œê°„ëŒ€ë³„ ê°€ì¤‘ì¹˜ (V3 íŒ¨í„´) - ë…¼ë¦¬ ì˜¤ë¥˜ ìˆ˜ì •
        hour = datetime.utcnow().hour
        time_weight = 1.0
        if 8 <= hour <= 16:  # ìœ ëŸ½ ì‹œê°„
            time_weight = 1.1
        elif hour >= 21 or hour <= 5:  # ë¯¸êµ­ ì‹œê°„ (ìˆ˜ì •: 21ì‹œ ì´í›„ ë˜ëŠ” 5ì‹œ ì´ì „)
            time_weight = 1.05
        
        # ì‹¬ë³¼ë³„ ê°€ì¤‘ì¹˜
        symbol_weights = {
            "BTCUSDT": 1.0,
            "ETHUSDT": 0.95,
            "ADAUSDT": 0.9,
            "SOLUSDT": 0.9
        }
        symbol_weight = symbol_weights.get(signal.symbol, 0.85)
        
        # ìµœì¢… Phoenix 95 ì ìˆ˜
        phoenix95_score = boosted_confidence * time_weight * symbol_weight
        return min(phoenix95_score, self.config["max_confidence"])
    
    async def _ensemble_analysis(self, signal: TradingSignal) -> float:
        """ì•™ìƒë¸” ëª¨ë¸ ë¶„ì„ - V4 ê³ ë„í™”"""
        weights = self.config["ensemble_weights"]
        
        # LSTM ì˜ˆì¸¡ ì‹œë®¬ë ˆì´ì…˜
        lstm_score = min(signal.confidence * 1.05, 1.0)
        
        # Transformer ì˜ˆì¸¡ ì‹œë®¬ë ˆì´ì…˜  
        transformer_score = min(signal.confidence * 1.08, 1.0)
        
        # ê°€ì¤‘ í‰ê· ìœ¼ë¡œ ë¶€ìŠ¤íŠ¸ íŒ©í„° ê³„ì‚°
        ensemble_score = (
            weights["phoenix95"] * signal.confidence +
            weights["lstm"] * lstm_score +
            weights["transformer"] * transformer_score
        )
        
        # ë¶€ìŠ¤íŠ¸ íŒ©í„° ë°˜í™˜ (1.0 = ë³€í™”ì—†ìŒ, 1.1 = 10% ì¦ê°€)
        boost_factor = ensemble_score / signal.confidence if signal.confidence > 0 else 1.0
        return min(boost_factor, 1.15)  # ìµœëŒ€ 15% ë¶€ìŠ¤íŠ¸
    
    async def _analyze_market_conditions(self, symbol: str) -> float:
        """ì‹œì¥ ì¡°ê±´ ë¶„ì„"""
        try:
            # ì‹¤ì œë¡œëŠ” Binance APIì—ì„œ ë°ì´í„° ìˆ˜ì§‘
            # ì—¬ê¸°ì„œëŠ” ì‹œê°„ ê¸°ë°˜ ê°„ë‹¨í•œ ì‹œë®¬ë ˆì´ì…˜
            hour = datetime.utcnow().hour
            
            # ê±°ë˜ëŸ‰ í™œë°œí•œ ì‹œê°„ëŒ€
            if 8 <= hour <= 16 or 21 <= hour <= 23:
                return 1.1
            elif 2 <= hour <= 6:  # ì €ì¡°í•œ ì‹œê°„ëŒ€
                return 0.9
            else:
                return 1.0
                
        except Exception as e:
            logging.error(f"ì‹œì¥ ì¡°ê±´ ë¶„ì„ ì‹¤íŒ¨: {e}")
            return 1.0
    
    async def _calculate_kelly_criterion(self, phoenix95_score: float) -> float:
        """Kelly Criterion ê³„ì‚° - V3 ê²€ì¦ëœ ê³µì‹"""
        try:
            # ìŠ¹ë¥  ì¶”ì • (Phoenix 95 ì ìˆ˜ ê¸°ë°˜)
            win_probability = phoenix95_score
            
            # ì†ìµ ë¹„ìœ¨ (ì†ì ˆ 1.5% vs ìµì ˆ 3% = 1:2)
            win_loss_ratio = (
                SystemConfig.TRADING["take_profit_pct"] / 
                SystemConfig.TRADING["stop_loss_pct"]
            )
            
            # Kelly Formula: (bp - q) / b
            # b = ì†ìµë¹„ìœ¨, p = ìŠ¹ë¥ , q = íŒ¨ë°°ìœ¨
            kelly_ratio = (
                (win_probability * win_loss_ratio - (1 - win_probability)) / 
                win_loss_ratio
            )
            
            # ë³´ìˆ˜ì  ì œí•œ (ìµœëŒ€ 25%)
            kelly_ratio = max(0.01, min(kelly_ratio, SystemConfig.TRADING["kelly_max"]))
            
            return kelly_ratio
        except (ZeroDivisionError, TypeError) as e:
            logging.error(f"Kelly Criterion ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 0.01
    
    async def _generate_recommendation(self, phoenix95_score: float, kelly_ratio: float) -> str:
        """ìµœì¢… ì¶”ì²œ ìƒì„±"""
        if phoenix95_score >= 0.95 and kelly_ratio >= 0.2:
            return "STRONG_BUY"
        elif phoenix95_score >= 0.85 and kelly_ratio >= 0.15:
            return "BUY"
        elif phoenix95_score >= 0.75 and kelly_ratio >= 0.1:
            return "WEAK_BUY"
        elif phoenix95_score >= 0.6:
            return "HOLD"
        else:
            return "REJECT"
    
    def get_performance_stats(self) -> Dict[str, Union[float, int]]:
        """ëª¨ë¸ ì„±ëŠ¥ í†µê³„"""
        if not self.model_performance:
            return {}
        
        scores = [p['score'] for p in self.model_performance]
        times = [p['analysis_time'] for p in self.model_performance]
        
        return {
            "avg_score": np.mean(scores),
            "score_std": np.std(scores),
            "avg_analysis_time": np.mean(times),
            "max_analysis_time": np.max(times),
            "total_analyses": len(self.model_performance),
            "cache_size": len(self.analysis_cache),
            "cache_hit_rate": 0.0  # ì‹¤ì œ êµ¬í˜„ì—ì„œëŠ” ìºì‹œ íˆíŠ¸ìœ¨ ì¶”ì 
        }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              âš¡ ë ˆë²„ë¦¬ì§€ íŠ¸ë ˆì´ë”© ì—”ì§„ (ë¬´í•œë£¨í”„ ë°©ì§€, ì¬ì‹œë„ ë¡œì§)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class UltimateLeverageTrader:
    """Ultimate ë ˆë²„ë¦¬ì§€ íŠ¸ë ˆì´ë”© ì—”ì§„ - V3 ì•ˆì •ì„± + V4 ê³ ë„í™” (ë¬´í•œë£¨í”„ ë°©ì§€)"""
    
    def __init__(self, redis_client, postgres_pool, telegram_notifier):
        self.redis = redis_client
        self.postgres = postgres_pool
        self.telegram = telegram_notifier
        self.active_positions: Dict[str, Position] = {}
        self.monitoring_tasks: Dict[str, asyncio.Task] = {}
        self.risk_metrics = deque(maxlen=1000)
        
        # ì¬ì‹œë„ ì„¤ì •
        self.max_retries = SystemConfig.TRADING["max_retries"]
        self.retry_delay = SystemConfig.TRADING["retry_delay"]
        
    async def execute_trade_complete(self, signal: TradingSignal, 
                                   phoenix95_score: float, 
                                   kelly_ratio: float) -> Optional[Position]:
        """ì™„ì „í•œ ê±°ë˜ ì‹¤í–‰ - 500ms ì´ë‚´ ë³´ì¥ (ì¬ì‹œë„ ë¡œì§ í¬í•¨)"""
        execution_start = time.time()
        
        for attempt in range(self.max_retries + 1):
            try:
                # 1. ì¢…í•© ë¦¬ìŠ¤í¬ ì²´í¬
                risk_check = await self._comprehensive_risk_check(signal)
                if not risk_check["approved"]:
                    logging.warning(f"ë¦¬ìŠ¤í¬ ì²´í¬ ì‹¤íŒ¨ (ì‹œë„ {attempt + 1}): {risk_check['reason']}")
                    if attempt == self.max_retries:
                        await self.telegram.send_message(f"âš ï¸ ê±°ë˜ ê±°ë¶€: {risk_check['reason']}")
                        return None
                    await asyncio.sleep(self.retry_delay)
                    continue
                
                # 2. í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° (Kelly + ë¦¬ìŠ¤í¬ ì¡°ì •)
                position_size_usd = await self._calculate_optimal_position_size(kelly_ratio, signal)
                
                # 3. ë ˆë²„ë¦¬ì§€ ê³„ì‚°
                leverage = await self._calculate_optimal_leverage(phoenix95_score)
                
                # 4. ìˆ˜ëŸ‰ ë° ë§ˆì§„ ê³„ì‚° (Zero Division ë°©ì§€)
                if signal.price <= 0 or leverage <= 0:
                    raise ValueError(f"ì˜ëª»ëœ ê°€ê²© ë˜ëŠ” ë ˆë²„ë¦¬ì§€: price={signal.price}, leverage={leverage}")
                
                quantity = position_size_usd / signal.price
                margin_required = position_size_usd / leverage
                
                # 5. ë¦¬ìŠ¤í¬ ê°€ê²© ê³„ì‚°
                liquidation_price = self._calculate_liquidation_price(signal, leverage)
                stop_loss_price = self._calculate_stop_loss_price(signal)
                take_profit_price = self._calculate_take_profit_price(signal)
                
                # 6. í¬ì§€ì…˜ ê°ì²´ ìƒì„±
                position = Position(
                    position_id=f"POS_{uuid.uuid4().hex[:8].upper()}",
                    signal_id=signal.signal_id,
                    symbol=signal.symbol,
                    side=signal.action.upper(),
                    entry_price=signal.price,
                    quantity=quantity,
                    leverage=leverage,
                    margin_mode=SystemConfig.TRADING["margin_mode"],
                    margin_required=margin_required,
                    liquidation_price=liquidation_price,
                    stop_loss_price=stop_loss_price,
                    take_profit_price=take_profit_price,
                    current_price=signal.price
                )
                
                # 7. ë°ì´í„°ë² ì´ìŠ¤ ì €ì¥
                await self._save_position_to_db(position)
                await self._save_signal_to_db(signal)
                
                # 8. ë©”ëª¨ë¦¬ì— í¬ì§€ì…˜ ì¶”ê°€
                self.active_positions[position.position_id] = position
                
                # 9. ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ ì‹œì‘
                await self._start_position_monitoring(position)
                
                # 10. ì‹¤í–‰ ì‹œê°„ ê²€ì¦
                execution_time = (time.time() - execution_start) * 1000
                if execution_time > 500:
                    logging.warning(f"ê±°ë˜ ì‹¤í–‰ ì‹œê°„ ì´ˆê³¼: {execution_time:.0f}ms")
                
                # 11. ì„±ê³µ ì•Œë¦¼
                await self.telegram.send_trade_notification(position, phoenix95_score, kelly_ratio)
                
                logging.info(f"ê±°ë˜ ì‹¤í–‰ ì™„ë£Œ: {position.position_id} ({execution_time:.0f}ms)")
                return position
                
            except Exception as e:
                logging.error(f"ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨ (ì‹œë„ {attempt + 1}): {e}")
                if attempt == self.max_retries:
                    await self.telegram.send_message(f"ğŸš¨ ê±°ë˜ ì‹¤í–‰ ì˜¤ë¥˜: {str(e)}")
                    return None
                await asyncio.sleep(self.retry_delay)
        
        return None
    
    async def _comprehensive_risk_check(self, signal: TradingSignal) -> Dict[str, Any]:
        """ì¢…í•© ë¦¬ìŠ¤í¬ ì²´í¬ (íƒ€ì… ì•ˆì •ì„± ê°•í™”)"""
        risk_factors = []
        
        # 1. ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ì²´í¬
        if len(self.active_positions) >= SystemConfig.TRADING["max_positions"]:
            return {"approved": False, "reason": "ìµœëŒ€ í¬ì§€ì…˜ ìˆ˜ ì´ˆê³¼"}
        
        # 2. ì¼ì¼ ì†ì‹¤ í•œë„ ì²´í¬
        daily_pnl = await self._get_daily_pnl()
        if daily_pnl <= -SystemConfig.TRADING["max_daily_loss"]:
            return {"approved": False, "reason": "ì¼ì¼ ì†ì‹¤ í•œë„ ì´ˆê³¼"}
        
        # 3. ì‹¬ë³¼ ì¤‘ë³µ ì²´í¬  
        symbol_positions = [p for p in self.active_positions.values() if p.symbol == signal.symbol]
        if len(symbol_positions) >= 1:  # ì‹¬ë³¼ë‹¹ 1ê°œë§Œ
            return {"approved": False, "reason": f"{signal.symbol} í¬ì§€ì…˜ ì´ë¯¸ ì¡´ì¬"}
        
        # 4. ì‹œì¥ ì‹œê°„ ì²´í¬
        now = datetime.utcnow()
        if now.weekday() >= 5:  # ì£¼ë§
            return {"approved": False, "reason": "ì£¼ë§ ê±°ë˜ ê¸ˆì§€"}
        
        # 5. ì‹ ë¢°ë„ ì¬í™•ì¸ (None ì²´í¬ í¬í•¨)
        if signal.phoenix95_score is not None and signal.phoenix95_score < SystemConfig.TRADING["confidence_threshold"]:
            risk_factors.append("ë‚®ì€ ì‹ ë¢°ë„")
        
        # 6. ë³€ë™ì„± ì²´í¬ (ê°„ë‹¨í•œ êµ¬í˜„)
        volatility_risk = await self._check_volatility_risk(signal.symbol)
        if volatility_risk > 0.8:
            risk_factors.append("ë†’ì€ ë³€ë™ì„±")
        
        risk_score = len(risk_factors) / 6  # ì •ê·œí™”
        
        return {
            "approved": risk_score < 0.5,
            "reason": "ë¦¬ìŠ¤í¬ ì²´í¬ í†µê³¼" if risk_score < 0.5 else f"ìœ„í—˜ ìš”ì†Œ: {', '.join(risk_factors)}",
            "risk_score": risk_score,
            "risk_factors": risk_factors
        }
    
    async def _calculate_optimal_position_size(self, kelly_ratio: float, signal: TradingSignal) -> float:
        """ìµœì  í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° (ì•ˆì „í•œ ê³„ì‚°)"""
        try:
            # ê³„ì¢Œ ì”ê³  (ì‹¤ì œë¡œëŠ” ê±°ë˜ì†Œ APIì—ì„œ ì¡°íšŒ)
            account_balance = float(os.getenv("ACCOUNT_BALANCE", "50000"))
            
            # Kelly ê¸°ë°˜ ê¸°ë³¸ í¬ì§€ì…˜ í¬ê¸°
            kelly_position = account_balance * kelly_ratio
            
            # ì„¤ì •ëœ ìµœëŒ€ í¬ì§€ì…˜ í¬ê¸° ì œí•œ
            max_position_size = account_balance * SystemConfig.TRADING["position_size_pct"]
            
            # ìµœì¢… í¬ì§€ì…˜ í¬ê¸° (ë³´ìˆ˜ì  ì ‘ê·¼)
            position_size = min(kelly_position, max_position_size)
            
            # ìµœì†Œ/ìµœëŒ€ ì œí•œ
            min_position = 100.0  # ìµœì†Œ $100
            max_position = 10000.0  # ìµœëŒ€ $10,000
            
            return max(min_position, min(position_size, max_position))
        except (ValueError, TypeError) as e:
            logging.error(f"í¬ì§€ì…˜ í¬ê¸° ê³„ì‚° ì˜¤ë¥˜: {e}")
            return 100.0  # ê¸°ë³¸ê°’
    
    async def _calculate_optimal_leverage(self, phoenix95_score: float) -> int:
        """ìµœì  ë ˆë²„ë¦¬ì§€ ê³„ì‚°"""
        max_leverage = SystemConfig.TRADING["max_leverage"]
        
        # ì‹ ë¢°ë„ ê¸°ë°˜ ë ˆë²„ë¦¬ì§€ ì¡°ì •
        if phoenix95_score >= 0.95:
            return max_leverage
        elif phoenix95_score >= 0.9:
            return min(8, max_leverage)
        elif phoenix95_score >= 0.85:
            return min(5, max_leverage)
        else:
            return min(3, max_leverage)
    
    def _calculate_liquidation_price(self, signal: TradingSignal, leverage: int) -> float:
        """ì²­ì‚°ê°€ ê³„ì‚° (ì•ˆì „í•œ ê³„ì‚°)"""
        try:
            maintenance_margin_rate = 0.004  # 0.4%
            
            if signal.action.lower() == "buy":
                return signal.price * (1 - (1/leverage) + maintenance_margin_rate)
            else:
                return signal.price * (1 + (1/leverage) - maintenance_margin_rate)
        except (ZeroDivisionError, TypeError) as e:
            logging.error(f"ì²­ì‚°ê°€ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return signal.price * 0.9  # ì•ˆì „í•œ ê¸°ë³¸ê°’
    
    def _calculate_stop_loss_price(self, signal: TradingSignal) -> float:
        """ì†ì ˆê°€ ê³„ì‚°"""
        stop_pct = SystemConfig.TRADING["stop_loss_pct"]
        
        if signal.action.lower() == "buy":
            return signal.price * (1 - stop_pct)
        else:
            return signal.price * (1 + stop_pct)
    
    def _calculate_take_profit_price(self, signal: TradingSignal) -> float:
        """ìµì ˆê°€ ê³„ì‚°"""
        profit_pct = SystemConfig.TRADING["take_profit_pct"]
        
        if signal.action.lower() == "buy":
            return signal.price * (1 + profit_pct)
        else:
            return signal.price * (1 - profit_pct)
    
    async def _start_position_monitoring(self, position: Position):
        """ì‹¤ì‹œê°„ í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì‹œì‘"""
        task = asyncio.create_task(self._monitor_position_realtime(position))
        self.monitoring_tasks[position.position_id] = task
        
        # Redisì— í¬ì§€ì…˜ ì •ë³´ ì €ì¥
        try:
            await self.redis.hset(
                f"position:{position.position_id}",
                mapping={
                    "symbol": position.symbol,
                    "side": position.side,
                    "entry_price": str(position.entry_price),
                    "quantity": str(position.quantity),
                    "leverage": str(position.leverage),
                    "status": position.status,
                    "created_at": position.created_at.isoformat()
                }
            )
        except Exception as e:
            logging.error(f"Redis í¬ì§€ì…˜ ì €ì¥ ì‹¤íŒ¨: {e}")
    
    async def _monitor_position_realtime(self, position: Position):
        """ì‹¤ì‹œê°„ í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ (ë¬´í•œë£¨í”„ ë°©ì§€ ë° ì¬ì‹œë„ ì œí•œ)"""
        logging.info(f"í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì‹œì‘: {position.position_id}")
        
        retry_count = 0
        max_consecutive_errors = 10  # ì—°ì† ì˜¤ë¥˜ ì œí•œ
        
        while position.status == "OPEN" and retry_count < max_consecutive_errors:
            try:
                # í˜„ì¬ê°€ ì¡°íšŒ
                current_price = await self._get_current_price(position.symbol)
                if current_price <= 0:
                    raise ValueError(f"ì˜ëª»ëœ ê°€ê²©: {current_price}")
                
                position.current_price = current_price
                
                # P&L ê³„ì‚°
                pnl, pnl_pct = position.calculate_pnl(current_price)
                position.unrealized_pnl = pnl
                position.pnl_percentage = pnl_pct
                
                # ì²­ì‚° ìœ„í—˜ë„ ê³„ì‚°
                risk = position.calculate_liquidation_risk(current_price)
                position.liquidation_risk = risk
                
                # ì¢…ë£Œ ì¡°ê±´ ì²´í¬
                exit_reason = await self._check_exit_conditions(position, current_price)
                if exit_reason:
                    await self._close_position(position, current_price, exit_reason)
                    break
                
                # Redis ì—…ë°ì´íŠ¸ (ì•ˆì „í•œ ì—…ë°ì´íŠ¸)
                try:
                    await self.redis.hset(
                        f"position:{position.position_id}",
                        mapping={
                            "current_price": str(current_price),
                            "unrealized_pnl": str(pnl),
                            "pnl_percentage": str(pnl_pct),
                            "liquidation_risk": str(risk),
                            "updated_at": datetime.utcnow().isoformat()
                        }
                    )
                except Exception as redis_error:
                    logging.warning(f"Redis ì—…ë°ì´íŠ¸ ì‹¤íŒ¨: {redis_error}")
                
                # ìœ„í—˜ ì•Œë¦¼ ì²´í¬
                if risk > 0.8:
                    await self.telegram.send_liquidation_warning(position)
                
                # ì„±ê³µì ì¸ ë°˜ë³µ í›„ retry_count ë¦¬ì…‹
                retry_count = 0
                await asyncio.sleep(1)  # 1ì´ˆë§ˆë‹¤ ì²´í¬
                
            except Exception as e:
                retry_count += 1
                logging.error(f"í¬ì§€ì…˜ ëª¨ë‹ˆí„°ë§ ì˜¤ë¥˜ {position.position_id} (ì¬ì‹œë„ {retry_count}): {e}")
                
                if retry_count >= max_consecutive_errors:
                    logging.critical(f"í¬ì§€ì…˜ {position.position_id} ëª¨ë‹ˆí„°ë§ ì¤‘ë‹¨ (ìµœëŒ€ ì˜¤ë¥˜ íšŸìˆ˜ ì´ˆê³¼)")
                    break
                
                await asyncio.sleep(min(5 * retry_count, 30))  # ì§€ìˆ˜ì  ë°±ì˜¤í”„ (ìµœëŒ€ 30ì´ˆ)
        
        # ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì •ë¦¬
        if position.position_id in self.monitoring_tasks:
            del self.monitoring_tasks[position.position_id]
        
        if retry_count >= max_consecutive_errors:
            await self.telegram.send_system_notification(
                f"í¬ì§€ì…˜ {position.position_id} ëª¨ë‹ˆí„°ë§ ì‹¤íŒ¨", "CRITICAL"
            )
    
    async def _get_current_price(self, symbol: str) -> float:
        """í˜„ì¬ê°€ ì¡°íšŒ (ì‹œë®¬ë ˆì´ì…˜ - í”„ë¡œë•ì…˜ì—ì„œëŠ” ì‹¤ì œ API ì‚¬ìš© í•„ìš”)"""
        # âš ï¸ ê²½ê³ : ì´ê²ƒì€ ì‹œë®¬ë ˆì´ì…˜ì…ë‹ˆë‹¤. ì‹¤ì œ ìš´ì˜ì—ì„œëŠ” Binance API ì‚¬ìš©í•˜ì„¸ìš”!
        logging.warning(f"âš ï¸ ì‹œë®¬ë ˆì´ì…˜ ëª¨ë“œ: {symbol} ê°€ê²© ì¡°íšŒ")
        
        # ì‹¤ì œë¡œëŠ” ë‹¤ìŒê³¼ ê°™ì´ Binance API í˜¸ì¶œ:
        # try:
        #     async with aiohttp.ClientSession() as session:
        #         url = f"https://api.binance.com/api/v3/ticker/price?symbol={symbol}"
        #         async with session.get(url, timeout=5) as response:
        #             if response.status == 200:
        #                 data = await response.json()
        #                 return float(data['price'])
        #             else:
        #                 raise aiohttp.ClientError(f"API ì‘ë‹µ ì˜¤ë¥˜: {response.status}")
        # except Exception as e:
        #     logging.error(f"Binance API í˜¸ì¶œ ì‹¤íŒ¨: {e}")
        #     raise
        
        base_prices = {
            "BTCUSDT": 45000, "ETHUSDT": 3000, "ADAUSDT": 0.5,
            "SOLUSDT": 100, "AVAXUSDT": 40, "DOTUSDT": 8
        }
        
        base_price = base_prices.get(symbol, 45000)
        
        # ê°„ë‹¨í•œ ê°€ê²© ë³€ë™ ì‹œë®¬ë ˆì´ì…˜
        import random
        change = random.uniform(-0.01, 0.01)  # Â±1% ë³€ë™
        price = base_price * (1 + change)
        
        # ê°€ê²© ìœ íš¨ì„± ê²€ì¦
        if price <= 0:
            logging.error(f"ì˜ëª»ëœ ê°€ê²© ìƒì„±: {price}")
            return base_price
        
        return price
    
    async def _check_exit_conditions(self, position: Position, current_price: float) -> Optional[str]:
        """í¬ì§€ì…˜ ì¢…ë£Œ ì¡°ê±´ ì²´í¬ (íƒ€ì… ì•ˆì •ì„± ê°•í™”)"""
        try:
            # ì†ì ˆê°€ ì²´í¬
            if position.side == "BUY" and current_price <= position.stop_loss_price:
                return "STOP_LOSS"
            if position.side == "SELL" and current_price >= position.stop_loss_price:
                return "STOP_LOSS"
            
            # ìµì ˆê°€ ì²´í¬  
            if position.side == "BUY" and current_price >= position.take_profit_price:
                return "TAKE_PROFIT"
            if position.side == "SELL" and current_price <= position.take_profit_price:
                return "TAKE_PROFIT"
            
            # ê¸´ê¸‰ ì²­ì‚° ì²´í¬ (ì²­ì‚°ê°€ 5% ì´ë‚´ ì ‘ê·¼)
            if position.liquidation_risk > 0.95:
                return "EMERGENCY_LIQUIDATION"
            
            return None
        except Exception as e:
            logging.error(f"ì¢…ë£Œ ì¡°ê±´ ì²´í¬ ì˜¤ë¥˜: {e}")
            return None
    
    async def _close_position(self, position: Position, exit_price: float, exit_reason: str):
        """í¬ì§€ì…˜ ì²­ì‚° (ì•ˆì „í•œ ì²­ì‚°)"""
        try:
            position.status = "CLOSED"
            position.exit_price = exit_price
            position.exit_time = datetime.utcnow()
            position.exit_reason = exit_reason
            
            # ìµœì¢… P&L ê³„ì‚°
            final_pnl, final_pnl_pct = position.calculate_pnl(exit_price)
            position.realized_pnl = final_pnl
            
            # ë°ì´í„°ë² ì´ìŠ¤ ì—…ë°ì´íŠ¸
            await self._update_position_in_db(position)
            await self._save_trade_history(position)
            
            # ë©”ëª¨ë¦¬ì—ì„œ ì œê±°
            if position.position_id in self.active_positions:
                del self.active_positions[position.position_id]
            
            # Redis ì •ë¦¬
            try:
                await self.redis.delete(f"position:{position.position_id}")
            except Exception as redis_error:
                logging.warning(f"Redis ì •ë¦¬ ì‹¤íŒ¨: {redis_error}")
            
            # ì²­ì‚° ì•Œë¦¼
            await self.telegram.send_close_notification(position, exit_reason)
            
            logging.info(f"í¬ì§€ì…˜ ì²­ì‚° ì™„ë£Œ: {position.position_id} | P&L: ${final_pnl:.2f} | ì‚¬ìœ : {exit_reason}")
        except Exception as e:
            logging.error(f"í¬ì§€ì…˜ ì²­ì‚° ì‹¤íŒ¨: {e}")
    
    async def _save_position_to_db(self, position: Position):
        """í¬ì§€ì…˜ DB ì €ì¥ (ì—°ê²° íƒ€ì„ì•„ì›ƒ ë° ì¬ì‹œë„)"""
        for attempt in range(3):  # 3íšŒ ì¬ì‹œë„
            try:
                async with asyncio.wait_for(self.postgres.acquire(), timeout=10) as conn:
                    await conn.execute("""
                        INSERT INTO positions (
                            position_id, signal_id, symbol, side, entry_price, quantity,
                            leverage, margin_mode, margin_required, liquidation_price,
                            stop_loss_price, take_profit_price, status, created_at
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)
                    """, position.position_id, position.signal_id, position.symbol, position.side,
                    position.entry_price, position.quantity, position.leverage, position.margin_mode,
                    position.margin_required, position.liquidation_price, position.stop_loss_price,
                    position.take_profit_price, position.status, position.created_at)
                return  # ì„±ê³µ ì‹œ ì¢…ë£Œ
            except asyncio.TimeoutError:
                logging.warning(f"í¬ì§€ì…˜ DB ì €ì¥ íƒ€ì„ì•„ì›ƒ (ì‹œë„ {attempt + 1})")
            except Exception as e:
                logging.error(f"í¬ì§€ì…˜ DB ì €ì¥ ì‹¤íŒ¨ (ì‹œë„ {attempt + 1}): {e}")
            
            if attempt < 2:  # ë§ˆì§€ë§‰ ì‹œë„ê°€ ì•„ë‹ˆë©´ ëŒ€ê¸°
                await asyncio.sleep(2 ** attempt)  # ì§€ìˆ˜ì  ë°±ì˜¤í”„
    
    async def _save_signal_to_db(self, signal: TradingSignal):
        """ì‹ í˜¸ DB ì €ì¥ (ì¬ì‹œë„ ë¡œì§ í¬í•¨)"""
        for attempt in range(3):
            try:
                async with asyncio.wait_for(self.postgres.acquire(), timeout=10) as conn:
                    await conn.execute("""
                        INSERT INTO signals (
                            signal_id, symbol, action, price, confidence, phoenix95_score,
                            kelly_ratio, recommendation, timestamp, processed
                        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)
                    """, signal.signal_id, signal.symbol, signal.action, signal.price,
                    signal.confidence, signal.phoenix95_score, signal.kelly_ratio,
                    signal.recommendation, signal.timestamp, signal.processed)
                return
            except asyncio.TimeoutError:
                logging.warning(f"ì‹ í˜¸ DB ì €ì¥ íƒ€ì„ì•„ì›ƒ (ì‹œë„ {attempt + 1})")
            except Exception as e:
                logging.error(f"ì‹ í˜¸ DB ì €ì¥ ì‹¤íŒ¨ (ì‹œë„ {attempt + 1}): {e}")
            
            if attempt < 2:
                await asyncio.sleep(2 ** attempt)
    
    async def _update_position_in_db(self, position: Position):
        """í¬ì§€ì…˜ DB ì—…ë°ì´íŠ¸ (ì¬ì‹œë„ ë¡œì§ í¬í•¨)"""
        for attempt in range(3):
            try:
                async with asyncio.wait_for(self.postgres.acquire(), timeout=10) as conn:
                    await conn.execute("""
                        UPDATE positions SET
                            current_price = $1, unrealized_pnl = $2, pnl_percentage = $3,
                            liquidation_risk = $4, status = $5, exit_price = $6,
                            exit_time = $7, exit_reason = $8, realized_pnl = $9, updated_at = $10
                        WHERE position_id = $11
                    """, position.current_price, position.unrealized_pnl, position.pnl_percentage,
                    position.liquidation_risk, position.status, position.exit_price,
                    position.exit_time, position.exit_reason, position.realized_pnl,
                    position.updated_at, position.position_id)
                return
            except Exception as e:
                logging.error(f"í¬ì§€ì…˜ DB ì—…ë°ì´íŠ¸ ì‹¤íŒ¨ (ì‹œë„ {attempt + 1}): {e}")
                if attempt < 2:
                    await asyncio.sleep(2 ** attempt)
    
    async def _save_trade_history(self, position: Position):
        """ê±°ë˜ ì´ë ¥ ì €ì¥ (ì•ˆì „í•œ ì €ì¥)"""
        try:
            duration_minutes = 0
            if position.exit_time and position.created_at:
                duration_minutes = int((position.exit_time - position.created_at).total_seconds() / 60)
            
            async with asyncio.wait_for(self.postgres.acquire(), timeout=10) as conn:
                await conn.execute("""
                    INSERT INTO trade_history (
                        position_id, symbol, side, entry_price, exit_price, quantity,
                        leverage, pnl, pnl_percentage, duration_minutes, entry_time,
                        exit_time, exit_reason
                    ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13)
                """, position.position_id, position.symbol, position.side, position.entry_price,
                position.exit_price, position.quantity, position.leverage, position.realized_pnl,
                position.pnl_percentage, duration_minutes, position.created_at,
                position.exit_time, position.exit_reason)
        except Exception as e:
            logging.error(f"ê±°ë˜ ì´ë ¥ ì €ì¥ ì‹¤íŒ¨: {e}")
    
    async def _get_daily_pnl(self) -> float:
        """ì¼ì¼ P&L ì¡°íšŒ (ì•ˆì „í•œ ì¡°íšŒ)"""
        try:
            async with asyncio.wait_for(self.postgres.acquire(), timeout=5) as conn:
                result = await conn.fetchval("""
                    SELECT COALESCE(SUM(pnl), 0) FROM trade_history
                    WHERE DATE(entry_time) = CURRENT_DATE
                """)
                return float(result) if result is not None else 0.0
        except Exception as e:
            logging.error(f"ì¼ì¼ P&L ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return 0.0
    
    async def _check_volatility_risk(self, symbol: str) -> float:
        """ë³€ë™ì„± ìœ„í—˜ë„ ì²´í¬ (0-1)"""
        # ê°„ë‹¨í•œ ì‹œë®¬ë ˆì´ì…˜ (ì‹¤ì œë¡œëŠ” 24h ë³€ë™ì„± ê³„ì‚°)
        volatility_map = {
            "BTCUSDT": 0.3, "ETHUSDT": 0.4, "ADAUSDT": 0.6,
            "SOLUSDT": 0.7, "AVAXUSDT": 0.6
        }
        return volatility_map.get(symbol, 0.5)
    
    def get_portfolio_summary(self) -> Dict[str, Union[int, float, List[str]]]:
        """í¬íŠ¸í´ë¦¬ì˜¤ ìš”ì•½ (íƒ€ì… ì•ˆì •ì„± ê°•í™”)"""
        if not self.active_positions:
            return {
                "active_positions": 0,
                "total_unrealized_pnl": 0.0,
                "total_margin_used": 0.0,
                "avg_leverage": 0.0,
                "avg_liquidation_risk": 0.0,
                "symbols": []
            }
        
        positions = list(self.active_positions.values())
        
        try:
            return {
                "active_positions": len(positions),
                "total_unrealized_pnl": sum(p.unrealized_pnl for p in positions),
                "total_margin_used": sum(p.margin_required for p in positions),
                "avg_leverage": float(np.mean([p.leverage for p in positions])),
                "avg_liquidation_risk": float(np.mean([p.liquidation_risk for p in positions])),
                "symbols": [p.symbol for p in positions]
            }
        except Exception as e:
            logging.error(f"í¬íŠ¸í´ë¦¬ì˜¤ ìš”ì•½ ê³„ì‚° ì˜¤ë¥˜: {e}")
            return {
                "active_positions": len(positions),
                "total_unrealized_pnl": 0.0,
                "total_margin_used": 0.0,
                "avg_leverage": 0.0,
                "avg_liquidation_risk": 0.0,
                "symbols": []
            }

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“± í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì‹œìŠ¤í…œ (ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ… ê°•í™”)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class UltimateTelegramNotifier:
    """Ultimate í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì‹œìŠ¤í…œ - V3 ë©”ì‹œì§€ + V4 ê³ ë„í™” (ì•ˆì „ì„± ê°•í™”)"""
    
    def __init__(self):
        self.config = SystemConfig.TELEGRAM
        self.bot_token = self.config["bot_token"]
        self.chat_id = self.config["chat_id"]
        
        # í…”ë ˆê·¸ë¨ ì„¤ì • ê²€ì¦ (None ì²´í¬ ê°•í™”)
        if not self.bot_token:
            raise ValueError("TELEGRAM_BOT_TOKENì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
        if not self.chat_id:
            raise ValueError("TELEGRAM_CHAT_IDê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
            
        self.rate_limiter = asyncio.Semaphore(5)  # ì´ˆë‹¹ 5ê°œ ë©”ì‹œì§€ ì œí•œ
        self.last_alert_times: Dict[str, datetime] = {}  # ì•Œë¦¼ ì¿¨ë‹¤ìš´ ê´€ë¦¬
        
        logging.info(f"í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ (Chat ID: {self.chat_id})")
        
    async def send_message(self, message: str, level: str = "INFO") -> bool:
        """í…”ë ˆê·¸ë¨ ë©”ì‹œì§€ ì „ì†¡ (ì¿¨ë‹¤ìš´ ë° ì¬ì‹œë„ ë¡œì§)"""
        if not self.config["alerts"].get(level.lower(), True):
            return False
        
        # ì•Œë¦¼ ì¿¨ë‹¤ìš´ ì²´í¬ (ì¤‘ë³µ ë°©ì§€)
        alert_key = f"{level}_{hash(message) % 10000}"
        now = datetime.utcnow()
        
        if alert_key in self.last_alert_times:
            time_diff = (now - self.last_alert_times[alert_key]).total_seconds()
            cooldown = SystemConfig.MONITORING["alert_cooldown"]
            if time_diff < cooldown:
                logging.debug(f"ì•Œë¦¼ ì¿¨ë‹¤ìš´ ì¤‘: {alert_key}")
                return False
        
        async with self.rate_limiter:
            success = await self._send_message_internal(message, level)
            if success:
                self.last_alert_times[alert_key] = now
            return success
    
    async def _send_message_internal(self, message: str, level: str) -> bool:
        """ë‚´ë¶€ ë©”ì‹œì§€ ì „ì†¡ ë¡œì§ (ì¬ì‹œë„ í¬í•¨)"""
        max_retries = 3
        
        for attempt in range(max_retries):
            try:
                url = f"https://api.telegram.org/bot{self.bot_token}/sendMessage"
                
                # ë ˆë²¨ë³„ ì´ëª¨ì§€ ì¶”ê°€
                level_emojis = {
                    "INFO": "â„¹ï¸", "WARNING": "âš ï¸", "ERROR": "âŒ", 
                    "CRITICAL": "ğŸš¨", "SUCCESS": "âœ…"
                }
                emoji = level_emojis.get(level, "ğŸ“¢")
                
                # ë©”ì‹œì§€ ê¸¸ì´ ì œí•œ (í…”ë ˆê·¸ë¨ 4096ì ì œí•œ)
                max_length = 4000
                if len(message) > max_length:
                    message = message[:max_length] + "..."
                
                formatted_message = f"{emoji} <b>[{level}]</b>\n{message}"
                
                data = {
                    "chat_id": self.chat_id,
                    "text": formatted_message,
                    "parse_mode": "HTML",
                    "disable_web_page_preview": True
                }
                
                async with aiohttp.ClientSession() as session:
                    async with session.post(url, data=data, timeout=10) as response:
                        if response.status == 200:
                            return True
                        elif response.status == 429:  # Rate limit
                            retry_after = int(response.headers.get("Retry-After", 1))
                            logging.warning(f"í…”ë ˆê·¸ë¨ ë ˆì´íŠ¸ ë¦¬ë¯¸íŠ¸, {retry_after}ì´ˆ ëŒ€ê¸°")
                            await asyncio.sleep(retry_after)
                        else:
                            response_text = await response.text()
                            logging.warning(f"í…”ë ˆê·¸ë¨ ì‘ë‹µ ì˜¤ë¥˜: {response.status} - {response_text}")
                            
            except asyncio.TimeoutError:
                logging.warning(f"í…”ë ˆê·¸ë¨ ì „ì†¡ íƒ€ì„ì•„ì›ƒ (ì‹œë„ {attempt + 1})")
            except Exception as e:
                logging.error(f"í…”ë ˆê·¸ë¨ ì „ì†¡ ì‹¤íŒ¨ (ì‹œë„ {attempt + 1}): {e}")
            
            if attempt < max_retries - 1:
                await asyncio.sleep(2 ** attempt)  # ì§€ìˆ˜ì  ë°±ì˜¤í”„
        
        return False
    
    async def send_trade_notification(self, position: Position, phoenix95_score: float, kelly_ratio: float):
        """ê±°ë˜ ì‹¤í–‰ ì•Œë¦¼ - V3 ìŠ¤íƒ€ì¼ ë©”ì‹œì§€ (ì•ˆì „í•œ ê³„ì‚°)"""
        try:
            pnl_range_low = position.margin_required * (SystemConfig.TRADING["stop_loss_pct"] * position.leverage)
            pnl_range_high = position.margin_required * (SystemConfig.TRADING["take_profit_pct"] * position.leverage)
            
            message = f"""ğŸ¯ <b>Phoenix 95 Ultimate ê±°ë˜ ì‹¤í–‰</b>

ğŸ“Š <b>{position.symbol}</b> {position.side} {position.leverage}x ({position.margin_mode})
ğŸ’° ì§„ì…ê°€: <b>${position.entry_price:,.2f}</b>
ğŸ“ˆ ìµì ˆê°€: <b>${position.take_profit_price:,.2f}</b> (+{SystemConfig.TRADING['take_profit_pct']*100:.1f}%)
ğŸ“‰ ì†ì ˆê°€: <b>${position.stop_loss_price:,.2f}</b> (-{SystemConfig.TRADING['stop_loss_pct']*100:.1f}%)
ğŸš¨ ì²­ì‚°ê°€: <b>${position.liquidation_price:,.2f}</b>

ğŸ§  Phoenix95: <b>{phoenix95_score:.1%}</b>
âš–ï¸ Kelly ë¹„ìœ¨: <b>{kelly_ratio:.1%}</b>
ğŸ’µ ìˆ˜ëŸ‰: <b>{position.quantity:.6f}</b>
ğŸ’¸ ë§ˆì§„: <b>${position.margin_required:,.2f}</b>

ğŸ“Š ì˜ˆìƒ P&L: <b>-${pnl_range_low:.0f}</b> ~ <b>+${pnl_range_high:.0f}</b>
ğŸ†” í¬ì§€ì…˜: <code>{position.position_id}</code>

ğŸ• {datetime.utcnow().strftime('%H:%M:%S UTC')}"""
            
            await self.send_message(message, "SUCCESS")
        except Exception as e:
            logging.error(f"ê±°ë˜ ì•Œë¦¼ ìƒì„± ì‹¤íŒ¨: {e}")
    
    async def send_close_notification(self, position: Position, exit_reason: str):
        """í¬ì§€ì…˜ ì²­ì‚° ì•Œë¦¼ (ì•ˆì „í•œ ë©”ì‹œì§€ ìƒì„±)"""
        try:
            pnl_emoji = "ğŸ“ˆ" if position.realized_pnl and position.realized_pnl > 0 else "ğŸ“‰"
            reason_emoji = {
                "TAKE_PROFIT": "ğŸ¯", "STOP_LOSS": "ğŸ›¡ï¸", 
                "EMERGENCY_LIQUIDATION": "ğŸš¨", "MANUAL": "ğŸ‘¤"
            }
            
            duration = ""
            if position.exit_time and position.created_at:
                duration_mins = int((position.exit_time - position.created_at).total_seconds() / 60)
                duration = f"â±ï¸ ê±°ë˜ì‹œê°„: <b>{duration_mins}ë¶„</b>\n"
            
            realized_pnl = position.realized_pnl or 0.0
            pnl_percentage = position.pnl_percentage or 0.0
            
            message = f"""{pnl_emoji} <b>í¬ì§€ì…˜ ì²­ì‚°</b> {reason_emoji.get(exit_reason, "ğŸ“")}

ğŸ“Š <b>{position.symbol}</b> {position.side} {position.leverage}x
ğŸ’° ì§„ì…ê°€: <b>${position.entry_price:,.2f}</b>
ğŸ’¸ ì²­ì‚°ê°€: <b>${position.exit_price:,.2f}</b>
{duration}
ğŸ’µ P&L: <b>${realized_pnl:,.2f}</b> ({pnl_percentage:+.1f}%)
ğŸ“‹ ì‚¬ìœ : <b>{exit_reason.replace('_', ' ')}</b>

ğŸ†” í¬ì§€ì…˜: <code>{position.position_id}</code>
ğŸ• {datetime.utcnow().strftime('%H:%M:%S UTC')}"""
            
            level = "SUCCESS" if realized_pnl > 0 else "WARNING"
            await self.send_message(message, level)
        except Exception as e:
            logging.error(f"ì²­ì‚° ì•Œë¦¼ ìƒì„± ì‹¤íŒ¨: {e}")
    
    async def send_liquidation_warning(self, position: Position):
        """ì²­ì‚° ìœ„í—˜ ê²½ê³  (ì¿¨ë‹¤ìš´ ì ìš©)"""
        try:
            message = f"""ğŸ†˜ <b>ì²­ì‚° ìœ„í—˜ ê²½ê³ </b>

ğŸ“Š <b>{position.symbol}</b> {position.side} {position.leverage}x
ğŸ’° ì§„ì…ê°€: <b>${position.entry_price:,.2f}</b>
ğŸ’¸ í˜„ì¬ê°€: <b>${position.current_price:,.2f}</b>
ğŸš¨ ì²­ì‚°ê°€: <b>${position.liquidation_price:,.2f}</b>

âš ï¸ ìœ„í—˜ë„: <b>{position.liquidation_risk:.1%}</b>
ğŸ’” ë¯¸ì‹¤í˜„ P&L: <b>${position.unrealized_pnl:,.2f}</b> ({position.pnl_percentage:+.1f}%)

ğŸ†” í¬ì§€ì…˜: <code>{position.position_id}</code>
ğŸ• {datetime.utcnow().strftime('%H:%M:%S UTC')}

âš¡ ì¦‰ì‹œ í™•ì¸ì´ í•„ìš”í•©ë‹ˆë‹¤!"""
            
            await self.send_message(message, "CRITICAL")
        except Exception as e:
            logging.error(f"ì²­ì‚° ê²½ê³  ìƒì„± ì‹¤íŒ¨: {e}")
    
    async def send_system_notification(self, message: str, level: str = "INFO"):
        """ì‹œìŠ¤í…œ ì•Œë¦¼"""
        try:
            system_message = f"""ğŸ–¥ï¸ <b>Phoenix 95 Ultimate System</b>

{message}

ğŸ• {datetime.utcnow().strftime('%H:%M:%S UTC')}"""
            
            await self.send_message(system_message, level)
        except Exception as e:
            logging.error(f"ì‹œìŠ¤í…œ ì•Œë¦¼ ìƒì„± ì‹¤íŒ¨: {e}")
    
    async def send_daily_summary(self, stats: Dict[str, Any]):
        """ì¼ì¼ ì„±ê³¼ ìš”ì•½ (ì•ˆì „í•œ í†µê³„ ê³„ì‚°)"""
        try:
            total_trades = stats.get('total_trades', 0)
            winning_trades = stats.get('winning_trades', 0)
            win_rate = (winning_trades / max(total_trades, 1)) * 100
            
            message = f"""ğŸ“Š <b>Phoenix 95 Ultimate ì¼ì¼ ì„±ê³¼</b>

ğŸ’° ì´ P&L: <b>${stats.get('total_pnl', 0):.2f}</b>
ğŸ“ˆ ì´ ê±°ë˜: <b>{total_trades}íšŒ</b>
ğŸ¯ ìŠ¹ë¥ : <b>{win_rate:.1f}%</b>
ğŸ† ìµœê³  ê±°ë˜: <b>${stats.get('best_trade', 0):.2f}</b>
ğŸ’” ìµœì•… ê±°ë˜: <b>${stats.get('worst_trade', 0):.2f}</b>
â±ï¸ í‰ê·  ê±°ë˜ì‹œê°„: <b>{stats.get('avg_duration', 0)}ë¶„</b>

ğŸ“Š í™œì„± í¬ì§€ì…˜: <b>{stats.get('active_positions', 0)}ê°œ</b>
ğŸ’¸ ì´ ë§ˆì§„: <b>${stats.get('total_margin', 0):.2f}</b>

ğŸ• {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}"""
            
            await self.send_message(message, "INFO")
        except Exception as e:
            logging.error(f"ì¼ì¼ ìš”ì•½ ìƒì„± ì‹¤íŒ¨: {e}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ”’ ë³´ì•ˆ & ì¸ì¦ (ê°•í™”ëœ ê²€ì¦)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SecurityManager:
    """ë³´ì•ˆ ê´€ë¦¬ì (ê²€ì¦ ê°•í™”)"""
    
    def __init__(self):
        self.config = SystemConfig.SECURITY
        
        # ì„¤ì • ê²€ì¦
        if not self.config["webhook_secret"]:
            raise ValueError("WEBHOOK_SECRETì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
        if not self.config["api_key"]:
            raise ValueError("API_KEYê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
        if not self.config["jwt_secret"]:
            raise ValueError("JWT_SECRETì´ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤")
        
    def verify_webhook_signature(self, payload: str, signature: str) -> bool:
        """ì›¹í›… ì„œëª… ê²€ì¦ (ì•ˆì „í•œ ê²€ì¦)"""
        try:
            expected_signature = hmac.new(
                self.config["webhook_secret"].encode(),
                payload.encode(),
                hashlib.sha256
            ).hexdigest()
            
            return hmac.compare_digest(signature, expected_signature)
        except Exception as e:
            logging.error(f"ì„œëª… ê²€ì¦ ì‹¤íŒ¨: {e}")
            return False
    
    def verify_api_key(self, api_key: str) -> bool:
        """API í‚¤ ê²€ì¦ (None ì²´í¬ í¬í•¨)"""
        if not api_key or not self.config["api_key"]:
            return False
        return hmac.compare_digest(api_key, self.config["api_key"])
    
    def is_ip_allowed(self, ip: str) -> bool:
        """IP í—ˆìš© ëª©ë¡ í™•ì¸"""
        if not ip:
            return False
        allowed_ips = self.config["allowed_ips"]
        return ip in allowed_ips or "0.0.0.0" in allowed_ips

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“Š ëª¨ë‹ˆí„°ë§ & ë©”íŠ¸ë¦­ (í†µí•© ë©”íŠ¸ë¦­ ìˆ˜ì§‘)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class SystemMonitor:
    """ì‹œìŠ¤í…œ ëª¨ë‹ˆí„°ë§ (ì¤‘ë³µ ì œê±°, ë©”íŠ¸ë¦­ í†µí•©)"""
    
    def __init__(self, redis_client, postgres_pool, telegram_notifier):
        self.redis = redis_client
        self.postgres = postgres_pool
        self.telegram = telegram_notifier
        # ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ì œí•œ
        max_history = SystemConfig.MONITORING["max_metrics_history"]
        self.metrics_history = deque(maxlen=max_history)
        
        # í†µí•© ë©”íŠ¸ë¦­ ìºì‹œ (ì¤‘ë³µ ì œê±°)
        self._metrics_cache: Dict[str, Any] = {}
        self._cache_timestamp = datetime.utcnow()
        self._cache_ttl = 30  # 30ì´ˆ ìºì‹œ
        
    async def collect_system_metrics(self) -> Optional[PerformanceMetrics]:
        """ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘ (í†µí•© ìˆ˜ì§‘, ì¤‘ë³µ ì œê±°)"""
        try:
            # ìºì‹œ í™•ì¸
            now = datetime.utcnow()
            if (now - self._cache_timestamp).total_seconds() < self._cache_ttl:
                if 'system_metrics' in self._metrics_cache:
                    return self._metrics_cache['system_metrics']
            
            # ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤
            cpu_usage, memory_usage = await self._get_system_resources()
            
            # ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìˆ˜
            active_connections = await self._get_db_connections()
            
            # íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­ (í†µí•©)
            trading_metrics = await self._get_unified_trading_metrics()
            
            metrics = PerformanceMetrics(
                timestamp=now,
                cpu_usage=cpu_usage,
                memory_usage=memory_usage,
                response_time_ms=0.0,  # APIì—ì„œ ì¸¡ì •
                active_connections=active_connections,
                active_positions=trading_metrics.get('active_positions', 0),
                total_pnl=trading_metrics.get('total_pnl', 0.0),
                win_rate=trading_metrics.get('win_rate', 0.0),
                avg_trade_duration=trading_metrics.get('avg_duration', 0.0),
                phoenix95_avg_score=trading_metrics.get('avg_score', 0.0),
                max_drawdown=trading_metrics.get('max_drawdown', 0.0),
                var_95=trading_metrics.get('var_95', 0.0),
                sharpe_ratio=trading_metrics.get('sharpe_ratio', 0.0)
            )
            
            # ìºì‹œ ì—…ë°ì´íŠ¸
            self._metrics_cache['system_metrics'] = metrics
            self._cache_timestamp = now
            
            self.metrics_history.append(metrics)
            return metrics
            
        except Exception as e:
            logging.error(f"ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤íŒ¨: {e}")
            return None
    
    async def _get_system_resources(self) -> Tuple[float, float]:
        """ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì¡°íšŒ (ì•ˆì „í•œ ì¡°íšŒ)"""
        try:
            import psutil
            cpu_usage = psutil.cpu_percent(interval=1)
            memory = psutil.virtual_memory()
            memory_usage = memory.percent
            return cpu_usage, memory_usage
        except ImportError:
            logging.warning("psutil ëª¨ë“ˆì´ ì—†ì–´ ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ë¥¼ ì¡°íšŒí•  ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
            return 0.0, 0.0
        except Exception as e:
            logging.error(f"ì‹œìŠ¤í…œ ë¦¬ì†ŒìŠ¤ ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return 0.0, 0.0
    
    async def _get_db_connections(self) -> int:
        """ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ìˆ˜ ì¡°íšŒ"""
        try:
            async with asyncio.wait_for(self.postgres.acquire(), timeout=5) as conn:
                result = await conn.fetchval(
                    "SELECT count(*) FROM pg_stat_activity WHERE state = 'active'"
                )
                return int(result) if result else 0
        except Exception as e:
            logging.error(f"DB ì—°ê²° ìˆ˜ ì¡°íšŒ ì‹¤íŒ¨: {e}")
            return 0
    
    async def _get_unified_trading_metrics(self) -> Dict[str, Union[int, float]]:
        """í†µí•© íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­ ìˆ˜ì§‘ (ì¤‘ë³µ ì œê±°)"""
        try:
            # ìºì‹œ í™•ì¸
            if 'trading_metrics' in self._metrics_cache:
                cache_age = (datetime.utcnow() - self._cache_timestamp).total_seconds()
                if cache_age < self._cache_ttl:
                    return self._metrics_cache['trading_metrics']
            
            async with asyncio.wait_for(self.postgres.acquire(), timeout=10) as conn:
                # í•˜ë‚˜ì˜ ì¿¼ë¦¬ë¡œ í†µí•© ì¡°íšŒ (ì¤‘ë³µ ì œê±°)
                today_stats = await conn.fetchrow("""
                    SELECT 
                        COUNT(*) as total_trades,
                        COUNT(*) FILTER (WHERE pnl > 0) as winning_trades,
                        COALESCE(SUM(pnl), 0) as total_pnl,
                        COALESCE(AVG(duration_minutes), 0) as avg_duration,
                        COALESCE(MAX(pnl), 0) as best_trade,
                        COALESCE(MIN(pnl), 0) as worst_trade
                    FROM trade_history 
                    WHERE DATE(entry_time) = CURRENT_DATE
                """)
                
                # í™œì„± í¬ì§€ì…˜ ìˆ˜
                active_positions = await conn.fetchval(
                    "SELECT COUNT(*) FROM positions WHERE status = 'OPEN'"
                ) or 0
                
                win_rate = 0.0
                if today_stats and today_stats['total_trades'] > 0:
                    win_rate = (today_stats['winning_trades'] / today_stats['total_trades']) * 100
                
                metrics = {
                    'active_positions': int(active_positions),
                    'total_pnl': float(today_stats['total_pnl']) if today_stats else 0.0,
                    'win_rate': win_rate,
                    'avg_duration': float(today_stats['avg_duration']) if today_stats else 0.0,
                    'avg_score': 0.85,  # Phoenix 95 í‰ê·  ì ìˆ˜
                    'max_drawdown': 0.0,
                    'var_95': 0.0,
                    'sharpe_ratio': 0.0,
                    'best_trade': float(today_stats['best_trade']) if today_stats else 0.0,
                    'worst_trade': float(today_stats['worst_trade']) if today_stats else 0.0,
                    'total_trades': int(today_stats['total_trades']) if today_stats else 0,
                    'winning_trades': int(today_stats['winning_trades']) if today_stats else 0
                }
                
                # ìºì‹œ ì €ì¥
                self._metrics_cache['trading_metrics'] = metrics
                return metrics
                
        except Exception as e:
            logging.error(f"íŠ¸ë ˆì´ë”© ë©”íŠ¸ë¦­ ìˆ˜ì§‘ ì‹¤íŒ¨: {e}")
            return {}
    
    async def check_alerts(self, metrics: PerformanceMetrics):
        """ì•Œë¦¼ ì²´í¬ (ì¤‘ë³µ ì•Œë¦¼ ë°©ì§€)"""
        try:
            alerts = []
            thresholds = SystemConfig.MONITORING["performance_threshold"]
            
            # CPU ì‚¬ìš©ë¥  ì²´í¬
            if metrics.cpu_usage > thresholds["cpu_usage_pct"]:
                alerts.append(f"ë†’ì€ CPU ì‚¬ìš©ë¥ : {metrics.cpu_usage:.1f}%")
            
            # ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥  ì²´í¬
            if metrics.memory_usage > thresholds["memory_usage_pct"]:
                alerts.append(f"ë†’ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©ë¥ : {metrics.memory_usage:.1f}%")
            
            # ì‘ë‹µ ì‹œê°„ ì²´í¬
            if metrics.response_time_ms > thresholds["response_time_ms"]:
                alerts.append(f"ëŠë¦° ì‘ë‹µ ì‹œê°„: {metrics.response_time_ms:.0f}ms")
            
            # ì•Œë¦¼ ì „ì†¡ (ì¿¨ë‹¤ìš´ ì ìš©)
            for alert in alerts:
                await self.telegram.send_system_notification(alert, "WARNING")
        except Exception as e:
            logging.error(f"ì•Œë¦¼ ì²´í¬ ì‹¤íŒ¨: {e}")

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸš€ ë©”ì¸ ì• í”Œë¦¬ì¼€ì´ì…˜ (ì˜¤ë¥˜ ì²˜ë¦¬ ê°•í™”)
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

class Phoenix95UltimateSystem:
    """Phoenix 95 Ultimate í†µí•© ì‹œìŠ¤í…œ (ì˜¤ë¥˜ ì²˜ë¦¬ ë° ì•ˆì •ì„± ê°•í™”)"""
    
    def __init__(self):
        self.phoenix95_engine = Phoenix95AIEngine()
        self.telegram = UltimateTelegramNotifier()
        self.security = SecurityManager()
        self.redis_client = None
        self.postgres_pool = None
        self.trader = None
        self.monitor = None
        
        # FastAPI ì•±
        self.app = FastAPI(
            title="Phoenix 95 Ultimate Trading System",
            description="V3 ê²€ì¦ëœ ì•Œê³ ë¦¬ì¦˜ + V4 ê³ ê¸‰ ê¸°ëŠ¥ + í—¤ì§€í€ë“œê¸‰ ì•ˆì „ì„± (ì˜¤ë¥˜ ìˆ˜ì • ë²„ì „)",
            version="Ultimate-1.0.1"
        )
        
        self._setup_middleware()
        self._setup_routes()
        
    def _setup_middleware(self):
        """ë¯¸ë“¤ì›¨ì–´ ì„¤ì •"""
        self.app.add_middleware(
            CORSMiddleware,
            allow_origins=["*"],
            allow_credentials=True,
            allow_methods=["*"],
            allow_headers=["*"],
        )
    
    def _setup_routes(self):
        """API ë¼ìš°íŠ¸ ì„¤ì • (ì˜¤ë¥˜ ì²˜ë¦¬ ê°•í™”)"""
        
        @self.app.on_event("startup")
        async def startup_event():
            await self.initialize()
        
        @self.app.on_event("shutdown")
        async def shutdown_event():
            await self.cleanup()
        
        @self.app.post("/webhook/tradingview")
        async def receive_tradingview_signal(signal_data: dict, background_tasks: BackgroundTasks):
            """TradingView ì‹ í˜¸ ìˆ˜ì‹  (ê²€ì¦ ê°•í™”)"""
            try:
                # í•„ìˆ˜ í•„ë“œ ê²€ì¦
                required_fields = ["symbol", "action", "price", "confidence"]
                for field in required_fields:
                    if field not in signal_data:
                        raise HTTPException(status_code=400, detail=f"í•„ìˆ˜ í•„ë“œ ëˆ„ë½: {field}")
                
                # ë°ì´í„° íƒ€ì… ê²€ì¦
                try:
                    price = float(signal_data["price"])
                    confidence = float(signal_data["confidence"])
                except (ValueError, TypeError):
                    raise HTTPException(status_code=400, detail="priceì™€ confidenceëŠ” ìˆ«ìì—¬ì•¼ í•©ë‹ˆë‹¤")
                
                # ì‹ í˜¸ íŒŒì‹± ë° ê²€ì¦
                signal = TradingSignal(
                    signal_id=f"SIG_{uuid.uuid4().hex[:8].upper()}",
                    symbol=signal_data["symbol"].upper(),
                    action=signal_data["action"].lower(),
                    price=price,
                    confidence=confidence,
                    timestamp=datetime.utcnow()
                )
                
                if not signal.is_valid():
                    raise HTTPException(status_code=400, detail="ì˜ëª»ëœ ì‹ í˜¸ ë°ì´í„°")
                
                # ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì²˜ë¦¬
                background_tasks.add_task(self._process_signal_complete, signal)
                
                return {
                    "status": "received",
                    "signal_id": signal.signal_id,
                    "timestamp": signal.timestamp.isoformat()
                }
                
            except HTTPException:
                raise
            except Exception as e:
                logging.error(f"ì‹ í˜¸ ìˆ˜ì‹  ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/health")
        async def health_check():
            """ì‹œìŠ¤í…œ í—¬ìŠ¤ì²´í¬ (í¬ê´„ì  ê²€ì‚¬)"""
            try:
                health_status = {
                    "status": "healthy",
                    "timestamp": datetime.utcnow().isoformat(),
                    "version": "Ultimate-1.0.1",
                    "system": "Phoenix 95 Ultimate Trading System",
                    "components": {},
                    "portfolio": {},
                    "config": {}
                }
                
                # ë°ì´í„°ë² ì´ìŠ¤ ì—°ê²° ì²´í¬
                db_healthy = False
                try:
                    async with asyncio.wait_for(self.postgres_pool.acquire(), timeout=5) as conn:
                        await conn.fetchval("SELECT 1")
                    db_healthy = True
                except Exception as e:
                    logging.warning(f"DB í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨: {e}")
                
                # Redis ì—°ê²° ì²´í¬
                redis_healthy = False
                try:
                    await asyncio.wait_for(self.redis_client.ping(), timeout=5)
                    redis_healthy = True
                except Exception as e:
                    logging.warning(f"Redis í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨: {e}")
                
                # í¬íŠ¸í´ë¦¬ì˜¤ ìš”ì•½
                try:
                    portfolio = self.trader.get_portfolio_summary() if self.trader else {}
                    health_status["portfolio"] = portfolio
                except Exception as e:
                    logging.warning(f"í¬íŠ¸í´ë¦¬ì˜¤ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                
                # ì»´í¬ë„ŒíŠ¸ ìƒíƒœ
                health_status["components"] = {
                    "database": "healthy" if db_healthy else "error",
                    "redis": "healthy" if redis_healthy else "error",
                    "ai_engine": "healthy",
                    "trading_engine": "healthy" if self.trader else "error",
                    "telegram": "healthy"
                }
                
                # ì„¤ì • ì •ë³´
                health_status["config"] = {
                    "max_leverage": SystemConfig.TRADING["max_leverage"],
                    "max_positions": SystemConfig.TRADING["max_positions"],
                    "confidence_threshold": SystemConfig.TRADING["confidence_threshold"]
                }
                
                # ì „ì²´ ìƒíƒœ ê²°ì •
                if not db_healthy or not redis_healthy:
                    health_status["status"] = "degraded"
                
                return health_status
                
            except Exception as e:
                logging.error(f"í—¬ìŠ¤ì²´í¬ ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/positions")
        async def get_active_positions():
            """í™œì„± í¬ì§€ì…˜ ì¡°íšŒ (ì•ˆì „í•œ ì¡°íšŒ)"""
            try:
                if not self.trader:
                    return {"positions": [], "count": 0, "summary": {}}
                
                positions = []
                for position in self.trader.active_positions.values():
                    try:
                        positions.append({
                            "position_id": position.position_id,
                            "symbol": position.symbol,
                            "side": position.side,
                            "entry_price": position.entry_price,
                            "current_price": position.current_price,
                            "quantity": position.quantity,
                            "leverage": position.leverage,
                            "margin_required": position.margin_required,
                            "unrealized_pnl": position.unrealized_pnl,
                            "pnl_percentage": position.pnl_percentage,
                            "liquidation_risk": position.liquidation_risk,
                            "liquidation_price": position.liquidation_price,
                            "stop_loss_price": position.stop_loss_price,
                            "take_profit_price": position.take_profit_price,
                            "status": position.status,
                            "created_at": position.created_at.isoformat()
                        })
                    except Exception as e:
                        logging.warning(f"í¬ì§€ì…˜ {position.position_id} ì§ë ¬í™” ì‹¤íŒ¨: {e}")
                
                portfolio_summary = self.trader.get_portfolio_summary()
                
                return {
                    "positions": positions,
                    "count": len(positions),
                    "summary": portfolio_summary
                }
                
            except Exception as e:
                logging.error(f"í¬ì§€ì…˜ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.get("/performance")
        async def get_performance_stats():
            """ì„±ëŠ¥ í†µê³„ ì¡°íšŒ (í†µí•© í†µê³„)"""
            try:
                # AI ì—”ì§„ ì„±ëŠ¥
                ai_stats = self.phoenix95_engine.get_performance_stats()
                
                # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­
                latest_metrics = None
                if self.monitor and self.monitor.metrics_history:
                    latest_metrics = self.monitor.metrics_history[-1]
                
                # ê±°ë˜ í†µê³„ (í†µí•© ë©”íŠ¸ë¦­ ì‚¬ìš©)
                trading_stats = {}
                if self.monitor:
                    trading_stats = await self.monitor._get_unified_trading_metrics()
                
                return {
                    "ai_engine": ai_stats,
                    "system_metrics": asdict(latest_metrics) if latest_metrics else {},
                    "trading_stats": trading_stats,
                    "timestamp": datetime.utcnow().isoformat()
                }
                
            except Exception as e:
                logging.error(f"ì„±ëŠ¥ í†µê³„ ì¡°íšŒ ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=str(e))
        
        @self.app.post("/admin/emergency_close")
        async def emergency_close_position(position_id: str):
            """ê¸´ê¸‰ í¬ì§€ì…˜ ì²­ì‚° (ì•ˆì „í•œ ì²­ì‚°)"""
            try:
                if not self.trader or position_id not in self.trader.active_positions:
                    raise HTTPException(status_code=404, detail="í¬ì§€ì…˜ì„ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤")
                
                position = self.trader.active_positions[position_id]
                current_price = await self.trader._get_current_price(position.symbol)
                
                await self.trader._close_position(position, current_price, "MANUAL")
                
                return {
                    "status": "success",
                    "message": f"í¬ì§€ì…˜ {position_id} ê¸´ê¸‰ ì²­ì‚° ì™„ë£Œ",
                    "timestamp": datetime.utcnow().isoformat()
                }
                
            except HTTPException:
                raise
            except Exception as e:
                logging.error(f"ê¸´ê¸‰ ì²­ì‚° ì‹¤íŒ¨: {e}")
                raise HTTPException(status_code=500, detail=str(e))
    
    async def initialize(self):
        """ì‹œìŠ¤í…œ ì´ˆê¸°í™” (ê°•í™”ëœ ì˜¤ë¥˜ ì²˜ë¦¬)"""
        try:
            logging.info("Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹œì‘...")
            
            # Redis ì—°ê²° (ì¬ì‹œë„ ë¡œì§)
            for attempt in range(3):
                try:
                    self.redis_client = await aioredis.from_url(
                        SystemConfig.DATABASE["redis_url"],
                        encoding="utf-8",
                        decode_responses=True,
                        socket_timeout=10,
                        socket_connect_timeout=10
                    )
                    await self.redis_client.ping()
                    logging.info("Redis ì—°ê²° ì„±ê³µ")
                    break
                except Exception as e:
                    logging.warning(f"Redis ì—°ê²° ì‹¤íŒ¨ (ì‹œë„ {attempt + 1}): {e}")
                    if attempt == 2:
                        raise
                    await asyncio.sleep(5)
            
            # PostgreSQL ì—°ê²° (ì¬ì‹œë„ ë¡œì§)
            for attempt in range(3):
                try:
                    self.postgres_pool = await asyncpg.create_pool(
                        SystemConfig.DATABASE["postgres_url"],
                        min_size=5,
                        max_size=SystemConfig.DATABASE["connection_pool_size"],
                        command_timeout=SystemConfig.DATABASE["query_timeout"]
                    )
                    # ì—°ê²° í…ŒìŠ¤íŠ¸
                    async with self.postgres_pool.acquire() as conn:
                        await conn.fetchval("SELECT 1")
                    logging.info("PostgreSQL ì—°ê²° ì„±ê³µ")
                    break
                except Exception as e:
                    logging.warning(f"PostgreSQL ì—°ê²° ì‹¤íŒ¨ (ì‹œë„ {attempt + 1}): {e}")
                    if attempt == 2:
                        raise
                    await asyncio.sleep(5)
            
            # íŠ¸ë ˆì´ë” ì´ˆê¸°í™”
            self.trader = UltimateLeverageTrader(
                self.redis_client, 
                self.postgres_pool, 
                self.telegram
            )
            logging.info("ë ˆë²„ë¦¬ì§€ íŠ¸ë ˆì´ë” ì´ˆê¸°í™” ì™„ë£Œ")
            
            # ëª¨ë‹ˆí„° ì´ˆê¸°í™”
            self.monitor = SystemMonitor(
                self.redis_client,
                self.postgres_pool,
                self.telegram
            )
            logging.info("ì‹œìŠ¤í…œ ëª¨ë‹ˆí„° ì´ˆê¸°í™” ì™„ë£Œ")
            
            # ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì‹œì‘
            asyncio.create_task(self._monitoring_loop())
            
            # ì‹œì‘ ì•Œë¦¼
            await self.telegram.send_system_notification(
                """ğŸ¯ <b>Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì‹œì‘</b> (ì˜¤ë¥˜ ìˆ˜ì • ë²„ì „)

âœ… V3 ê²€ì¦ëœ ì•Œê³ ë¦¬ì¦˜ í™œì„±í™”
âœ… V4 ê³ ê¸‰ ê¸°ëŠ¥ í™œì„±í™”  
âœ… í—¤ì§€í€ë“œê¸‰ ë¦¬ìŠ¤í¬ ê´€ë¦¬ í™œì„±í™”
âœ… ì‹¤ì‹œê°„ ëª¨ë‹ˆí„°ë§ í™œì„±í™”
âœ… 20x â†’ 10x ë³´ìˆ˜ì  ë ˆë²„ë¦¬ì§€
âœ… 85% ì‹ ë¢°ë„ ì„ê³„ê°’
âœ… ë³´ì•ˆ ê°•í™” ë° ì˜¤ë¥˜ ìˆ˜ì • ì™„ë£Œ

ğŸ’° ìµœëŒ€ í¬ì§€ì…˜: {SystemConfig.TRADING["max_positions"]}ê°œ
ğŸ›¡ï¸ ì¼ì¼ ì†ì‹¤ í•œë„: ${SystemConfig.TRADING["max_daily_loss"]}
âš¡ ë¶„ì„ ì†ë„: 2ì´ˆ ì´ë‚´ ë³´ì¥
ğŸ”’ í™˜ê²½ë³€ìˆ˜ ê²€ì¦ ê°•í™”
ğŸš« ë¬´í•œë£¨í”„ ë° ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€

ğŸš€ ì‹œìŠ¤í…œ ì¤€ë¹„ ì™„ë£Œ!""", 
                "SUCCESS"
            )
            
            logging.info("Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì™„ë£Œ!")
            
        except Exception as e:
            logging.error(f"ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}")
            try:
                await self.telegram.send_system_notification(f"ì‹œìŠ¤í…œ ì´ˆê¸°í™” ì‹¤íŒ¨: {e}", "ERROR")
            except:
                pass  # í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì‹¤íŒ¨ ì‹œì—ë„ ì‹œìŠ¤í…œì€ ì¢…ë£Œë˜ì–´ì•¼ í•¨
            raise
    
    async def cleanup(self):
        """ì‹œìŠ¤í…œ ì •ë¦¬ (ì•ˆì „í•œ ì •ë¦¬)"""
        try:
            logging.info("ì‹œìŠ¤í…œ ì •ë¦¬ ì‹œì‘...")
            
            # ëª¨ë“  ëª¨ë‹ˆí„°ë§ íƒœìŠ¤í¬ ì·¨ì†Œ
            if self.trader:
                for task in list(self.trader.monitoring_tasks.values()):
                    if not task.done():
                        task.cancel()
                        try:
                            await task
                        except asyncio.CancelledError:
                            pass
            
            # ì—°ê²° ì •ë¦¬
            if self.redis_client:
                try:
                    await self.redis_client.close()
                except Exception as e:
                    logging.warning(f"Redis ì •ë¦¬ ì‹¤íŒ¨: {e}")
            
            if self.postgres_pool:
                try:
                    await self.postgres_pool.close()
                except Exception as e:
                    logging.warning(f"PostgreSQL ì •ë¦¬ ì‹¤íŒ¨: {e}")
            
            try:
                await self.telegram.send_system_notification("ì‹œìŠ¤í…œ ì •ìƒ ì¢…ë£Œ", "INFO")
            except Exception as e:
                logging.warning(f"ì¢…ë£Œ ì•Œë¦¼ ì‹¤íŒ¨: {e}")
            
            logging.info("ì‹œìŠ¤í…œ ì •ë¦¬ ì™„ë£Œ")
            
        except Exception as e:
            logging.error(f"ì‹œìŠ¤í…œ ì •ë¦¬ ì‹¤íŒ¨: {e}")
    
    async def _process_signal_complete(self, signal: TradingSignal):
        """ì™„ì „í•œ ì‹ í˜¸ ì²˜ë¦¬ íŒŒì´í”„ë¼ì¸ (ì˜¤ë¥˜ ì²˜ë¦¬ ê°•í™”)"""
        try:
            logging.info(f"ì‹ í˜¸ ì²˜ë¦¬ ì‹œì‘: {signal.signal_id}")
            
            # 1. Phoenix 95 AI ë¶„ì„ (íƒ€ì„ì•„ì›ƒ ì ìš©)
            try:
                phoenix95_score, kelly_ratio, recommendation = await asyncio.wait_for(
                    self.phoenix95_engine.analyze_signal_complete(signal),
                    timeout=SystemConfig.PHOENIX95["analysis_timeout"]
                )
            except asyncio.TimeoutError:
                logging.warning(f"AI ë¶„ì„ íƒ€ì„ì•„ì›ƒ: {signal.signal_id}")
                phoenix95_score, kelly_ratio, recommendation = 0.0, 0.0, "REJECT"
            
            signal.phoenix95_score = phoenix95_score
            signal.kelly_ratio = kelly_ratio
            signal.recommendation = recommendation
            signal.processed = True
            
            logging.info(f"AI ë¶„ì„ ì™„ë£Œ: Phoenix95={phoenix95_score:.3f}, Kelly={kelly_ratio:.3f}, Rec={recommendation}")
            
            # 2. ì¶”ì²œì´ ê±°ë˜ ê°€ëŠ¥í•œ ê²½ìš°ì—ë§Œ ì‹¤í–‰
            if recommendation in ["STRONG_BUY", "BUY", "WEAK_BUY"]:
                # 3. ê±°ë˜ ì‹¤í–‰
                position = await self.trader.execute_trade_complete(signal, phoenix95_score, kelly_ratio)
                
                if position:
                    logging.info(f"ê±°ë˜ ì‹¤í–‰ ì„±ê³µ: {position.position_id}")
                else:
                    logging.warning(f"ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨: {signal.signal_id}")
                    await self.telegram.send_system_notification(
                        f"ê±°ë˜ ì‹¤í–‰ ì‹¤íŒ¨\nì‹ í˜¸: {signal.symbol} {signal.action}", 
                        "WARNING"
                    )
            else:
                logging.info(f"ê±°ë˜ ê±°ë¶€: {recommendation}")
                await self.telegram.send_system_notification(
                    f"""ğŸ“Š ì‹ í˜¸ ë¶„ì„ ì™„ë£Œ (ê±°ë˜ ê±°ë¶€)

ğŸ” {signal.symbol} {signal.action.upper()}
ğŸ’° ê°€ê²©: ${signal.price:,.2f}
ğŸ§  Phoenix95: {phoenix95_score:.1%}
âš–ï¸ Kelly: {kelly_ratio:.1%}
âŒ ì¶”ì²œ: {recommendation}

ğŸ’¡ ê±°ë˜ ì¡°ê±´ ë¯¸ì¶©ì¡±""", 
                    "INFO"
                )
            
        except Exception as e:
            logging.error(f"ì‹ í˜¸ ì²˜ë¦¬ ì‹¤íŒ¨ {signal.signal_id}: {e}")
            signal.processed = False
            signal.error_message = str(e)
            
            try:
                await self.telegram.send_system_notification(
                    f"ì‹ í˜¸ ì²˜ë¦¬ ì˜¤ë¥˜\n{signal.symbol}: {str(e)}", 
                    "ERROR"
                )
            except Exception as telegram_error:
                logging.error(f"í…”ë ˆê·¸ë¨ ì•Œë¦¼ ì‹¤íŒ¨: {telegram_error}")
    
    async def _monitoring_loop(self):
        """ëª¨ë‹ˆí„°ë§ ë£¨í”„ (ì¬ì‹œë„ ë° ì˜¤ë¥˜ ì²˜ë¦¬ ê°•í™”)"""
        consecutive_errors = 0
        max_consecutive_errors = 5
        
        while consecutive_errors < max_consecutive_errors:
            try:
                # ì‹œìŠ¤í…œ ë©”íŠ¸ë¦­ ìˆ˜ì§‘
                metrics = await self.monitor.collect_system_metrics()
                
                if metrics:
                    # ì•Œë¦¼ ì²´í¬
                    await self.monitor.check_alerts(metrics)
                    
                    # Redisì— ìµœì‹  ë©”íŠ¸ë¦­ ì €ì¥
                    try:
                        await self.redis_client.hset("system:metrics", mapping={
                            "cpu_usage": str(metrics.cpu_usage),
                            "memory_usage": str(metrics.memory_usage),
                            "active_positions": str(metrics.active_positions),
                            "total_pnl": str(metrics.total_pnl),
                            "timestamp": metrics.timestamp.isoformat()
                        })
                    except Exception as redis_error:
                        logging.warning(f"Redis ë©”íŠ¸ë¦­ ì €ì¥ ì‹¤íŒ¨: {redis_error}")
                
                # ì„±ê³µì ì¸ ë°˜ë³µ í›„ ì˜¤ë¥˜ ì¹´ìš´í„° ë¦¬ì…‹
                consecutive_errors = 0
                
                # 30ì´ˆë§ˆë‹¤ ì‹¤í–‰
                await asyncio.sleep(SystemConfig.MONITORING["metrics_interval"])
                
            except Exception as e:
                consecutive_errors += 1
                logging.error(f"ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì˜¤ë¥˜ ({consecutive_errors}/{max_consecutive_errors}): {e}")
                
                if consecutive_errors >= max_consecutive_errors:
                    logging.critical("ëª¨ë‹ˆí„°ë§ ë£¨í”„ ì¤‘ë‹¨ (ìµœëŒ€ ì˜¤ë¥˜ íšŸìˆ˜ ì´ˆê³¼)")
                    try:
                        await self.telegram.send_system_notification(
                            "ëª¨ë‹ˆí„°ë§ ì‹œìŠ¤í…œ ì¤‘ë‹¨", "CRITICAL"
                        )
                    except:
                        pass
                    break
                
                # ì§€ìˆ˜ì  ë°±ì˜¤í”„
                await asyncio.sleep(min(60 * consecutive_errors, 300))  # ìµœëŒ€ 5ë¶„

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸš€ ì„œë²„ ì‹¤í–‰
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async def main():
    """ë©”ì¸ ì‹¤í–‰ í•¨ìˆ˜ (ì˜¤ë¥˜ ì²˜ë¦¬ ê°•í™”)"""
    try:
        # ë¡œê¹… ì„¤ì •
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler('phoenix95_ultimate.log'),
                logging.StreamHandler(sys.stdout)
            ]
        )
        
        # ì‹œìŠ¤í…œ ì‹œì‘ ë©”ì‹œì§€
        print("=" * 80)
        print("ğŸ¯ Phoenix 95 Ultimate Trading System (ì˜¤ë¥˜ ìˆ˜ì • ë²„ì „)")
        print("ğŸ’° V3 ê²€ì¦ëœ ì•Œê³ ë¦¬ì¦˜ + V4 ê³ ê¸‰ ê¸°ëŠ¥ + í—¤ì§€í€ë“œê¸‰ ì•ˆì „ì„±")
        print("âš¡ Wall Streetê¸‰ íŠ¸ë ˆì´ë”© ì‹œìŠ¤í…œ")
        print("ğŸ”§ ë³´ì•ˆ ê°•í™”, ë¡œì§ ìˆ˜ì •, ì¤‘ë³µ ì œê±°, ë¬´í•œë£¨í”„ ë°©ì§€")
        print("=" * 80)
        
        # Phoenix 95 ì‹œìŠ¤í…œ ìƒì„±
        phoenix95_system = Phoenix95UltimateSystem()
        
        # FastAPI ì„œë²„ ì‹¤í–‰
        config = uvicorn.Config(
            phoenix95_system.app,
            host="0.0.0.0",
            port=int(os.getenv("PORT", "8080")),
            log_level="info",
            access_log=True
        )
        
        server = uvicorn.Server(config)
        await server.serve()
        
    except EnvironmentError as e:
        print(f"\nâŒ í™˜ê²½ì„¤ì • ì˜¤ë¥˜:\n{e}")
        print("\nğŸ“ .env íŒŒì¼ ì˜ˆì‹œ:")
        print("TELEGRAM_BOT_TOKEN=your_bot_token")
        print("TELEGRAM_CHAT_ID=your_chat_id")
        print("WEBHOOK_SECRET=your_secret")
        print("API_KEY=your_api_key")
        print("JWT_SECRET=your_jwt_secret")
        sys.exit(1)
    except ValueError as e:
        print(f"\nâŒ ì„¤ì •ê°’ ì˜¤ë¥˜: {e}")
        sys.exit(1)

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        print("\nğŸ‘‹ Phoenix 95 Ultimate ì‹œìŠ¤í…œ ì¢…ë£Œ")
    except Exception as e:
        print(f"\nâŒ ì‹œìŠ¤í…œ ì˜¤ë¥˜: {e}")
        sys.exit(1)

# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
#                              ğŸ“‹ ìˆ˜ì • ì™„ë£Œ ë³´ê³ ì„œ
# â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

"""
ğŸ”§ ì£¼ìš” ìˆ˜ì • ì‚¬í•­ ìš”ì•½:

1. ğŸ”’ ë³´ì•ˆ ê°•í™”:
   - ë¯¼ê° ì •ë³´ í•˜ë“œì½”ë”© ì œê±° (í…”ë ˆê·¸ë¨ í† í°, ì±„íŒ… ID)
   - JWT ì‹œí¬ë¦¿ ê³ ì • ì‚¬ìš©ìœ¼ë¡œ í† í° ë¬´íš¨í™” ë°©ì§€
   - í™˜ê²½ë³€ìˆ˜ í•„ìˆ˜ ê²€ì¦ ê°•í™”
   - ê¸°ë³¸ê°’ None ì²˜ë¦¬ë¡œ ë³´ì•ˆ ê°•í™”

2. ğŸ› ë¡œì§ ì˜¤ë¥˜ ìˆ˜ì •:
   - ì‹œê°„ëŒ€ ì¡°ê±´ ìˆ˜ì •: elif hour >= 21 or hour <= 5 (ê¸°ì¡´ ë¶ˆê°€ëŠ¥í•œ ì¡°ê±´ ìˆ˜ì •)
   - ë¬´í•œë£¨í”„ ë°©ì§€: ìµœëŒ€ ì¬ì‹œë„ íšŸìˆ˜ ì œí•œ ë° íšŒë¡œ ì°¨ë‹¨ê¸° íŒ¨í„´
   - íƒ€ì… ì•ˆì •ì„± ê°•í™”: Optional í•„ë“œ None ì²´í¬ ì¶”ê°€

3. ğŸ”„ ì¤‘ë³µ ì½”ë“œ ì œê±°:
   - í™˜ê²½ë³€ìˆ˜ ë¡œë”© í†µí•© (ìµœìš°ì„  í•œ ë²ˆë§Œ ì‹¤í–‰)
   - ë©”íŠ¸ë¦­ ìˆ˜ì§‘ í†µí•© (unified_trading_metrics)
   - ë°ì´í„°ë² ì´ìŠ¤ ì¿¼ë¦¬ í†µí•©

4. ğŸ—ï¸ ì•„í‚¤í…ì²˜ ê°œì„ :
   - íƒ€ì… íŒíŠ¸ ê°•í™” (Union, Optional ëª…ì‹œ)
   - ì˜ˆì™¸ ì²˜ë¦¬ êµ¬ì²´í™” (ValueError, TypeError ë“±)
   - ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ë°©ì§€ (ìºì‹œ í¬ê¸° ì œí•œ, TTL ì ìš©)

5. âš¡ ì„±ëŠ¥ ë° ì•ˆì •ì„± í–¥ìƒ:
   - ì—°ê²° íƒ€ì„ì•„ì›ƒ ë° ì¬ì‹œë„ ë¡œì§ ì¶”ê°€
   - ë ˆì´íŠ¸ ë¦¬ë¯¸íŒ… ë° ì•Œë¦¼ ì¿¨ë‹¤ìš´ ê°•í™”
   - ì§€ìˆ˜ì  ë°±ì˜¤í”„ íŒ¨í„´ ì ìš©
   - ì•ˆì „í•œ ê³„ì‚° (ZeroDivisionError ë°©ì§€)

6. ğŸ“Š ëª¨ë‹ˆí„°ë§ ê°•í™”:
   - êµ¬ì¡°í™”ëœ ì˜¤ë¥˜ ë¡œê¹…
   - í¬ê´„ì  í—¬ìŠ¤ì²´í¬
   - ì—°ì† ì˜¤ë¥˜ ì œí•œ ë° ìë™ ë³µêµ¬

ì›ë³¸ ëŒ€ë¹„ ëˆ„ë½ ê¸°ëŠ¥: ì—†ìŒ (ëª¨ë“  ê¸°ëŠ¥ ìœ ì§€í•˜ë©´ì„œ ì•ˆì •ì„± ê°•í™”)
"""